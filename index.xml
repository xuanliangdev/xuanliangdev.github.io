<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xuanliang</title>
    <link>https://xuanliangdev.github.io/</link>
    <description>Recent content on xuanliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 03 Aug 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://xuanliangdev.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://xuanliangdev.github.io/about/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/about/</guid>
      
        <description>

&lt;h2 id=&#34;如果你有理想在远方-就不要被路边的风景影响了前进的速度-因为人的时间是有限的&#34;&gt;——如果你有理想在远方，就不要被路边的风景影响了前进的速度，因为人的时间是有限的。&lt;/h2&gt;

&lt;p&gt;来小米差一个月就满一年了，与来之前的雄心壮志相比，进步之缓慢超出了预期，主要还是没有定下切实的目标并坚持执行，没有在繁忙的杂活中或者抽出空闲时间总结提升，甚至从今年4月中旬开始胡思乱想到了现在，迷失了自己，浪费了3个半月，今天开始重新制定半年计划并执行，尽一切努力排除杂念💪。&lt;/p&gt;

&lt;p&gt;人没有目标就会胡思乱想，有了目标就要切实执行，不然就会停滞不前甚至倒退。&lt;/p&gt;

&lt;p&gt;今天是2019年8月3日，体检发现甲状腺结节，还好是良性的。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>preference体系学习总结</title>
      <link>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>

&lt;h1 id=&#34;1-preference体系学习总结&#34;&gt;1.preference体系学习总结&lt;/h1&gt;

&lt;p&gt;类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNbRwgy1fx3akmgz13j31cg133k17.jpg&#34; alt=&#34;preferenceclass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一部分主要学习了preference体系的相关知识（类图中蓝色和绿色部分）&lt;/p&gt;

&lt;h2 id=&#34;1-1-数据结构描述&#34;&gt;1.1 数据结构描述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.1.1&lt;/strong&gt; &lt;strong&gt;preference&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;设置的基石，简单来讲可以认为是设置列表中的每一个项目。&lt;/p&gt;

&lt;p&gt;其中有个重要的方法getView，这个方法返回的View将会被添加到PreferenceFragment或PreferenceActivity里&lt;/p&gt;

&lt;p&gt;作用：提供一个view给即将被展示的activity并且关联一个sharepreferences来保存或取出preference数据，其他常用的preference子类都继承于该类从而进行view样式的改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.2（v7包的Preference）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;去除了getView方法，增加了继承于RecycleView.ViewHolder的PreferenceViewHolder类&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1.1.3&lt;/strong&gt; &lt;strong&gt;PreferenceGroup&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;继承于PreferenceGroup，内部维护了一个元素为Preference的List，和Preference的关系类似于View和ViewGroup一样，采用了组合模式进行组织。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4（v7包的PreferenceGroup）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与旧实现类似，改动不大&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1.1.5&lt;/strong&gt; &lt;strong&gt;PreferenceScreen&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;继承于PreferenceGroup，是一个界面的root节点。当一个PreferenceScreen嵌套在另一个PreferenceScreen内部时会以Dialog的形式开启一个新的界面进行显示。&lt;/p&gt;

&lt;p&gt;内部持有一个listView，一个listAdapter（PreferenceGroupAdapter），持有一个layout文件&amp;rdquo;com.android.internal.R.layout.preference_list_fragment&amp;rdquo;的id，还有一个Dialog，用于展示嵌套的preferenceScreen&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.6 （v7包的PreferenceScreen）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与旧实现对比解耦了关联的View体系的东西，更加简洁。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1.1.7 PreferenceManager&lt;/strong&gt; ：&lt;/p&gt;

&lt;p&gt;管理类，用XmlPullParser遍历解析xml文件来创建preference。&lt;/p&gt;

&lt;p&gt;1.重要的属性&lt;/p&gt;

&lt;p&gt;activity，fragment，sharepreference，preferenceDataStore，preferenceScreen；&lt;/p&gt;

&lt;p&gt;关联了一个根布局“PreferenceScreen”，和SharedPreference进行交互。&lt;/p&gt;

&lt;p&gt;2.重要的方法&lt;/p&gt;

&lt;p&gt;inflateFromResource：通过PreferenceInflater（继承于GenericInflater）递归地扫描xml文件取出所有节点信息来构建出PreferenceScreen对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.8 （v14包的PreferenceManager）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;增加了一些接口OnDisplayPreferenceDialogListener、OnNavigateToScreenListener&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1.1.9 PreferenceFragment：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于显示preference对象列表&lt;/p&gt;

&lt;p&gt;持有一个listView，最终会关联到PreferenceScreen的listView，实现了onPreferenceTreeClick接口，这个接口会在ListView的项被点击时回调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.10（v14包的PreferenceFragment）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与旧实现相比改动较大。主要是采用了RecyclerView并且实现了一些Dialog的接口。&lt;/p&gt;

&lt;p&gt;关联了recycleView和preferenceManager&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1.1.11 PreferenceActivity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;继承于ListActivity，重要的内部类&lt;/p&gt;

&lt;p&gt;Header：&lt;/p&gt;

&lt;p&gt;Header包含的属性：&lt;/p&gt;

&lt;p&gt;1.title； 2.summary；3.icon；4.fragment；5.intent；6.bundle；&lt;/p&gt;

&lt;p&gt;HeaderAdapter&lt;/p&gt;

&lt;p&gt;HeaderAdapter包含的属性：1.icon；2.title；3.summary&lt;/p&gt;

&lt;p&gt;从这个adapter和layout布局(preference_header_item.xml)可以看出一个header只有这三项。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-2-preferencefragment加载xml源码分析-旧&#34;&gt;1.2 PreferenceFragment加载xml源码分析（旧）&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNbRwgy1fwwaqbe99dj30ul14l76u.jpg&#34; alt=&#34;PreferenceFragmentBuild&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重要流程说明：&lt;/p&gt;

&lt;p&gt;第8步：PreferenceInflater是一个xml解析器，通过解析xml取出节点，然后反射生成PreferenceScreen对象&lt;/p&gt;

&lt;h2 id=&#34;1-3-preferencefragment点击事件触发流程-旧&#34;&gt;1.3  PreferenceFragment点击事件触发流程（旧）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            Preference的performClick
                PreferenceManager.OnPreferenceTreeClickListener的onPreferenceTreeClick
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-4-preferenceactivity加载xml源码分析&#34;&gt;1.4 PreferenceActivity加载xml源码分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fwgb5lgqgfj30ol0ktab8.jpg&#34; alt=&#34;preferenceActivityonCreate&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重要流程说明：&lt;/p&gt;

&lt;p&gt;第4步：生成Header的方式也是通过xml解析器解析xml的header节点然后反射生成Header对象。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;无论是新的loadHeadersFromResource还是旧的addPreferencesFromResource，底层解析xml都用的XmlPullParser类。&lt;/p&gt;

&lt;h2 id=&#34;1-5-preferenceactivity点击事件触发流程&#34;&gt;1.5. PreferenceActivity点击事件触发流程&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp    
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            ListActivity里的onListItemClick
                PreferenceAcitvity里的onHeaderClick
                    然后根据fragment是否为空来执行switchToHeader或者startActivity
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;2-aosp中setting模块学习总结&#34;&gt;2.aosp中Setting模块学习总结&lt;/h1&gt;

&lt;p&gt;类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNbRwgy1fx3akmgz13j31cg133k17.jpg&#34; alt=&#34;preferenceclass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;主要分析只在系统Settings中使用的部分（除去上面分析过的蓝色和绿色部分）&lt;/p&gt;

&lt;h4 id=&#34;2-1-settings主页面的显示分析&#34;&gt;2.1 Settings主页面的显示分析：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNbRwgy1fwv0gkkantj309c0ibmz4.jpg&#34; alt=&#34;pscreen&#34; /&gt;&lt;/p&gt;

&lt;p&gt;aosp中P版本设置界面如上图所示，除去没显示的，主界面中一共展示了12个列表项，先分析列表项，后面再分析搜索和suggestion项。&lt;/p&gt;

&lt;p&gt;主Activity为Settings，继承于SettingsActivity，内部包含一个DashboardSummary的Fragment，从类图上看出DashboardSummary并没有用到preference的那一套东西。布局也相对简单，只有一个FocusRecyclerView，页面的布局由DashboardAdapter负责，DashboardAdapter用到的所有数据由DashboardData进行描述。这里只分析DashboardData中的DashboardCategory，也就是12个列表项所属的DashboardCategory，对于设置主界面来说只有一个DashboardCategory，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta-data android:name=&amp;quot;com.android.settings.category&amp;quot;
    android:value=&amp;quot;com.android.settings.category.ia.homepage&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从android manifest中也可以看到12个这样的数据，代表主界面的12个列表项。&lt;/p&gt;

&lt;p&gt;从类图中可以看出一个列表项由&lt;strong&gt;Tile&lt;/strong&gt;这样一个数据结构进行描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Tile implements Parcelable {
    public CharSequence title;
    public CharSequence summary;
    public Icon icon;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DashboardCategory&lt;/strong&gt;表示一个类别，持有一个元素为Tile的List表；&lt;/p&gt;

&lt;p&gt;可以发现Dashboard和Preference有很多相似的地方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Base fragment for dashboard style UI containing a list of static and dynamic setting items.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从注释可以看出DashboardFragment是为了动态加载而设计的，相对于Preference是静态地从xml文件中解析读取的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CategoryManager&lt;/strong&gt;主要是对DashboardCategory进行管理，内部会借助于&lt;strong&gt;TileUtils&lt;/strong&gt;来生成DashboardCategory对象，在生成DashboardCategory对象时会借助PackageManager来查询手机中的安装包信息来进行分析，来动态决定是否展示一些项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DashboardFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;DashboardFeatureProvider&lt;/strong&gt;接口，持有CategoryManager对象，通过CategoryManager对象进行Category的获取&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SuggestionFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;SuggestionFeatureProvider&lt;/strong&gt;接口，应该是用于获取推荐信息，后面再分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FeatureFactoryImpl&lt;/strong&gt;实现了&lt;strong&gt;FeatureFactory&lt;/strong&gt;接口，通过反射生成，用于生成DashboardFeatureProviderImpl和SuggestionFeatureProviderImpl等一些FeatureProvider对象。&lt;/p&gt;

&lt;p&gt;整个设置主界面加载流程大致如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNbRwgy1fww0pjn6xtj31kw1oewmo.jpg&#34; alt=&#34;dashboardsummary&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中绿色为主线程，其他线程为后台线程。&lt;/p&gt;

&lt;p&gt;对于流程做个简单的分析。&lt;/p&gt;

&lt;h5 id=&#34;1-settingsactivity的oncreate流程&#34;&gt;1. SettingsActivity的onCreate流程&lt;/h5&gt;

&lt;p&gt;在这个过程中会进行FeatureFactory、DashboardFeatureProvider、CategoryManager的初始化，并且如果判断是主界面，则启动DashboardSummary这个Fragment。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 DashboardSummary在onAttach中会创建SuggestionFeatureProvider，使之来进行推荐功能的实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1.2 DashboardSummary在onCreate中会成创建DashboardFeatureProvider，以及新建一个SummaryLoader，用&amp;rdquo;om.android.settings.category.ia.homepage&amp;rdquo;来作为CategoryKey，SummaryLoader构造时会启动一个HandlerThread来在后台运行，以便随时接受主线程发过来的消息从而触发SummaryProvider的setListening方法进行Summary的更新，比如更新存储空间或者电量的百分比，或者根据不同的手机特性显示不同的Summary，比如在安全设置Fragment中对于支持指纹的手机显示&amp;rdquo;屏幕锁定、指纹&amp;rdquo;，不支持指纹的手机仅显示&amp;rdquo;屏幕锁定&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1.3  DashboardSummary在onCreateView中会进行view相关的处理，rootview为R.layout.dashboard，这个view中只有一个简单的RecycleView，创建DashboardAdapter，执行rebuildUI方法，该方法启动一个后台线程调用updateCategory来进行Category的更新，更新完毕通过notifyDashboardDataChanged通知主线程进行view的更新，如果需要加载推荐项，推荐项没加载，则向主线程发送一个延迟更新view的消息，通过Handler的postDelayed方法实现。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-settingsactivity的onresume流程&#34;&gt;2. SettingsActivity的onResume流程&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.1 这个方法首先会在父类SettingsDrawerActivity的onResume中执行CategoriesUpdateTask，来在后台更新所有的Categories，调用完毕后回主线程调用CategoryListener接口的onCategoriesChanged方法，DashboardFrament和DashboardSummary实现了该接口来进行Category的刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.2 SettingsAcitvity在重写onResume后再次向AsyncTask中post一个doUpdateTilesList的方法，这个方法会排在CategoriesUpdateTask之后执行，也是用来更新Categories的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.3 在DashboardSummary的onResume中，会调用SummaryLoader的setListening方法，这个方法会向HandlerThread中post消息，分析这个消息类型MSG_GET_CATEGORY_TILES_AND_SET_LISTENING，对应时序图的47步，在后台线程获取到category后，遍历所有的tile，调用makeProviderW方法，因为所有该category下的Fragment都实现了SummaryProvider以及SummaryLoader.SummaryProviderFactory，SummaryProvider实现了SummaryLoader.SummaryProvider接口，因此通过tile找到相关的factory后，再通过反射生成SummaryProvider对象，如时序图的52步。紧接着在setListeningW中遍历调用所有的SummaryProvider的setListening方法，这个方法进一步触发SummaryLoader的setSummary方法来进行各个列表项summary的动态变化，比如电量的更新等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setSummary(SummaryProvider provider, final CharSequence summary) {
  final ComponentName component = mSummaryProviderMap.get(provider);
  ThreadUtils.postOnMainThread(() -&amp;gt; {
  
      final Tile tile = getTileFromCategory(
              mDashboardFeatureProvider.getTilesForCategory(mCategoryKey), component);
  
      if (tile == null) {
          if (DEBUG) {
              Log.d(TAG, &amp;quot;Can&#39;t find tile for &amp;quot; + component);
          }
          return;
      }
      if (DEBUG) {
          Log.d(TAG, &amp;quot;setSummary &amp;quot; + tile.title + &amp;quot; - &amp;quot; + summary);
      }
  
      updateSummaryIfNeeded(tile, summary);
  });
}
  
@VisibleForTesting
void updateSummaryIfNeeded(Tile tile, CharSequence summary) {
  if (TextUtils.equals(tile.summary, summary)) {
      if (DEBUG) {
          Log.d(TAG, &amp;quot;Summary doesn&#39;t change, skipping summary update for &amp;quot; + tile.title);
      }
      return;
  }
  mSummaryTextMap.put(mDashboardFeatureProvider.getDashboardKeyForTile(tile), summary);
  tile.summary = summary;
  if (mSummaryConsumer != null) {
      mSummaryConsumer.notifySummaryChanged(tile);
  } else {
      if (DEBUG) {
          Log.d(TAG, &amp;quot;SummaryConsumer is null, skipping summary update for &amp;quot;
                  + tile.title);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而在SummaryLoader的setSummary方法中再通过SummaryConsumer接口的notifySummaryChanged方法进行界面的更新，对于主界面来说是DashboardAdapter实现了SummaryConsumer接口，会直接触发notifyItemChanged来进行view的更新（对于其他DashboardFragment的子类来说则是父类DashboardFragment实现了SummaryConsumer接口，会触发Preference的setSummary方法，这个方法会调用notifyChanged方法，进而触发OnPreferenceChangeInternalListener的onPreferenceChange方法，而PreferenceGroupAdapter实现了该接口，因而也会触发notifyItemChanged来进行view的更新）。&lt;/p&gt;

&lt;h3 id=&#34;2-2-securitysettings页面的显示流程分析&#34;&gt;2.2 SecuritySettings页面的显示流程分析：&lt;/h3&gt;

&lt;p&gt;Settings主界面的显示完全是动态的，而除去主界面其他的Fragment的显示则是动态和静态相结合，以要分析的SecuritySettings来说明。SecuritySettings的继承于DashboardFragment，而DashboardFragment主要就是用来加载动态和静态的item。DashboardFragment最终继承于PreferenceFragment，因此可以解析xml中配置的preference来进行显示，而且持有DashboardFeatureProviderImpl对象，因此也可以加载DashboardCategory中的Tile进行显示。&lt;/p&gt;

&lt;p&gt;SecuritySettings界面显示是这个样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNbRwgy1fww1moiavmj30990icwgc.jpg&#34; alt=&#34;securitysettings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;layout文件R.xml.security_dashboard_settings如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;PreferenceScreen
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:settings=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    android:key=&amp;quot;security_dashboard_page&amp;quot;
    android:title=&amp;quot;@string/security_settings_title&amp;quot;
    settings:initialExpandedChildrenCount=&amp;quot;9&amp;quot;&amp;gt;

    &amp;lt;!-- security_settings_status.xml --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;-10&amp;quot;
        android:key=&amp;quot;security_status&amp;quot;
        android:title=&amp;quot;@string/security_status_title&amp;quot; /&amp;gt;

    &amp;lt;PreferenceCategory
        android:order=&amp;quot;1&amp;quot;
        android:key=&amp;quot;dashboard_tile_placeholder&amp;quot; /&amp;gt;

    &amp;lt;!-- security section --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;10&amp;quot;
        android:key=&amp;quot;security_category&amp;quot;
        android:title=&amp;quot;@string/lock_settings_title&amp;quot;&amp;gt;  &amp;lt;!-- 设备安全性--&amp;gt;

        &amp;lt;com.android.settings.widget.GearPreference
            android:key=&amp;quot;unlock_set_or_change&amp;quot;
            android:title=&amp;quot;@string/unlock_set_unlock_launch_picker_title&amp;quot;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_lockscreen&amp;quot; /&amp;gt; &amp;lt;!-- 屏幕锁定--&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;lockscreen_preferences&amp;quot;
            android:title=&amp;quot;@string/lockscreen_settings_title&amp;quot; &amp;lt;!-- 锁屏时的偏好设置--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            android:fragment=&amp;quot;com.android.settings.security.LockscreenDashboardFragment&amp;quot; /&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;fingerprint_settings&amp;quot;
            android:title=&amp;quot;@string/security_settings_fingerprint_preference_title&amp;quot; &amp;lt;!-- 指纹--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_fingerprint_settings&amp;quot;/&amp;gt;

    &amp;lt;/PreferenceCategory&amp;gt;
....

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码里会解析这个xml文件来构造PreferenceScreen对象。&lt;/p&gt;

&lt;p&gt;从图里看到并没有显示锁屏时的偏好设置这一个Preference的条目，从源码分析是LockScreenPreferenceController这个类动态的改变了这一个Preference的显示状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public int getAvailabilityStatus() {
        if (!mLockPatternUtils.isSecure(MY_USER_ID)) {
            return mLockPatternUtils.isLockScreenDisabled(MY_USER_ID)
                    ? DISABLED_FOR_USER : AVAILABLE;
        } else {
            return mLockPatternUtils.getKeyguardStoredPasswordQuality(MY_USER_ID)
                    == PASSWORD_QUALITY_UNSPECIFIED
                    ? DISABLED_FOR_USER : AVAILABLE;
        }
    }

    @Override
    public void updateState(Preference preference) {
        preference.setSummary(
                LockScreenNotificationPreferenceController.getSummaryResource(mContext));
    }

    @Override
    public void onResume() {
        mPreference.setVisible(isAvailable());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而这三个item其实是通过动态从DashboardTiles中取出来的。下面简单分析SecuritySettings的显示过程，主要是DashboardFragment的流程分析。&lt;/p&gt;

&lt;h4 id=&#34;2-2-1-dashboardfragmenet的onattach流程&#34;&gt;2.2.1.DashboardFragmenet的onAttach流程&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mDashboardFeatureProvider = FeatureFactory.getFactory(context).
            getDashboardFeatureProvider(context);
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
    // Load preference controllers from code
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllersFromCode =
            createPreferenceControllers(context);
    // Load preference controllers from xml definition
    final List&amp;lt;BasePreferenceController&amp;gt; controllersFromXml = PreferenceControllerListHelper
            .getPreferenceControllersFromXml(context, getPreferenceScreenResId());
    // Filter xml-based controllers in case a similar controller is created from code already.
    final List&amp;lt;BasePreferenceController&amp;gt; uniqueControllerFromXml =
            PreferenceControllerListHelper.filterControllers(
                    controllersFromXml, controllersFromCode);

    // Add unique controllers to list.
    if (controllersFromCode != null) {
        controllers.addAll(controllersFromCode);
    }
    controllers.addAll(uniqueControllerFromXml);
...

    mPlaceholderPreferenceController =
            new DashboardTilePlaceholderPreferenceController(context);
    controllers.add(mPlaceholderPreferenceController);
    for (AbstractPreferenceController controller : controllers) {
        addPreferenceController(controller);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法里主要是一些controllers的创建，这些controller可以从代码创建，也可以从xml解析获取，&lt;/p&gt;

&lt;p&gt;在SecuritySettings里通过代码创建了一些controller，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private static List&amp;lt;AbstractPreferenceController&amp;gt; buildPreferenceControllers(Context context,
            Lifecycle lifecycle, SecuritySettings host) {
        final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
        controllers.add(new LocationPreferenceController(context, lifecycle));
        controllers.add(new ManageDeviceAdminPreferenceController(context));
        controllers.add(new EnterprisePrivacyPreferenceController(context));
        controllers.add(new ManageTrustAgentsPreferenceController(context));
        ...

        return controllers;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在xml中是通过声明settings:controller属性来创建的，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;SwitchPreference
    android:key=&amp;quot;visiblepattern_profile&amp;quot;
    android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
    android:title=&amp;quot;@string/lockpattern_settings_enable_visible_pattern_title_profile&amp;quot;
    settings:controller=&amp;quot;com.android.settings.security.VisiblePatternProfilePreferenceController&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-1-dashboardfragmenet的oncreate流程&#34;&gt;2.2.1.DashboardFragmenet的onCreate流程&lt;/h4&gt;

&lt;p&gt;DashboardFragmenet最终继承于v14包里的PreferenceFragment的onCreate方法，里面会调用onCreatePreferences方法，DashboardFragmenet重写了onCreatePreferences方法，进而调用refreshAllPreferences方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Refresh all preference items, including both static prefs from xml, and dynamic items from
 * DashboardCategory.
 */
private void refreshAllPreferences(final String TAG) {
    // First remove old preferences.
    if (getPreferenceScreen() != null) {
        // Intentionally do not cache PreferenceScreen because it will be recreated later.
        getPreferenceScreen().removeAll();
    }

    // Add resource based tiles.
    displayResourceTiles();

    refreshDashboardTiles(TAG);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从注释可以看出这个方法是这个Fragment显示流程的核心。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Displays resource based tiles.
 */
private void displayResourceTiles() {
    final int resId = getPreferenceScreenResId();
    if (resId &amp;lt;= 0) {
        return;
    }
    addPreferencesFromResource(resId);
    final PreferenceScreen screen = getPreferenceScreen();
    mPreferenceControllers.values().stream().flatMap(Collection::stream).forEach(
            controller -&amp;gt; controller.displayPreference(screen));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;displayResourceTiles这个方法首先获取了PreferenceScreen，然后通过循环调用了每个controller的displayPreference方法&lt;/p&gt;

&lt;p&gt;以上面说的LockScreenPreferenceController为例，LockScreenPreferenceController继承于BasePreferenceController，因此会调用如下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Displays preference in this controller.
 */
@Override
public void displayPreference(PreferenceScreen screen) {
    super.displayPreference(screen);
    if (getAvailabilityStatus() == DISABLED_DEPENDENT_SETTING) {
        // Disable preference if it depends on another setting.
        final Preference preference = screen.findPreference(getPreferenceKey());
        if (preference != null) {
            preference.setEnabled(false);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从而来决定一个preference是否该显示。&lt;/p&gt;

&lt;p&gt;执行完displayResourceTiles后接着会执行refreshDashboardTiles方法，从注释也可以看出这个方法是用来展示动态DashboardCategory的item的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Refresh preference items backed by DashboardCategory.
 */
@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
void refreshDashboardTiles(final String TAG) {
    final PreferenceScreen screen = getPreferenceScreen();

    final DashboardCategory category =
            mDashboardFeatureProvider.getTilesForCategory(getCategoryKey());
    ...
    final List&amp;lt;Tile&amp;gt; tiles = category.getTiles();
    ...
    mSummaryLoader = new SummaryLoader(getActivity(), getCategoryKey());
    mSummaryLoader.setSummaryConsumer(this);
    ...
    // Install dashboard tiles.
    for (Tile tile : tiles) {
        final String key = mDashboardFeatureProvider.getDashboardKeyForTile(tile);
        ...
        if (mDashboardTilePrefKeys.contains(key)) {
            // Have the key already, will rebind.
            ....
        } else {
            // Don&#39;t have this key, add it.
            final Preference pref = new Preference(getPrefContext());
            mDashboardFeatureProvider.bindPreferenceToTile(getActivity(), getMetricsCategory(),
                    pref, tile, key, mPlaceholderPreferenceController.getOrder());
            screen.addPreference(pref);
            mDashboardTilePrefKeys.add(key);
        }
        remove.remove(key);
    }
    ...
    mSummaryLoader.setListening(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5-11行取出相关key的tile对象。对于SecuritySettings来说key是&amp;rdquo;com.android.settings.category.ia.security&amp;rdquo;，三个tile的title为“Google Play 保护机制、查找我的设备、安全更新”，如前面一节所介绍的，这三项是从gms服务中取出的，并不是Settings app本身内置的，因此可以看作是动态加载。&lt;/p&gt;

&lt;p&gt;13行创建了一个SummaryLoader对象，从之前的分析可知，会创建一个HandlerThread置于后台运行。&lt;/p&gt;

&lt;p&gt;14行把自己设置为SummaryConsumer接口对象，当SummaryLoader后台更新完，会调用setListeningW，这个方法又会取出所有满足要求的SummaryProvider去执行setListening方法，SummaryProvider又会反过来调用SummaryLoader的setSummary方法，SummaryLoader这时会post一个updateSummaryIfNeeded方法到主线程执行，而这个方法会取出mSummaryConsumer也就是DashboardFragment去执行notifySummaryChanged方法，这个方法会获取tile关联的preference，执行其setSummary方法，这个方法又会调用notifyChanged方法，这个方法调用OnPreferenceChangeInternalListener接口的onPreferenceChange方法，而PreferenceGroupAdapter实现了这个接口，因此最终通过PreferenceGroupAdapter实现了view中Summary的更新。&lt;/p&gt;

&lt;p&gt;25-29行创建Preference对象，并且将Preference和Tile进行绑定，然后添加到PreferenceScreen中。&lt;/p&gt;

&lt;p&gt;34行调用SummaryLoader的setListening方法，从前面一节分析可知，这个操作会往后台HandlerThread发送一个消息，从而在后台监听Summary是否有更新&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private SummaryProvider getSummaryProvider(Tile tile) {
    if (!mActivity.getPackageName().equals(tile.intent.getComponent().getPackageName())) {
        // Not within Settings, can&#39;t load Summary directly.
        // TODO: Load summary indirectly.
        return null;
    }
    ...
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在SummaryLoader的getSummaryProvider方法第二行中当前包名为com.android.settings，而tile的包名为com.google.android.gms，因此返回空，从注释也可以看出，如果当前的tile不在Settings应用中，是不能获取到SummaryProvider的。因此后面的通知Adapter进行Summary的刷新操作也就不会执行了，&lt;/p&gt;

&lt;h1 id=&#34;3-aosp-8-0-settingssearch分析&#34;&gt;3.aosp 8.0 SettingsSearch分析&lt;/h1&gt;

&lt;p&gt;类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNbRwgy1fx3eqhh74zj30u017aqc3.jpg&#34; alt=&#34;aospsearchclass&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-1搜索的数据源&#34;&gt;3.1搜索的数据源&lt;/h2&gt;

&lt;p&gt;SearchIndexableData:用于搜索的可索引数据&lt;/p&gt;

&lt;p&gt;SearchIndexableResource：xml资源&lt;/p&gt;

&lt;p&gt;SearchIndexableRaw：原始数据&lt;/p&gt;

&lt;p&gt;BaseColumns：基类，rank排名，className类名，iconResId等；&lt;/p&gt;

&lt;p&gt;XmlResource：xml的资源id，关联SearchIndexableResource&lt;/p&gt;

&lt;p&gt;RawData：原始数据，title标题，summary概要等；关联SearchIndexableData&lt;/p&gt;

&lt;p&gt;NonIndexableKey：描述一个不能被索引的数据&lt;/p&gt;

&lt;p&gt;SearchIndexablesProvider：用于搜索的可索引provider的基类，用于给搜索提供preference的xml文件数据或者原始数据。&lt;/p&gt;

&lt;p&gt;以上的类除了SearchIndexableRaw外其他都位于framework包中；&lt;/p&gt;

&lt;p&gt;以下的类或接口位于settings中；&lt;/p&gt;

&lt;p&gt;Indexable.SearchIndexProvider：接口，其实现类的实例可以提供可索引的数据&lt;/p&gt;

&lt;p&gt;SettingsSearchIndexablesProvider：设置app中的content provider，实现了SearchIndexablesPrevider的相关搜索方法，在phone的app中也有一个类似的实现:PhoneSearchIndexablesProvider，从而可以在设置的搜索中找到Phone中的xml数据进行跳转&lt;/p&gt;

&lt;p&gt;BaseSearchIndexProvider：&lt;/p&gt;

&lt;p&gt;IndexDatabaseHelper：提供数据库的操作，数据库文件位于data/user_de/0/com.android.settings/databases/search_index.db&lt;/p&gt;

&lt;h2 id=&#34;3-2数据库构建过程&#34;&gt;3.2数据库构建过程&lt;/h2&gt;

&lt;p&gt;设置中的界面大部分都是通过xml文件中声明的Preference类的各种子类构建而成，页面打开时通过解析xml文件中的各个节点从而构建成listview中的各个item从而进行显示，以日期和时间页面DateTimeSettings为例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fx11cudlk5j307g0chjru.jpg&#34; alt=&#34;datatimephone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;构成这个界面的文件date_time_prefs.xml如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;

&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
        xmlns:settings=&amp;quot;http://schemas.android.com/apk/res/com.android.settings&amp;quot;
        android:title=&amp;quot;@string/date_and_time&amp;quot; 
        settings:keywords=&amp;quot;@string/keywords_date_and_time&amp;quot;&amp;gt;

    &amp;lt;com.android.settingslib.RestrictedSwitchPreference android:key=&amp;quot;auto_time&amp;quot;
        android:title=&amp;quot;@string/date_time_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/date_time_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/date_time_auto_summaryOff&amp;quot;
        settings:useAdditionalSummary=&amp;quot;true&amp;quot;
        settings:restrictedSwitchSummary=&amp;quot;@string/enabled_by_admin&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;auto_zone&amp;quot;
        android:title=&amp;quot;@string/zone_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/zone_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/zone_auto_summaryOff&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;date&amp;quot;
        android:title=&amp;quot;@string/date_time_set_date&amp;quot;
        android:summary=&amp;quot;03/10/2008&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;time&amp;quot;
        android:title=&amp;quot;@string/date_time_set_time&amp;quot;
        android:summary=&amp;quot;12:00am&amp;quot;
        /&amp;gt;

    &amp;lt;Preference
        android:fragment=&amp;quot;com.android.settings.datetime.ZonePicker&amp;quot;
        android:key=&amp;quot;timezone&amp;quot;
        android:title=&amp;quot;@string/date_time_set_timezone&amp;quot;
        android:summary=&amp;quot;GMT-8:00&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;24 hour&amp;quot;
        android:title=&amp;quot;@string/date_time_24hour&amp;quot;
        /&amp;gt;

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的xml文件的每一项跟界面展示是一一对应的，实际情况也可能不一样，可以通过配置一些属性或者代码动态增删一些项。&lt;/p&gt;

&lt;p&gt;title为显示的标题，summary为摘要，keywords为关键词（不直接显示，用于搜索），留意上面的settings:keywords=&amp;ldquo;@string/keywords_date_and_time&amp;rdquo;中keywords_date_and_time的值为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string name=&amp;quot;keywords_date_and_time&amp;quot; msgid=&amp;quot;758325881602648204&amp;quot;&amp;gt;&amp;quot;时钟, 军用&amp;quot;&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面写的是界面跟xml的关系，搜索过程是一个数据库的检索过程，因此搜索需要用到数据库，数据库数据的来源就是上面的xml文件，从模拟器取出search_index.db数据库观察，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNbRwgy1fx1282l0m3j30t40fpq77.jpg&#34; alt=&#34;searchdb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见xml的数据跟数据库中的记录也是一一对应的，因此搜索过程就是数据库的检索过程，输入搜索的字符串最终会转换成SQL数据库查询语句从而返回查询结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fx12ff9u4tj307j0d8aal.jpg&#34; alt=&#34;军用&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之所以搜索军用能出现日期和时间的结果，是因为“军用”是keyword的一部分&lt;/p&gt;

&lt;p&gt;设置中也能搜索其他app的数据，只要其实现了SearchIndexablesProvider，以phone的app为例，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PhoneSearchIndexablesProvider extends SearchIndexablesProvider {
    private static final String TAG = &amp;quot;PhoneSearchIndexablesProvider&amp;quot;;

    private static SearchIndexableResource[] INDEXABLE_RES = new SearchIndexableResource[] {
            new SearchIndexableResource(1, R.xml.network_setting_fragment,
                    MobileNetworkSettings.class.getName(),
                    R.mipmap.ic_launcher_phone),
    };

    ...

    @Override
    public Cursor queryXmlResources(String[] projection) {
        ....
    }
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样实现后（还需要在AndroidManifest里面做些配置），设置app就能跨进程取到network_setting_fragment.xml中的数据并加入search_index.db数据库，如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNbRwgy1fx12zl3typj30u30cc41w.jpg&#34; alt=&#34;phonedb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面简单分析下数据库的创建过程：&lt;/p&gt;

&lt;p&gt;刚进入设置创建数据库流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fx2a2t9qhzj31050t9gnq.jpg&#34; alt=&#34;aospsearchcreatedb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当点击搜索按钮后会启动SearchFragment&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mSearchFeatureProvider = FeatureFactory.getFactory(context).getSearchFeatureProvider();
    mMetricsFeatureProvider = FeatureFactory.getFactory(context).getMetricsFeatureProvider();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会创建mSearchFeatureProvider，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);

    final LoaderManager loaderManager = getLoaderManager();
    mSearchAdapter = new SearchResultsAdapter(this);
    mSavedQueryController = new SavedQueryController(
            getContext(), loaderManager, mSearchAdapter);
    mSearchFeatureProvider.initFeedbackButton();

    ...
    
    // Run the Index update only if we have some space
    if (!Utils.isLowStorage(activity)) {
        mSearchFeatureProvider.updateIndex(activity, this /* indexingCallback */);
    } else {
        Log.w(TAG, &amp;quot;Cannot update the Indexer as we are running low on storage space!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在onCreate中会执行索引过程，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void updateIndex(Context context, IndexingCallback callback) {
    long indexStartTime = System.currentTimeMillis();
    getIndexingManager(context).indexDatabase(callback);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着会执行IndexManager的indexDatabase方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void indexDatabase(IndexingCallback callback) {
    IndexingTask task = new IndexingTask(callback);
    task.execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启了一个台任务，IndexingTask是一个AsyncTask，后台执行performIndexing方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected Void doInBackground(Void... voids) {
    performIndexing();
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Accumulate all data and non-indexable keys from each of the content-providers.
 * Only the first indexing for the default language gets static search results - subsequent
 * calls will only gather non-indexable keys.
 */
@VisibleForTesting
void performIndexing() {
    final Intent intent = new Intent(SearchIndexablesContract.PROVIDER_INTERFACE);
    // 这里是返回手机中所有声明了action为&amp;quot;android.content.action.SEARCH_INDEXABLES_PROVIDER&amp;quot;的provider的信息，暂时只有三个应用做了这个声明，Settings，Phone和cellbroadcastreceiver，因此Settings的搜索中可以搜索到phone的app中的信息从而进行跳转。
    final List&amp;lt;ResolveInfo&amp;gt; list =
            mContext.getPackageManager().queryIntentContentProviders(intent, 0);

    String localeStr = Locale.getDefault().toString();
    String fingerprint = Build.FINGERPRINT;
    final boolean isFullIndex = isFullIndex(localeStr, fingerprint);

    if (isFullIndex) {
        rebuildDatabase();
    }

    for (final ResolveInfo info : list) {
        if (!DatabaseIndexingUtils.isWellKnownProvider(info, mContext)) {
            continue;
        }
        final String authority = info.providerInfo.authority;
        final String packageName = info.providerInfo.packageName;

        if (isFullIndex) {
        	加载外部app的索引
            addIndexablesFromRemoteProvider(packageName, authority);
        }
        addNonIndexablesKeysFromRemoteProvider(packageName, authority);
    }
	// 更新到数据库
    updateDatabase(isFullIndex, localeStr);
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-3数据搜索以及显示过程&#34;&gt;3.3数据搜索以及显示过程&lt;/h1&gt;

&lt;p&gt;在搜索框输入字符后，会回调到SearchFragment的onQueryTextChange方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public boolean onQueryTextChange(String query) {
    ...
    if (isEmptyQuery) {
        ...
    } else {
        restartLoaders();
    }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个搜索过程涉及到了Loader机制，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; onCreateLoader(int id, Bundle args) {
    final Activity activity = getActivity();

    switch (id) {
        case LOADER_ID_DATABASE:
            return mSearchFeatureProvider.getDatabaseSearchLoader(activity, mQuery);
        case LOADER_ID_INSTALLED_APPS:
            return mSearchFeatureProvider.getInstalledAppSearchLoader(activity, mQuery);
        default:
            return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Override
public List&amp;lt;? extends SearchResult&amp;gt; loadInBackground() {
    ...

    primaryFirstWordResults = firstWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[0]);
    primaryMidWordResults = secondaryWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[1]);
    secondaryResults = anyWordQuery(MATCH_COLUMNS_SECONDARY, BASE_RANKS[2]);
    tertiaryResults = anyWordQuery(MATCH_COLUMNS_TERTIARY, BASE_RANKS[3]);

    final List&amp;lt;SearchResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(
            primaryFirstWordResults.size()
            + primaryMidWordResults.size()
            + secondaryResults.size()
            + tertiaryResults.size());

    results.addAll(primaryFirstWordResults);
    results.addAll(primaryMidWordResults);
    results.addAll(secondaryResults);
    results.addAll(tertiaryResults);

    return removeDuplicates(results);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;private List&amp;lt;SearchResult&amp;gt; firstWordQuery(String[] matchColumns, int baseRank) {
    final String whereClause = buildSingleWordWhereClause(matchColumns);
    final String query = mQueryText + &amp;quot;%&amp;quot;;
    final String[] selection = buildSingleWordSelection(query, matchColumns.length);

    return query(whereClause, selection, baseRank);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(data_title like ?  OR data_title_normalized like ? ) AND enabled = 1&lt;/p&gt;

&lt;p&gt;日期%&lt;/p&gt;

&lt;p&gt;% 日期%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onLoadFinished(Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; loader,
        List&amp;lt;? extends SearchResult&amp;gt; data) {
    mSearchAdapter.addSearchResults(data, loader.getClass().getName());
    if (mUnfinishedLoadersCount.decrementAndGet() != 0) {
        return;
    }
    final int resultCount = mSearchAdapter.displaySearchResults();

    if (resultCount == 0) {
        mNoResultsView.setVisibility(View.VISIBLE);
    } else {
        mNoResultsView.setVisibility(View.GONE);
        mResultsRecyclerView.scrollToPosition(0);
    }
    mSearchFeatureProvider.showFeedbackButton(this, getView());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Merge the results from each of the loaders into one list for the adapter.
 * Prioritizes results from the local database over installed apps.
 *
 * @return Number of matched results
 */
public int displaySearchResults() {
    final List&amp;lt;? extends SearchResult&amp;gt; databaseResults = mResultsMap
            .get(DatabaseResultLoader.class.getName());
    final List&amp;lt;? extends SearchResult&amp;gt; installedAppResults = mResultsMap
            .get(InstalledAppResultLoader.class.getName());
    final int dbSize = (databaseResults != null) ? databaseResults.size() : 0;
    final int appSize = (installedAppResults != null) ? installedAppResults.size() : 0;
    final List&amp;lt;SearchResult&amp;gt; newResults = new ArrayList&amp;lt;&amp;gt;(dbSize + appSize);

    int dbIndex = 0;
    int appIndex = 0;
    int rank = TOP_RANK;

    while (rank &amp;lt;= BOTTOM_RANK) {
        while ((dbIndex &amp;lt; dbSize) &amp;amp;&amp;amp; (databaseResults.get(dbIndex).rank == rank)) {
            newResults.add(databaseResults.get(dbIndex++));
        }
        while ((appIndex &amp;lt; appSize) &amp;amp;&amp;amp; (installedAppResults.get(appIndex).rank == rank)) {
            newResults.add(installedAppResults.get(appIndex++));
        }
        rank++;
    }

    while (dbIndex &amp;lt; dbSize) {
        newResults.add(databaseResults.get(dbIndex++));
    }
    while (appIndex &amp;lt; appSize) {
        newResults.add(installedAppResults.get(appIndex++));
    }

    final DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(
            new SearchResultDiffCallback(mSearchResults, newResults), false /* detectMoves */);
    mSearchResults = newResults;
    diffResult.dispatchUpdatesTo(this);

    return mSearchResults.size();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public void dispatchUpdatesTo(final RecyclerView.Adapter adapter) {
    dispatchUpdatesTo(new ListUpdateCallback() {
        @Override
        public void onInserted(int position, int count) {
            adapter.notifyItemRangeInserted(position, count);
        }

        @Override
        public void onRemoved(int position, int count) {
            adapter.notifyItemRangeRemoved(position, count);
        }

        @Override
        public void onMoved(int fromPosition, int toPosition) {
            adapter.notifyItemMoved(fromPosition, toPosition);
        }

        @Override
        public void onChanged(int position, int count, Object payload) {
            adapter.notifyItemRangeChanged(position, count, payload);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>无障碍学习整理（基于talkback）</title>
      <link>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</guid>
      
        <description>

&lt;h2 id=&#34;一-疑问&#34;&gt;一、疑问：&lt;/h2&gt;

&lt;p&gt;1.无障碍机制涉及哪些模块？&lt;/p&gt;

&lt;p&gt;2.开启talkback后talkback手势生效原理？&lt;/p&gt;

&lt;p&gt;3.无障碍焦点的方框如何产生？&lt;/p&gt;

&lt;p&gt;4.talkback如何获取view的内容从而调用tts进行朗读？&lt;/p&gt;

&lt;p&gt;5.为什么实现了AccessibilityService的apk安装后设置无障碍就会出现相关的开关？&lt;/p&gt;

&lt;p&gt;6.打开某个页面时talkback的默认焦点怎么来的？&lt;/p&gt;

&lt;h2 id=&#34;二-结构分析&#34;&gt;二、结构分析&lt;/h2&gt;

&lt;h3 id=&#34;1-代码结构&#34;&gt;1.代码结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNc79gy1g1t8b1vx1zj317l0signa.jpg&#34; alt=&#34;无障碍架构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNc79gy1g1t8avpt29j30vh0u01kx.jpg&#34; alt=&#34;accessibilityclass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;整个talkback机制涉及了4个进程，SystemServer（蓝色部分）、Talkback（黄色部分）、前台app进程（绿色部分），TTS引擎进程（暂不分析）&lt;/p&gt;

&lt;p&gt;四个AIDL接口，图上红色部分&lt;/p&gt;

&lt;h4 id=&#34;1-1-talkback-辅助app-实现了accessibilityservice的app&#34;&gt;1.1、talkback（辅助app，实现了AccessibilityService的app）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNc79gy1g1qzm48qapj30b40abacc.jpg&#34; alt=&#34;WX20190404-224703@2x&#34; /&gt;&lt;/p&gt;

&lt;p&gt;talkback实现了AccessiblityService用于接收系统传过来的无障碍事件。&lt;/p&gt;

&lt;h4 id=&#34;1-2-前台app进程-被辅助app&#34;&gt;1.2、前台app进程（被辅助app）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNc79gy1g1r0sbx0bxj30b40b8421.jpg&#34; alt=&#34;viewaccessibility&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-3-system-process&#34;&gt;1.3、system_process&lt;/h4&gt;

&lt;p&gt;1.3.1（AccessibilityManagerService）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNc79gy1g1r04mvninj30b40d8q73.jpg&#34; alt=&#34;acms&#34; /&gt;&lt;/p&gt;

&lt;p&gt;系统进程SystemServer维护了ActivityManagerService，用来作为binder服务端，SystemServer启动时会启动AccessibilityManagerService。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.SystemServer.java

/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */
private void startOtherServices() {
...
            traceBeginAndSlog(&amp;quot;StartAccessibilityManagerService&amp;quot;);
            try {
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf(&amp;quot;starting Accessibility Manager&amp;quot;, e);
            }
            traceEnd();
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.3.2、TTS&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNc79gy1g1rg51wbiij30b40m0q9h.jpg&#34; alt=&#34;tts&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-语音引擎&#34;&gt;4.语音引擎&lt;/h4&gt;

&lt;p&gt;暂不分析&lt;/p&gt;

&lt;h3 id=&#34;1-2-aidl接口&#34;&gt;1.2 AIDL接口&lt;/h3&gt;

&lt;p&gt;跨进程通信的需要用到aidl，理解aidl的设计是理解无障碍框架的关键。&lt;/p&gt;

&lt;h4 id=&#34;1-2-1-iaccessibilityserviceclient&#34;&gt;1.2.1 、IAccessibilityServiceClient&lt;/h4&gt;

&lt;p&gt;服务端为辅助app进程（talkback），调用客户端为SystemServer进程。&lt;/p&gt;

&lt;p&gt;当SystemServer绑定AccessibilityService时，AccessibilityService会返回实现该接口的binder对象给SystemServer进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceClient.aidl

/**
 * Top-level interface to an accessibility service component.
 */
oneway interface IAccessibilityServiceClient {

    void onAccessibilityEvent(in AccessibilityEvent event, in boolean serviceWantsEvent);

    void onSoftKeyboardShowModeChanged(int showMode);

    void onPerformGestureResult(int sequence, boolean completedSuccessfully);

    void onAccessibilityButtonClicked();

    void onAccessibilityButtonAvailabilityChanged(boolean available);
    
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-2-iaccessibilityserviceconnection&#34;&gt;1.2.2、IAccessibilityServiceConnection&lt;/h4&gt;

&lt;p&gt;服务端为SystemServer进程，调用客户端为辅助app进程（talkback）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceConnection.aidl

/**
 * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
 */
interface IAccessibilityServiceConnection {

    String[] findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId,
        in Bundle arguments);

    String[] findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    String[] findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    boolean isAccessibilityButtonAvailable();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用于talkback和system_process之间，服务端为system_process（AccessibilityManagerService），客户端为talkback。&lt;/p&gt;

&lt;h4 id=&#34;1-2-3-iaccessibilitymanager&#34;&gt;1.2.3、IAccessibilityManager&lt;/h4&gt;

&lt;p&gt;服务端为SystemServer进程，调用客户端为被辅助app进程。&lt;/p&gt;

&lt;p&gt;当被辅助app产生触摸事件后，会通过这个接口发送无障碍事件给SystemServer进程的AccessibilityManagerService&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityManager.aidl

/**
 * Interface implemented by the AccessibilityManagerService called by
 * the AccessibilityManagers.
 *
 * @hide
 */
interface IAccessibilityManager {

    oneway void sendAccessibilityEvent(in AccessibilityEvent uiEvent, int userId);

    long addClient(IAccessibilityManagerClient client, int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getInstalledAccessibilityServiceList(int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getEnabledAccessibilityServiceList(int feedbackType, int userId);

    int addAccessibilityInteractionConnection(IWindow windowToken,
            in IAccessibilityInteractionConnection connection,
            String packageName, int userId);

    void removeAccessibilityInteractionConnection(IWindow windowToken);

    void notifyAccessibilityButtonClicked();

    // Requires WRITE_SECURE_SETTINGS
    void performAccessibilityShortcut();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-4-iaccessibilityinteractionconnection&#34;&gt;1.2.4、IAccessibilityInteractionConnection&lt;/h4&gt;

&lt;p&gt;服务端为被辅助app进程，调用客户端为SystemServer进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityInteractionConnection.aidl

/**
 * Interface for interaction between the AccessibilityManagerService
 * and the ViewRoot in a given window.
 *
 * @hide
 */
oneway interface IAccessibilityInteractionConnection {

    void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId, in Region bounds,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid, in MagnificationSpec spec,
        in Bundle arguments);

    ...

    void findFocus(long accessibilityNodeId, int focusType, in Region bounds, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
        long interrogatingTid, in MagnificationSpec spec);

  ...

    void performAccessibilityAction(long accessibilityNodeId, int action, in Bundle arguments,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-流程分析&#34;&gt;三、流程分析&lt;/h2&gt;

&lt;h3 id=&#34;1-talkback开关打开后到talkbackservice启动过程&#34;&gt;1、talkback开关打开后到TalkbackService启动过程。&lt;/h3&gt;

&lt;p&gt;1.1、在设置中打开talback开关后，会调用到如下方法，最终会往Settings provider中key为Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES的字段写入Talkback注册的AccessibilityService值（TalkbackService），这个值保存在&lt;/p&gt;

&lt;p&gt;/data/system/users/0/settings_secure.xml文件中。（其他app的AccessibilityService也保存在同一个key中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.settingslib.accessibility.AccessibilityUtils.java

/**
 * Changes an accessibility component&#39;s state for {@param userId}.
 */
public static void setAccessibilityServiceState(Context context, ComponentName toggledService,
        boolean enabled, int userId) {
    ...
    Settings.Secure.putStringForUser(context.getContentResolver(),
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
            enabledServicesBuilder.toString(), userId);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于AccessibilityManagerService创建时注册了AccessibilityContentObserver，因此马上会收到Settings provider数据变化的监听。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

private void updateServicesLocked(UserState userState) {
    ...
        if (userState.mEnabledServices.contains(componentName)
                &amp;amp;&amp;amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
            if (service == null) {
                service = new AccessibilityServiceConnection(userState, mContext, componentName,
                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                        this, mWindowManagerService, mGlobalActionPerformer);
            } 
            ...
            service.bindLocked();
        } ...
    }
    ...
    updateAccessibilityEnabledSetting(userState);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据获取到的AccessibilityService信息（com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService）创建出AccessibilityServiceConnection。AccessibilityServiceConnection代表了一个无障碍服务，存储用于管理这个服务需要的所有数据，提供了开始/停止服务和在服务管理的数据结构中添加或者移除这个服务的api。&lt;/p&gt;

&lt;p&gt;接着调用bindServiceAsUser方法来绑定服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

public void bindLocked() {
    ...
    try {
        ...
        if (mService == null &amp;amp;&amp;amp; mContext.bindServiceAsUser(
                mIntent, this, flags, new UserHandle(userState.mUserId))) {
            userState.getBindingServicesLocked().add(mComponentName);
        }
    } ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务启动后会跨进程调用到TalkbackService(AccessibilityService)的onBind方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.AccessibilityService

/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        ...
        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }
...
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onBind方法返回的是一个IAccessibilityServiceClientWrapper的binder对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Implements the internal {@link IAccessibilityServiceClient} interface to convert
 * incoming calls to it back to calls on an {@link AccessibilityService}.
 *
 * @hide
 */
public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
        implements HandlerCaller.Callback {
    ...

    private final HandlerCaller mCaller;

    private final Callbacks mCallback;

    private int mConnectionId = AccessibilityInteractionClient.NO_ID;

    public IAccessibilityServiceClientWrapper(Context context, Looper looper,
            Callbacks callback) {
        mCallback = callback;
        mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);
    }

    public void init(IAccessibilityServiceConnection connection, int connectionId,
            IBinder windowToken) {
        Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                connection, windowToken);
        mCaller.sendMessage(message);
    }

    ...

    public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {
        Message message = mCaller.obtainMessageBO(
                DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);
        mCaller.sendMessage(message);
    }
...

    @Override
    public void executeMessage(Message message) {
        switch (message.what) {
            case DO_ON_ACCESSIBILITY_EVENT: {
                AccessibilityEvent event = (AccessibilityEvent) message.obj;
                boolean serviceWantsEvent = message.arg1 != 0;
                if (event != null) {
                    // Send the event to AccessibilityCache via AccessibilityInteractionClient
                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);
                    if (serviceWantsEvent
                            &amp;amp;&amp;amp; (mConnectionId != AccessibilityInteractionClient.NO_ID)) {
                        // Send the event to AccessibilityService
                        mCallback.onAccessibilityEvent(event);
                    }
                    ...
                }
            } return;

            ...
            case DO_INIT: {
                mConnectionId = message.arg1;
                SomeArgs args = (SomeArgs) message.obj;
                IAccessibilityServiceConnection connection =
                        (IAccessibilityServiceConnection) args.arg1;
                IBinder windowToken = (IBinder) args.arg2;
                args.recycle();
                if (connection != null) {
                    AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                            connection);
                    mCallback.init(mConnectionId, windowToken);
                    mCallback.onServiceConnected();
                }...
            } return;
...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IAccessibilityServiceClientWrapper中保存了一个HandlerCaller和Callbacks对象，其中HandlerCaller主要是将SystemServer进程中AccessibilityServiceConnection的binder call的binder线程调研切换到AccessibilityService的主线程调用。Callbacks对象则将IAccessibilityServiceClientWrapper中的调用回调到AccessibilityService中。&lt;/p&gt;

&lt;p&gt;AccessibilityService返回binder后会走到AccessibilityServiceConnection的onServiceConnected调用中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        ...
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        ...
        userState.addServiceLocked(this);
        mSystemSupport.onClientChange(false);
        // Initialize the service on the main handler after we&#39;re done setting up for
        // the new configuration (for example, initializing the input filter).
        mMainHandler.sendMessage(obtainMessage(
                AccessibilityServiceConnection::initializeService, this));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;private void initializeService() {
    IAccessibilityServiceClient serviceInterface = null;
    ...
    try {
        serviceInterface.init(this, mId, mOverlayWindowToken);
    } catch (RemoteException re) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在serviceInterface.init方法中（binder调用）将这个AccessibilityServiceConnection、mId和mOverlayWindowToken传给AccessibilityService完成初始化工作。&lt;/p&gt;

&lt;p&gt;初始化时会调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
        connection);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将AccessibilityServiceConnection保存到AccessibilityInteractionClient中。&lt;/p&gt;

&lt;h3 id=&#34;2-触摸事件出发到焦点绘制过程&#34;&gt;2、触摸事件出发到焦点绘制过程。&lt;/h3&gt;

&lt;p&gt;2.1 触摸事件发出到AccessibilityService接收到onAccessibilityEvent事件流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNc79gy1g1t16x2ozmj313g0u0x0h.jpg&#34; alt=&#34;accessibilitytouch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.2 talkback发出focus事件通知ViewRootImpl绘制绿框焦点过程。&lt;/p&gt;

&lt;h3 id=&#34;3-talkback调用tts发出声音过程&#34;&gt;3、talkback调用TTS发出声音过程。&lt;/h3&gt;

&lt;h1 id=&#34;四-解疑&#34;&gt;四、解疑&lt;/h1&gt;

&lt;p&gt;1.无障碍机制涉及哪些模块？答案如上分析&lt;/p&gt;

&lt;p&gt;2.开启talkback后talkback手势生效原理？&lt;/p&gt;

&lt;p&gt;答：service的xml配置中android:canRequestTouchExplorationMode=&amp;ldquo;true&amp;rdquo;&lt;/p&gt;

&lt;p&gt;配上这个属性时com.android.server.accessibility.TouchExplorer会生效，该类会处理无障碍手势。&lt;/p&gt;

&lt;p&gt;3.无障碍焦点的方框如何产生？&lt;/p&gt;

&lt;p&gt;答：ViewRootImp进行绘制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl.java

/**
 * We want to draw a highlight around the current accessibility focused.
 * Since adding a style for all possible view is not a viable option we
 * have this specialized drawing method.
 *
 * Note: We are doing this here to be able to draw the highlight for
 *       virtual views in addition to real ones.
 *
 * @param canvas The canvas on which to draw.
 */
private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas) {
    final Rect bounds = mAttachInfo.mTmpInvalRect;
    if (getAccessibilityFocusedRect(bounds)) {
        final Drawable drawable = getAccessibilityFocusedDrawable();
        if (drawable != null) {
            drawable.setBounds(bounds);
            drawable.draw(canvas);
        }
    } else if (mAttachInfo.mAccessibilityFocusDrawable != null) {
        mAttachInfo.mAccessibilityFocusDrawable.setBounds(0, 0, 0, 0);
    }
}

private boolean getAccessibilityFocusedRect(Rect bounds) {
    final AccessibilityManager manager = AccessibilityManager.getInstance(mView.mContext);
    if (!manager.isEnabled() || !manager.isTouchExplorationEnabled()) {
        return false;
    }

    final View host = mAccessibilityFocusedHost;
    if (host == null || host.mAttachInfo == null) {
        return false;
    }

    final AccessibilityNodeProvider provider = host.getAccessibilityNodeProvider();
    if (provider == null) {
        host.getBoundsOnScreen(bounds, true);
    } else if (mAccessibilityFocusedVirtualView != null) {
        mAccessibilityFocusedVirtualView.getBoundsInScreen(bounds);
    } else {
        return false;
    }

    // Transform the rect into window-relative coordinates.
    final AttachInfo attachInfo = mAttachInfo;
    bounds.offset(0, attachInfo.mViewRootImpl.mScrollY);
    bounds.offset(-attachInfo.mWindowLeft, -attachInfo.mWindowTop);
    if (!bounds.intersect(0, 0, attachInfo.mViewRootImpl.mWidth,
            attachInfo.mViewRootImpl.mHeight)) {
        // If no intersection, set bounds to empty.
        bounds.setEmpty();
    }
    return !bounds.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，绿框出现的条件有AccessibilityManager可用（isEnabled）、开启了TouchExploration模式（同上第二点）等。&lt;/p&gt;

&lt;p&gt;4.talkback如何获取view的内容从而调用tts进行朗读？&lt;/p&gt;

&lt;p&gt;5.为什么实现了AccessibilityService的apk安装后设置无障碍就会出现相关的开关？&lt;/p&gt;

&lt;p&gt;有待研究，猜测是从PKMS中查询。&lt;/p&gt;

&lt;p&gt;6.打开某个页面时talkback的默认焦点怎么来的？&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
