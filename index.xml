<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xuanliang</title>
    <link>https://xuanliangdev.github.io/</link>
    <description>Recent content on xuanliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 03 Aug 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://xuanliangdev.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://xuanliangdev.github.io/about/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/about/</guid>
      
        <description>

&lt;h2 id=&#34;如果你有理想在远方-就不要被路边的风景影响了前进的速度-因为人的时间是有限的&#34;&gt;——如果你有理想在远方，就不要被路边的风景影响了前进的速度，因为人的时间是有限的。&lt;/h2&gt;

&lt;p&gt;来小米差一个月就满一年了，与来之前的雄心壮志相比，进步之缓慢超出了预期，主要还是没有定下切实的目标并坚持执行，没有在繁忙的杂活中或者抽出空闲时间总结提升，甚至从今年4月中旬开始胡思乱想到了现在，迷失了自己，浪费了3个半月，今天开始重新制定半年计划并执行，尽一切努力排除杂念💪。&lt;/p&gt;

&lt;p&gt;人没有目标就会胡思乱想，有了目标就要切实执行，不然就会停滞不前甚至倒退。&lt;/p&gt;

&lt;p&gt;今天是2019年8月3日，体检发现甲状腺结节，还好是良性的。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>无障碍学习整理（基于talkback）</title>
      <link>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</guid>
      
        <description>

&lt;h2 id=&#34;一-疑问&#34;&gt;一、疑问：&lt;/h2&gt;

&lt;p&gt;1.无障碍机制涉及哪些模块？&lt;/p&gt;

&lt;p&gt;2.开启talkback后talkback手势生效原理？&lt;/p&gt;

&lt;p&gt;3.无障碍焦点的方框如何产生？&lt;/p&gt;

&lt;p&gt;4.talkback如何获取view的内容从而调用tts进行朗读？&lt;/p&gt;

&lt;p&gt;5.为什么实现了AccessibilityService的apk安装后设置无障碍就会出现相关的开关？&lt;/p&gt;

&lt;p&gt;6.打开某个页面时talkback的默认焦点怎么来的？&lt;/p&gt;

&lt;h2 id=&#34;二-结构分析&#34;&gt;二、结构分析&lt;/h2&gt;

&lt;h3 id=&#34;1-代码结构&#34;&gt;1.代码结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNc79gy1g1t8b1vx1zj317l0signa.jpg&#34; alt=&#34;无障碍架构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNc79gy1g1t8avpt29j30vh0u01kx.jpg&#34; alt=&#34;accessibilityclass&#34; /&gt;&lt;/p&gt;

&lt;p&gt;整个talkback机制涉及了4个进程，SystemServer（蓝色部分）、Talkback（黄色部分）、前台app进程（绿色部分），TTS引擎进程（暂不分析）&lt;/p&gt;

&lt;p&gt;四个AIDL接口，图上红色部分&lt;/p&gt;

&lt;h4 id=&#34;1-1-talkback-辅助app-实现了accessibilityservice的app&#34;&gt;1.1、talkback（辅助app，实现了AccessibilityService的app）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNc79gy1g1qzm48qapj30b40abacc.jpg&#34; alt=&#34;WX20190404-224703@2x&#34; /&gt;&lt;/p&gt;

&lt;p&gt;talkback实现了AccessiblityService用于接收系统传过来的无障碍事件。&lt;/p&gt;

&lt;h4 id=&#34;1-2-前台app进程-被辅助app&#34;&gt;1.2、前台app进程（被辅助app）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNc79gy1g1r0sbx0bxj30b40b8421.jpg&#34; alt=&#34;viewaccessibility&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-3-system-process&#34;&gt;1.3、system_process&lt;/h4&gt;

&lt;p&gt;1.3.1（AccessibilityManagerService）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNc79gy1g1r04mvninj30b40d8q73.jpg&#34; alt=&#34;acms&#34; /&gt;&lt;/p&gt;

&lt;p&gt;系统进程SystemServer维护了ActivityManagerService，用来作为binder服务端，SystemServer启动时会启动AccessibilityManagerService。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.SystemServer.java

/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */
private void startOtherServices() {
...
            traceBeginAndSlog(&amp;quot;StartAccessibilityManagerService&amp;quot;);
            try {
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf(&amp;quot;starting Accessibility Manager&amp;quot;, e);
            }
            traceEnd();
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.3.2、TTS&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tNc79gy1g1rg51wbiij30b40m0q9h.jpg&#34; alt=&#34;tts&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-语音引擎&#34;&gt;4.语音引擎&lt;/h4&gt;

&lt;p&gt;暂不分析&lt;/p&gt;

&lt;h3 id=&#34;1-2-aidl接口&#34;&gt;1.2 AIDL接口&lt;/h3&gt;

&lt;p&gt;跨进程通信的需要用到aidl，理解aidl的设计是理解无障碍框架的关键。&lt;/p&gt;

&lt;h4 id=&#34;1-2-1-iaccessibilityserviceclient&#34;&gt;1.2.1 、IAccessibilityServiceClient&lt;/h4&gt;

&lt;p&gt;服务端为辅助app进程（talkback），调用客户端为SystemServer进程。&lt;/p&gt;

&lt;p&gt;当SystemServer绑定AccessibilityService时，AccessibilityService会返回实现该接口的binder对象给SystemServer进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceClient.aidl

/**
 * Top-level interface to an accessibility service component.
 */
oneway interface IAccessibilityServiceClient {

    void onAccessibilityEvent(in AccessibilityEvent event, in boolean serviceWantsEvent);

    void onSoftKeyboardShowModeChanged(int showMode);

    void onPerformGestureResult(int sequence, boolean completedSuccessfully);

    void onAccessibilityButtonClicked();

    void onAccessibilityButtonAvailabilityChanged(boolean available);
    
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-2-iaccessibilityserviceconnection&#34;&gt;1.2.2、IAccessibilityServiceConnection&lt;/h4&gt;

&lt;p&gt;服务端为SystemServer进程，调用客户端为辅助app进程（talkback）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceConnection.aidl

/**
 * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
 */
interface IAccessibilityServiceConnection {

    String[] findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId,
        in Bundle arguments);

    String[] findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    String[] findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    boolean isAccessibilityButtonAvailable();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用于talkback和system_process之间，服务端为system_process（AccessibilityManagerService），客户端为talkback。&lt;/p&gt;

&lt;h4 id=&#34;1-2-3-iaccessibilitymanager&#34;&gt;1.2.3、IAccessibilityManager&lt;/h4&gt;

&lt;p&gt;服务端为SystemServer进程，调用客户端为被辅助app进程。&lt;/p&gt;

&lt;p&gt;当被辅助app产生触摸事件后，会通过这个接口发送无障碍事件给SystemServer进程的AccessibilityManagerService&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityManager.aidl

/**
 * Interface implemented by the AccessibilityManagerService called by
 * the AccessibilityManagers.
 *
 * @hide
 */
interface IAccessibilityManager {

    oneway void sendAccessibilityEvent(in AccessibilityEvent uiEvent, int userId);

    long addClient(IAccessibilityManagerClient client, int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getInstalledAccessibilityServiceList(int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getEnabledAccessibilityServiceList(int feedbackType, int userId);

    int addAccessibilityInteractionConnection(IWindow windowToken,
            in IAccessibilityInteractionConnection connection,
            String packageName, int userId);

    void removeAccessibilityInteractionConnection(IWindow windowToken);

    void notifyAccessibilityButtonClicked();

    // Requires WRITE_SECURE_SETTINGS
    void performAccessibilityShortcut();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-4-iaccessibilityinteractionconnection&#34;&gt;1.2.4、IAccessibilityInteractionConnection&lt;/h4&gt;

&lt;p&gt;服务端为被辅助app进程，调用客户端为SystemServer进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityInteractionConnection.aidl

/**
 * Interface for interaction between the AccessibilityManagerService
 * and the ViewRoot in a given window.
 *
 * @hide
 */
oneway interface IAccessibilityInteractionConnection {

    void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId, in Region bounds,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid, in MagnificationSpec spec,
        in Bundle arguments);

    ...

    void findFocus(long accessibilityNodeId, int focusType, in Region bounds, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
        long interrogatingTid, in MagnificationSpec spec);

  ...

    void performAccessibilityAction(long accessibilityNodeId, int action, in Bundle arguments,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-流程分析&#34;&gt;三、流程分析&lt;/h2&gt;

&lt;h3 id=&#34;1-talkback开关打开后到talkbackservice启动过程&#34;&gt;1、talkback开关打开后到TalkbackService启动过程。&lt;/h3&gt;

&lt;p&gt;1.1、在设置中打开talback开关后，会调用到如下方法，最终会往Settings provider中key为Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES的字段写入Talkback注册的AccessibilityService值（TalkbackService），这个值保存在&lt;/p&gt;

&lt;p&gt;/data/system/users/0/settings_secure.xml文件中。（其他app的AccessibilityService也保存在同一个key中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.settingslib.accessibility.AccessibilityUtils.java

/**
 * Changes an accessibility component&#39;s state for {@param userId}.
 */
public static void setAccessibilityServiceState(Context context, ComponentName toggledService,
        boolean enabled, int userId) {
    ...
    Settings.Secure.putStringForUser(context.getContentResolver(),
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
            enabledServicesBuilder.toString(), userId);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于AccessibilityManagerService创建时注册了AccessibilityContentObserver，因此马上会收到Settings provider数据变化的监听。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

private void updateServicesLocked(UserState userState) {
    ...
        if (userState.mEnabledServices.contains(componentName)
                &amp;amp;&amp;amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
            if (service == null) {
                service = new AccessibilityServiceConnection(userState, mContext, componentName,
                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                        this, mWindowManagerService, mGlobalActionPerformer);
            } 
            ...
            service.bindLocked();
        } ...
    }
    ...
    updateAccessibilityEnabledSetting(userState);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据获取到的AccessibilityService信息（com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService）创建出AccessibilityServiceConnection。AccessibilityServiceConnection代表了一个无障碍服务，存储用于管理这个服务需要的所有数据，提供了开始/停止服务和在服务管理的数据结构中添加或者移除这个服务的api。&lt;/p&gt;

&lt;p&gt;接着调用bindServiceAsUser方法来绑定服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

public void bindLocked() {
    ...
    try {
        ...
        if (mService == null &amp;amp;&amp;amp; mContext.bindServiceAsUser(
                mIntent, this, flags, new UserHandle(userState.mUserId))) {
            userState.getBindingServicesLocked().add(mComponentName);
        }
    } ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务启动后会跨进程调用到TalkbackService(AccessibilityService)的onBind方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.accessibilityservice.AccessibilityService

/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        ...
        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }
...
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onBind方法返回的是一个IAccessibilityServiceClientWrapper的binder对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Implements the internal {@link IAccessibilityServiceClient} interface to convert
 * incoming calls to it back to calls on an {@link AccessibilityService}.
 *
 * @hide
 */
public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
        implements HandlerCaller.Callback {
    ...

    private final HandlerCaller mCaller;

    private final Callbacks mCallback;

    private int mConnectionId = AccessibilityInteractionClient.NO_ID;

    public IAccessibilityServiceClientWrapper(Context context, Looper looper,
            Callbacks callback) {
        mCallback = callback;
        mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);
    }

    public void init(IAccessibilityServiceConnection connection, int connectionId,
            IBinder windowToken) {
        Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                connection, windowToken);
        mCaller.sendMessage(message);
    }

    ...

    public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {
        Message message = mCaller.obtainMessageBO(
                DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);
        mCaller.sendMessage(message);
    }
...

    @Override
    public void executeMessage(Message message) {
        switch (message.what) {
            case DO_ON_ACCESSIBILITY_EVENT: {
                AccessibilityEvent event = (AccessibilityEvent) message.obj;
                boolean serviceWantsEvent = message.arg1 != 0;
                if (event != null) {
                    // Send the event to AccessibilityCache via AccessibilityInteractionClient
                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);
                    if (serviceWantsEvent
                            &amp;amp;&amp;amp; (mConnectionId != AccessibilityInteractionClient.NO_ID)) {
                        // Send the event to AccessibilityService
                        mCallback.onAccessibilityEvent(event);
                    }
                    ...
                }
            } return;

            ...
            case DO_INIT: {
                mConnectionId = message.arg1;
                SomeArgs args = (SomeArgs) message.obj;
                IAccessibilityServiceConnection connection =
                        (IAccessibilityServiceConnection) args.arg1;
                IBinder windowToken = (IBinder) args.arg2;
                args.recycle();
                if (connection != null) {
                    AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                            connection);
                    mCallback.init(mConnectionId, windowToken);
                    mCallback.onServiceConnected();
                }...
            } return;
...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IAccessibilityServiceClientWrapper中保存了一个HandlerCaller和Callbacks对象，其中HandlerCaller主要是将SystemServer进程中AccessibilityServiceConnection的binder call的binder线程调研切换到AccessibilityService的主线程调用。Callbacks对象则将IAccessibilityServiceClientWrapper中的调用回调到AccessibilityService中。&lt;/p&gt;

&lt;p&gt;AccessibilityService返回binder后会走到AccessibilityServiceConnection的onServiceConnected调用中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        ...
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        ...
        userState.addServiceLocked(this);
        mSystemSupport.onClientChange(false);
        // Initialize the service on the main handler after we&#39;re done setting up for
        // the new configuration (for example, initializing the input filter).
        mMainHandler.sendMessage(obtainMessage(
                AccessibilityServiceConnection::initializeService, this));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;private void initializeService() {
    IAccessibilityServiceClient serviceInterface = null;
    ...
    try {
        serviceInterface.init(this, mId, mOverlayWindowToken);
    } catch (RemoteException re) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在serviceInterface.init方法中（binder调用）将这个AccessibilityServiceConnection、mId和mOverlayWindowToken传给AccessibilityService完成初始化工作。&lt;/p&gt;

&lt;p&gt;初始化时会调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
        connection);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将AccessibilityServiceConnection保存到AccessibilityInteractionClient中。&lt;/p&gt;

&lt;h3 id=&#34;2-触摸事件出发到焦点绘制过程&#34;&gt;2、触摸事件出发到焦点绘制过程。&lt;/h3&gt;

&lt;p&gt;2.1 触摸事件发出到AccessibilityService接收到onAccessibilityEvent事件流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tNc79gy1g1t16x2ozmj313g0u0x0h.jpg&#34; alt=&#34;accessibilitytouch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.2 talkback发出focus事件通知ViewRootImpl绘制绿框焦点过程。&lt;/p&gt;

&lt;h3 id=&#34;3-talkback调用tts发出声音过程&#34;&gt;3、talkback调用TTS发出声音过程。&lt;/h3&gt;

&lt;h1 id=&#34;四-解疑&#34;&gt;四、解疑&lt;/h1&gt;

&lt;p&gt;1.无障碍机制涉及哪些模块？答案如上分析&lt;/p&gt;

&lt;p&gt;2.开启talkback后talkback手势生效原理？&lt;/p&gt;

&lt;p&gt;答：service的xml配置中android:canRequestTouchExplorationMode=&amp;ldquo;true&amp;rdquo;&lt;/p&gt;

&lt;p&gt;配上这个属性时com.android.server.accessibility.TouchExplorer会生效，该类会处理无障碍手势。&lt;/p&gt;

&lt;p&gt;3.无障碍焦点的方框如何产生？&lt;/p&gt;

&lt;p&gt;答：ViewRootImp进行绘制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl.java

/**
 * We want to draw a highlight around the current accessibility focused.
 * Since adding a style for all possible view is not a viable option we
 * have this specialized drawing method.
 *
 * Note: We are doing this here to be able to draw the highlight for
 *       virtual views in addition to real ones.
 *
 * @param canvas The canvas on which to draw.
 */
private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas) {
    final Rect bounds = mAttachInfo.mTmpInvalRect;
    if (getAccessibilityFocusedRect(bounds)) {
        final Drawable drawable = getAccessibilityFocusedDrawable();
        if (drawable != null) {
            drawable.setBounds(bounds);
            drawable.draw(canvas);
        }
    } else if (mAttachInfo.mAccessibilityFocusDrawable != null) {
        mAttachInfo.mAccessibilityFocusDrawable.setBounds(0, 0, 0, 0);
    }
}

private boolean getAccessibilityFocusedRect(Rect bounds) {
    final AccessibilityManager manager = AccessibilityManager.getInstance(mView.mContext);
    if (!manager.isEnabled() || !manager.isTouchExplorationEnabled()) {
        return false;
    }

    final View host = mAccessibilityFocusedHost;
    if (host == null || host.mAttachInfo == null) {
        return false;
    }

    final AccessibilityNodeProvider provider = host.getAccessibilityNodeProvider();
    if (provider == null) {
        host.getBoundsOnScreen(bounds, true);
    } else if (mAccessibilityFocusedVirtualView != null) {
        mAccessibilityFocusedVirtualView.getBoundsInScreen(bounds);
    } else {
        return false;
    }

    // Transform the rect into window-relative coordinates.
    final AttachInfo attachInfo = mAttachInfo;
    bounds.offset(0, attachInfo.mViewRootImpl.mScrollY);
    bounds.offset(-attachInfo.mWindowLeft, -attachInfo.mWindowTop);
    if (!bounds.intersect(0, 0, attachInfo.mViewRootImpl.mWidth,
            attachInfo.mViewRootImpl.mHeight)) {
        // If no intersection, set bounds to empty.
        bounds.setEmpty();
    }
    return !bounds.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，绿框出现的条件有AccessibilityManager可用（isEnabled）、开启了TouchExploration模式（同上第二点）等。&lt;/p&gt;

&lt;p&gt;4.talkback如何获取view的内容从而调用tts进行朗读？&lt;/p&gt;

&lt;p&gt;5.为什么实现了AccessibilityService的apk安装后设置无障碍就会出现相关的开关？&lt;/p&gt;

&lt;p&gt;有待研究，猜测是从PKMS中查询。&lt;/p&gt;

&lt;p&gt;6.打开某个页面时talkback的默认焦点怎么来的？&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
