<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xuanliang</title>
    <link>https://xuanliangdev.github.io/</link>
    <description>Recent content on xuanliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 25 Feb 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://xuanliangdev.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://xuanliangdev.github.io/about/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/about/</guid>
      
        <description>&lt;h3 id=&#34;小米android程序员&#34;&gt;小米android程序员&lt;/h3&gt;
&lt;p&gt;搬砖工&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>InputManagerService和ANR原理学习（待完善）</title>
      <link>https://xuanliangdev.github.io/post/inputmanagerservice%E5%92%8Canr%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/inputmanagerservice%E5%92%8Canr%E5%8E%9F%E7%90%86/</guid>
      
        <description>&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/samchen2009/p/3368158.html&#34;&gt;https://www.cnblogs.com/samchen2009/p/3368158.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《深入理解Android 卷三》邓凡平&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gityuan.com/2017/01/01/input-anr/&#34;&gt;http://gityuan.com/2017/01/01/input-anr/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;输入系统主要作用&#34;&gt;输入系统主要作用：&lt;/h2&gt;
&lt;p&gt;读取设备节点原始的事件，然后派发给一个特定的窗口以及窗口中的控件。&lt;/p&gt;
&lt;h4 id=&#34;核心类&#34;&gt;核心类&lt;/h4&gt;
&lt;h3 id=&#34;1inputmanagerservice&#34;&gt;1、InputManagerService：&lt;/h3&gt;
&lt;p&gt;是系统进程的一个服务，分为java层和native层，java层负责与WMS通信。Native层是InputReader和InputDispatcher的运行容器。&lt;/p&gt;
&lt;h3 id=&#34;2eventhub-&#34;&gt;2、EventHub :&lt;/h3&gt;
&lt;p&gt;作为直接操作设备节点的输入系统组件，隐藏了INotify与Epoll以及设备节点读取等底层操作。通过一个简单的接口getEvents向使用者提供抽取设备事件与原始输入事件的功能。&lt;/p&gt;
&lt;h5 id=&#34;inotify与epoll&#34;&gt;INotify与Epoll:&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;INotify&lt;/strong&gt;:Linux内核提供的一种文件系统变化通知机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Epoll&lt;/strong&gt;：可扩展I/O事件通知机制，&lt;/p&gt;
&lt;p&gt;这两套机制提供的事件监听机制以最小的开销解决了&lt;strong&gt;文件系统变化通知&lt;/strong&gt;以及&lt;strong&gt;文件描述符可读可写状态变化&lt;/strong&gt;的&lt;strong&gt;监听&lt;/strong&gt;问题。&lt;/p&gt;
&lt;h3 id=&#34;3windowmanagerservice&#34;&gt;3、WindowManagerService:&lt;/h3&gt;
&lt;p&gt;创建新窗口时，将窗口信息，包括点击区域、焦点窗口等信息实时更新到IMS的InputDispatcher中。&lt;/p&gt;
&lt;h3 id=&#34;4inputreader&#34;&gt;4、InputReader&lt;/h3&gt;
&lt;h5 id=&#34;native层inputreader&#34;&gt;（native层）InputReader：&lt;/h5&gt;
&lt;p&gt;作用1：运行在独立线程，循环从EventHub中取事件。&lt;/p&gt;
&lt;p&gt;作用2：由于原始输入事件结构简单，信息量少，可用性不好，而且所携带的事件信息往往与硬件实现有关，因此InputReader会对原始输入事件进行整合变换，比如对Keyboard类型或Touch类型分别加工。&lt;/p&gt;
&lt;h3 id=&#34;5inputdispatcher&#34;&gt;5、InputDispatcher&lt;/h3&gt;
&lt;h5 id=&#34;native层inputdispatcher也运行在独立线程保管wms的所有窗口信息当收到inputreader输入事件后会从中寻找合适的窗口进行分发&#34;&gt;（native层）InputDispatcher：也运行在独立线程，保管WMS的所有窗口信息，当收到InputReader输入事件后，会从中寻找合适的窗口进行分发。&lt;/h5&gt;
&lt;p&gt;mInboundQueue:会区分Key或者Motion等类型事件分别派发，或者是废弃&lt;/p&gt;
&lt;p&gt;mOutboundQueue:&lt;strong&gt;Connection&lt;/strong&gt;中的成员，&lt;strong&gt;Connection&lt;/strong&gt;描述了从InputDispatcher到目标窗口的一个连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Queue of events that need to be published to the connection.
std::deque&amp;lt;DispatchEntry*&amp;gt; outboundQueue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WaitQueue:Connection中的成员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Queue of events that have been published to the connection but that have not
// yet received a &amp;quot;finished&amp;quot; response from the application.
std::deque&amp;lt;DispatchEntry*&amp;gt; waitQueue;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;流程&#34;&gt;流程：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/anr/InputDispatcher.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、inputReader取出的事件加入派发队列mInboundQueue，有需要的话唤醒派发线程，过程发生在InputReader线程中。&lt;/p&gt;
&lt;p&gt;2、派发线程的循环：&lt;/p&gt;
&lt;p&gt;1）从mInboundQueue取事件；&lt;/p&gt;
&lt;p&gt;2）寻找目标窗口，过程中会判断是否需要出发ANR&lt;/p&gt;
&lt;p&gt;3）找到窗口则进行事件的分发，将事件加入mOutboundQueue队列，通过InputChannel向上层分发事件，然后将mOutboundQueue队列的事件转移到WaitQueue队列等待上层处理结果。&lt;/p&gt;
&lt;p&gt;4）上层事件处理完成后通知底层从WaitQueue移除事件。&lt;/p&gt;
&lt;h5 id=&#34;源码分析&#34;&gt;源码分析：&lt;/h5&gt;
&lt;p&gt;InputDispatcher.cpp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool InputDispatcherThread::threadLoop() {
    mDispatcher-&amp;gt;dispatchOnce();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正的一次事件分发流程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    { // acquire lock
        AutoMutex _l(mLock);
        mDispatcherIsAliveCondition.broadcast();

        // Run a dispatch loop if there are no pending commands.
        // The dispatch loop might enqueue commands to run afterwards.
        if (!haveCommandsLocked()) {
            dispatchOnceInnerLocked(&amp;amp;nextWakeupTime);
        }

        // Run all pending commands if there are any.
        // If any commands were run then force the next poll to wake up immediately.
        if (runCommandsLockedInterruptible()) {
            nextWakeupTime = LONG_LONG_MIN;
        }
    } // release lock

    // Wait for callback or timeout or wake.  (make sure we round up, not down)
    nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&amp;gt;pollOnce(timeoutMillis);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {
    nsecs_t currentTime = now();
...
    // Optimize latency of app switches.
    // Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has
    // been pressed.  When it expires, we preempt dispatch and drop all other pending events.
    bool isAppSwitchDue = mAppSwitchDueTime &amp;lt;= currentTime;
    if (mAppSwitchDueTime &amp;lt; *nextWakeupTime) {
        *nextWakeupTime = mAppSwitchDueTime;
    }

    // Ready to start a new event.
    // If we don&#39;t already have a pending event, go grab one.
    if (! mPendingEvent) {
        if (mInboundQueue.isEmpty()) {
...
            // Nothing to do if there is no pending event.
            if (!mPendingEvent) {
                return;
            }
        } else {
            // Inbound queue has at least one entry.
            mPendingEvent = mInboundQueue.dequeueAtHead();
            traceInboundQueueLengthLocked();
        }

        // Poke user activity for this event.
        if (mPendingEvent-&amp;gt;policyFlags &amp;amp; POLICY_FLAG_PASS_TO_USER) {
            pokeUserActivityLocked(mPendingEvent);
        }

        // Get ready to dispatch the event.
        resetANRTimeoutsLocked();
    }

    // Now we have an event to dispatch.
    // All events are eventually dequeued and processed this way, even if we intend to drop them.
    ALOG_ASSERT(mPendingEvent != NULL);
    bool done = false;
    DropReason dropReason = DROP_REASON_NOT_DROPPED;
    if (!(mPendingEvent-&amp;gt;policyFlags &amp;amp; POLICY_FLAG_PASS_TO_USER)) {
        dropReason = DROP_REASON_POLICY;
    } else if (!mDispatchEnabled) {
        dropReason = DROP_REASON_DISABLED;
    }

    if (mNextUnblockedEvent == mPendingEvent) {
        mNextUnblockedEvent = NULL;
    }

    switch (mPendingEvent-&amp;gt;type) {
...

    case EventEntry::TYPE_KEY: {
        KeyEntry* typedEntry = static_cast&amp;lt;KeyEntry*&amp;gt;(mPendingEvent);
        if (isAppSwitchDue) {
            if (isAppSwitchKeyEventLocked(typedEntry)) {
                resetPendingAppSwitchLocked(true);
                isAppSwitchDue = false;
            } else if (dropReason == DROP_REASON_NOT_DROPPED) {
                dropReason = DROP_REASON_APP_SWITCH;
            }
        }
        if (dropReason == DROP_REASON_NOT_DROPPED
                &amp;amp;&amp;amp; isStaleEventLocked(currentTime, typedEntry)) {
            dropReason = DROP_REASON_STALE;
        }
        if (dropReason == DROP_REASON_NOT_DROPPED &amp;amp;&amp;amp; mNextUnblockedEvent) {
            dropReason = DROP_REASON_BLOCKED;
        }
        done = dispatchKeyLocked(currentTime, typedEntry, &amp;amp;dropReason, nextWakeupTime);
        break;
    }

    case EventEntry::TYPE_MOTION: {
        MotionEntry* typedEntry = static_cast&amp;lt;MotionEntry*&amp;gt;(mPendingEvent);
        if (dropReason == DROP_REASON_NOT_DROPPED &amp;amp;&amp;amp; isAppSwitchDue) {
            dropReason = DROP_REASON_APP_SWITCH;
        }
        if (dropReason == DROP_REASON_NOT_DROPPED
                &amp;amp;&amp;amp; isStaleEventLocked(currentTime, typedEntry)) {
            dropReason = DROP_REASON_STALE;
        }
        if (dropReason == DROP_REASON_NOT_DROPPED &amp;amp;&amp;amp; mNextUnblockedEvent) {
            dropReason = DROP_REASON_BLOCKED;
        }
        done = dispatchMotionLocked(currentTime, typedEntry,
                &amp;amp;dropReason, nextWakeupTime);
        break;
    }
..
    }

    if (done) {
        if (dropReason != DROP_REASON_NOT_DROPPED) {
            dropInboundEventLocked(mPendingEvent, dropReason);
        }

        releasePendingEventLocked();
        *nextWakeupTime = LONG_LONG_MIN;  // force next poll to wake up immediately
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;bool InputDispatcher::dispatchMotionLocked(
        nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) {
    // Preprocessing.
...

    // Clean up if dropping the event.
    if (*dropReason != DROP_REASON_NOT_DROPPED) {
        setInjectionResultLocked(entry, *dropReason == DROP_REASON_POLICY
                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);
        return true;
    }

    bool isPointerEvent = entry-&amp;gt;source &amp;amp; AINPUT_SOURCE_CLASS_POINTER;

    // Identify targets.
    Vector&amp;lt;InputTarget&amp;gt; inputTargets;

    bool conflictingPointerActions = false;
    int32_t injectionResult;
    if (isPointerEvent) {
        // Pointer event.  (eg. touchscreen)
        injectionResult = findTouchedWindowTargetsLocked(currentTime,
                entry, inputTargets, nextWakeupTime, &amp;amp;conflictingPointerActions);
    } else {
        // Non touch event.  (eg. trackball)
        injectionResult = findFocusedWindowTargetsLocked(currentTime,
                entry, inputTargets, nextWakeupTime);
    }
  ...
    dispatchEventLocked(currentTime, entry, inputTargets);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
        const MotionEntry* entry, Vector&amp;lt;InputTarget&amp;gt;&amp;amp; inputTargets, nsecs_t* nextWakeupTime,
        bool* outConflictingPointerActions) {
...

    // Ensure all touched foreground windows are ready for new input.
    for (size_t i = 0; i &amp;lt; mTempTouchState.windows.size(); i++) {
        const TouchedWindow&amp;amp; touchedWindow = mTempTouchState.windows[i];
        if (touchedWindow.targetFlags &amp;amp; InputTarget::FLAG_FOREGROUND) {
            // If the touched window is paused then keep waiting.
            if (touchedWindow.windowHandle-&amp;gt;getInfo()-&amp;gt;paused) {
                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,
                        NULL, touchedWindow.windowHandle, nextWakeupTime,
                        &amp;quot;Waiting because the touched window is paused.&amp;quot;);
                goto Unresponsive;
            }

            // If the touched window is still working on previous events then keep waiting.
            if (!isWindowReadyForMoreInputLocked(currentTime, touchedWindow.windowHandle, entry)) {
                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,
                        NULL, touchedWindow.windowHandle, nextWakeupTime,
                        &amp;quot;Waiting because the touched window has not finished &amp;quot;
                        &amp;quot;processing the input events that were previously delivered to it.&amp;quot;);
                goto Unresponsive;
            }
        }
    }

...
    return injectionResult;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;判断窗口是否可以接收事件，否则就触发ANR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool InputDispatcher::isWindowReadyForMoreInputLocked(nsecs_t currentTime,
        const sp&amp;lt;InputWindowHandle&amp;gt;&amp;amp; windowHandle, const EventEntry* eventEntry) {
    ssize_t connectionIndex = getConnectionIndexLocked(windowHandle-&amp;gt;getInputChannel());
    if (connectionIndex &amp;gt;= 0) {
...
        if (eventEntry-&amp;gt;type == EventEntry::TYPE_KEY) {
            // If the event is a key event, then we must wait for all previous events to
            // complete before delivering it because previous events may have the
            // side-effect of transferring focus to a different window and we want to
            // ensure that the following keys are sent to the new window.
            //
            // Suppose the user touches a button in a window then immediately presses &amp;quot;A&amp;quot;.
            // If the button causes a pop-up window to appear then we want to ensure that
            // the &amp;quot;A&amp;quot; key is delivered to the new pop-up window.  This is because users
            // often anticipate pending UI changes when typing on a keyboard.
            // To obtain this behavior, we must serialize key events with respect to all
            // prior input events.
            return connection-&amp;gt;outboundQueue.isEmpty()
                    &amp;amp;&amp;amp; connection-&amp;gt;waitQueue.isEmpty();
        }
        // Touch events can always be sent to a window immediately because the user intended
        // to touch whatever was visible at the time.  Even if focus changes or a new
        // window appears moments later, the touch event was meant to be delivered to
        // whatever window happened to be on screen at the time.
        //
        // Generic motion events, such as trackball or joystick events are a little trickier.
        // Like key events, generic motion events are delivered to the focused window.
        // Unlike key events, generic motion events don&#39;t tend to transfer focus to other
        // windows and it is not important for them to be serialized.  So we prefer to deliver
        // generic motion events as soon as possible to improve efficiency and reduce lag
        // through batching.
        //
        // The one case where we pause input event delivery is when the wait queue is piling
        // up with lots of events because the application is not responding.
        // This condition ensures that ANRs are detected reliably.
        if (!connection-&amp;gt;waitQueue.isEmpty()
                &amp;amp;&amp;amp; currentTime &amp;gt;= connection-&amp;gt;waitQueue.head-&amp;gt;deliveryTime
                        + STREAM_AHEAD_EVENT_TIMEOUT) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;6anr&#34;&gt;6、ANR&lt;/h3&gt;
&lt;p&gt;findTouchedWindowTargetsLocked函数中调用handleTargetsNotReadyLocked方法会执行，主要分如下三类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (windowState != null) {
    Slog.i(TAG_WM, &amp;quot;Input event dispatching timed out &amp;quot;
            + &amp;quot;sending to &amp;quot; + windowState.mAttrs.getTitle()
            + &amp;quot;.  Reason: &amp;quot; + reason);
    // MIUI ADD:
    reason = windowState.mAttrs.getTitle() + &amp;quot;, &amp;quot; + reason;
} else if (activity != null) {
    Slog.i(TAG_WM, &amp;quot;Input event dispatching timed out &amp;quot;
            + &amp;quot;sending to application &amp;quot; + activity.stringName
            + &amp;quot;.  Reason: &amp;quot; + reason);
    // MIUI ADD:
    reason = activity.stringName + &amp;quot;, &amp;quot; + reason;
} else {
    Slog.i(TAG_WM, &amp;quot;Input event dispatching timed out &amp;quot;
            + &amp;quot;.  Reason: &amp;quot; + reason);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ANR的原因有如下类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Anr reason types:
 * Input dispatching timed out (Waiting because the focused window has not finished processing the input events that were previously delivered to it.)
 * Input dispatching timed out (Waiting because the touched window has not finished processing the input events that were previously delivered to it.)
 * Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)
 * Input dispatching timed out (Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago. Wait queue length: 6. Wait queue head age: 6152.1ms.)
 * Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: 0. Wait queue length: 6.)
 * Input dispatching timed out (Waiting because the touched window&#39;s input channel is full. Outbound queue length: 1. Wait queue length: 52.)
 * Input dispatching timed out (Waiting because the focused window&#39;s input channel is full. Outbound queue length: 1. Wait queue length: 52.)
 * Input dispatching timed out (Waiting because the touched window&#39;s input channel is not registered with the input dispatcher. The window may be in the process of being removed.)
 * Input dispatching timed out (Waiting because the focused window&#39;s input channel is not registered with the input dispatcher. The window may be in the process of being removed.)
 * Input dispatching timed out (Waiting because the touched window is paused.)
 * Input dispatching timed out (Waiting because the focused window is paused.)
 * Input dispatching timed out (Waiting because the touched window&#39;s input connection is %s. The window may be in the process of being removed
 * Input dispatching timed out (Waiting because the focused window&#39;s input connection is %s. The window may be in the process of being removed
 * executing service
 * Broadcast of Intent
 * ContentProvider not responding
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ANR实例分析：&lt;/p&gt;
&lt;p&gt;待续&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android 内存分析（围绕Bitmap）</title>
      <link>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%9B%B4%E7%BB%95bitmap/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%9B%B4%E7%BB%95bitmap/</guid>
      
        <description>&lt;h3 id=&#34;疑问&#34;&gt;疑问：&lt;/h3&gt;
&lt;h5 id=&#34;1图片在内存中的大小跟imageview设置的宽高有没影响&#34;&gt;1、图片在内存中的大小跟imageview设置的宽高有没影响？&lt;/h5&gt;
&lt;h5 id=&#34;2同一张图片放在drawable里面跟放在drawable-xxhdpi目录里面加载到内存中大小有什么区别&#34;&gt;2、同一张图片放在drawable里面，跟放在drawable-xxhdpi目录里面，加载到内存中大小有什么区别？&lt;/h5&gt;
&lt;h5 id=&#34;3如何减少bitmap的内存占用&#34;&gt;3、如何减少Bitmap的内存占用？&lt;/h5&gt;
&lt;h5 id=&#34;4加载svg图片的内存怎么计算&#34;&gt;4、加载svg图片的内存怎么计算？&lt;/h5&gt;
&lt;h3 id=&#34;结论bitmap内存占用跟以下因素有关&#34;&gt;结论：Bitmap内存占用跟以下因素有关&lt;/h3&gt;
&lt;h5 id=&#34;1手机屏幕密度&#34;&gt;1、手机屏幕密度&lt;/h5&gt;
&lt;h5 id=&#34;2图片资源存放的目录&#34;&gt;2、图片资源存放的目录&lt;/h5&gt;
&lt;h5 id=&#34;3bitmap宽高以及色彩格式&#34;&gt;3、bitmap宽高以及色彩格式&lt;/h5&gt;
&lt;h4 id=&#34;1加载相同图片只修改imageview宽高&#34;&gt;1、加载相同图片，只修改ImageView宽高&lt;/h4&gt;
&lt;p&gt;测试imageview加载图片内存大小，改变imageview的大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/***
 * 计算ImageView中加载图片的具体尺寸和内存占用大小
 * @param imageView
 */
private void calculateBitmapInfo(ImageView imageView) {
    Drawable drawable = imageView.getDrawable();
    if (drawable != null) {
        final Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(),
                drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
        Log.d(TAG, &amp;quot;imageView.getWidth() &amp;quot; + imageView.getWidth() +
                &amp;quot; bitmap width = &amp;quot; + bitmap.getWidth() +
                &amp;quot; bitmap height = &amp;quot; + bitmap.getHeight() +
                &amp;quot; memory usage = &amp;quot; + bitmap.getAllocationByteCount());
    }
}

final ImageView img = findViewById(R.id.imag1000);
   img.post(new Runnable() {
       @Override
        public void run() {
           calculateBitmapInfo(img);
       }
});


结果：改变imageview大小，内存占用不变

2021-02-17 01:37:28.709 18883-18883/com.xuanliangdev.firstproject D/MainActivity: imageView.getWidth() 1000 bitmap width = 126 bitmap height = 126 memory usage = 63504

2021-02-17 01:34:56.147 18752-18752/? D/MainActivity: imageView.getWidth() 500 bitmap width = 126 bitmap height = 126 memory usage = 63504
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;答案图片在内存中的大小跟imageview设置的宽高没影响&#34;&gt;答案：图片在内存中的大小跟imageview设置的宽高没影响。&lt;/h5&gt;
&lt;h4 id=&#34;21加载相同图片但是图片放在不同的drawable目录&#34;&gt;2.1、加载相同图片，但是图片放在不同的drawable目录&lt;/h4&gt;
&lt;p&gt;通过如下的方式也可以直接算出一张图片的内存大小占用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launchern);
Log.d(TAG, &amp;quot; bitmap width = &amp;quot; + bitmap.getWidth()
        + &amp;quot; bitmap height = &amp;quot; + bitmap.getHeight()
        + &amp;quot; memory usage = &amp;quot; + bitmap.getAllocationByteCount());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;针对一张192*192的png分别放在drawable、drawable-xhdpi、drawable-xxhdip、drawable-xxxhdpi在密度手机屏幕密度为480的模拟器上测试，结果分别为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drawable
2021-02-17 00:07:12.461 16564-16564/com.xuanliangdev.firstproject D/MainActivity:  bitmap width = 576 bitmap height = 576 memory usage = 1327104

drawable-xhdpi
2021-02-17 00:08:33.710 16689-16689/? D/MainActivity:  bitmap width = 288 bitmap height = 288 memory usage = 331776

drawable-xxhdip
2021-02-17 00:09:05.434 16820-16820/com.xuanliangdev.firstproject D/MainActivity:  bitmap width = 192 bitmap height = 192 memory usage = 147456

drawable-xxxhdpi
2021-02-17 00:09:43.582 16936-16936/com.xuanliangdev.firstproject D/MainActivity:  bitmap width = 144 bitmap height = 144 memory usage = 82944
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;答案同一张图片放在不同的drawable文件夹加载到内存中的大小是不一样的&#34;&gt;答案：同一张图片放在不同的drawable文件夹，加载到内存中的大小是不一样的。&lt;/h5&gt;
&lt;p&gt;宽为192的png图片放在drawable-xxhdpi目录，在屏幕密度为480的手机，加载到内存的宽为：width = 192 * （480）/(480) = 192&lt;/p&gt;
&lt;p&gt;放在drawable-xxxhdpi目录加载到内存的宽为：width = 192 * （480）/(640) = 144&lt;/p&gt;
&lt;p&gt;放在drawable-xhdpi目录加载到内存的宽为：width = 192 * （480）/(320) = 288&lt;/p&gt;
&lt;p&gt;放在drawable目录加载到内存的宽为：width = 192 * （480）/(160) = 578&lt;/p&gt;
&lt;p&gt;高度计算方法一样。&lt;/p&gt;
&lt;h5 id=&#34;公式&#34;&gt;公式：&lt;/h5&gt;
&lt;p&gt;1、scale = (float) targetDensity / density;（targetDensity为机型分辨率密度，density为资源所在目录密度，如默认drawable为160，drawable-xxhdpi为480）&lt;/p&gt;
&lt;p&gt;2、scaledWidth = width * scale + 0.5f;&lt;/p&gt;
&lt;h4 id=&#34;22bitmap解码相关源码&#34;&gt;2.2、bitmap解码相关源码：&lt;/h4&gt;
&lt;h5 id=&#34;221bitmapfactorydecoderesource&#34;&gt;2.2.1、BitmapFactory.decodeResource&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;BitmapFactory.java

/**
 * Synonym for {@link #decodeResource(Resources, int, android.graphics.BitmapFactory.Options)}
 * with null Options.
 *
 * @param res The resources object containing the image data
 * @param id The resource id of the image data
 * @return The decoded bitmap, or null if the image could not be decoded.
 */
public static Bitmap decodeResource(Resources res, int id) {
    return decodeResource(res, id, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public static Bitmap decodeResource(Resources res, int id, Options opts) {
...
     final TypedValue value = new TypedValue();
     is = res.openRawResource(id, value);
...
     bm = decodeResourceStream(res, value, is, null, opts);
...
    return bm;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value,
        @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) {
    validate(opts);
    if (opts == null) {
        opts = new Options();
    }

    // TypedValue会取出res资源信息，比如从xxxhdp目录取出的图片资源，value.density为640.
    if (opts.inDensity == 0 &amp;amp;&amp;amp; value != null) {
        final int density = value.density;
        if (density == TypedValue.DENSITY_DEFAULT) {
            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;
        } else if (density != TypedValue.DENSITY_NONE) {
            opts.inDensity = density;
        }
    }
    
    if (opts.inTargetDensity == 0 &amp;amp;&amp;amp; res != null) {
        // 手机屏幕密度
        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;
    }
    
    return decodeStream(is, pad, opts);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public static Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding,
        @Nullable Options opts) {
    ..
    Bitmap bm = null;
..
        final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset();
        bm = nativeDecodeAsset(asset, outPadding, opts, Options.nativeInBitmap(opts),
..
        // 重新设置java层bitmap的scale
        setDensityFromOptions(bm, opts);
..
    return bm;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;static jobject nativeDecodeAsset(JNIEnv* env, jobject clazz, jlong native_asset,
        jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle) {

    Asset* asset = reinterpret_cast&amp;lt;Asset*&amp;gt;(native_asset);
    // since we know we&#39;ll be done with the asset when we return, we can
    // just use a simple wrapper
    return doDecode(env, std::make_unique&amp;lt;AssetStreamAdaptor&amp;gt;(asset), padding, options,
                    inBitmapHandle, colorSpaceHandle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;static jobject doDecode(JNIEnv* env, std::unique_ptr&amp;lt;SkStreamRewindable&amp;gt; stream,
                        jobject padding, jobject options, jlong inBitmapHandle,
                        jlong colorSpaceHandle) {
    ...
    // Update with options supplied by the client.
    if (options != NULL) {
        ...
        if (env-&amp;gt;GetBooleanField(options, gOptions_scaledFieldID)) {
            const int density = env-&amp;gt;GetIntField(options, gOptions_densityFieldID);
            const int targetDensity = env-&amp;gt;GetIntField(options, gOptions_targetDensityFieldID);
            const int screenDensity = env-&amp;gt;GetIntField(options, gOptions_screenDensityFieldID);
            if (density != 0 &amp;amp;&amp;amp; targetDensity != 0 &amp;amp;&amp;amp; density != screenDensity) {
               // targetDensity为手机屏幕密度，density为当前资源目录的密度
               scale = (float) targetDensity / density;
            }
        }
    }

    // Scale is necessary due to density differences.
    if (scale != 1.0f) {
        willScale = true;
        // 此处对bitmap的宽高进行调整
        scaledWidth = static_cast&amp;lt;int&amp;gt;(scaledWidth * scale + 0.5f);
        scaledHeight = static_cast&amp;lt;int&amp;gt;(scaledHeight * scale + 0.5f);
    }
...
    // 创建bitmap
    // now create the java bitmap
    return bitmap::createBitmap(env, defaultAllocator.getStorageObjAndReset(),
            bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;// native层回调创建Java的bitmap对象
// called from JNI and Bitmap_Delegate.
Bitmap(long nativeBitmap, int width, int height, int density,
        boolean requestPremultiplied, byte[] ninePatchChunk,
        NinePatch.InsetStruct ninePatchInsets, boolean fromMalloc) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;// 重新设置java层bitmap的scale
/**
 * Set the newly decoded bitmap&#39;s density based on the Options.
 */
private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) {
    if (outputBitmap == null || opts == null) return;

    final int density = opts.inDensity;
    if (density != 0) {
        outputBitmap.setDensity(density);
        final int targetDensity = opts.inTargetDensity;
        if (targetDensity == 0 || density == targetDensity || density == opts.inScreenDensity) {
            return;
        }

        byte[] np = outputBitmap.getNinePatchChunk();
        final boolean isNinePatch = np != null &amp;amp;&amp;amp; NinePatch.isNinePatchChunk(np);
        if (opts.inScaled || isNinePatch) {
            outputBitmap.setDensity(targetDensity);
        }
    } else if (opts.inBitmap != null) {
        // bitmap was reused, ensure density is reset
        outputBitmap.setDensity(Bitmap.getDefaultDensity());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;222bitmapgetallocationbytecount&#34;&gt;2.2.2、Bitmap#getAllocationByteCount&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Returns the size of the allocated memory used to store this bitmap&#39;s pixels.
 *
 * &amp;lt;p&amp;gt;This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to
 * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link
 * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link
 * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap
 * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be
 * the same as that returned by {@link #getByteCount()}.&amp;lt;/p&amp;gt;
 *
 * &amp;lt;p&amp;gt;This value will not change over the lifetime of a Bitmap.&amp;lt;/p&amp;gt;
 *
 * @see #reconfigure(int, int, Config)
 */
public final int getAllocationByteCount() {
    if (mRecycled) {
        Log.w(TAG, &amp;quot;Called getAllocationByteCount() on a recycle()&#39;d bitmap! &amp;quot;
                + &amp;quot;This is undefined behavior!&amp;quot;);
        return 0;
    }
    return nativeGetAllocationByteCount(mNativePtr);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;jni/Bitmap.cpp

{   &amp;quot;nativeGetAllocationByteCount&amp;quot;, &amp;quot;(J)I&amp;quot;, (void*)Bitmap_getAllocationByteCount }

static jint Bitmap_getAllocationByteCount(JNIEnv* env, jobject, jlong bitmapPtr) {
    LocalScopedBitmap bitmapHandle(bitmapPtr);
    return static_cast&amp;lt;jint&amp;gt;(bitmapHandle-&amp;gt;getAllocationByteCount());
}

static jint Bitmap_rowBytes(JNIEnv* env, jobject, jlong bitmapHandle) {
    LocalScopedBitmap bitmap(bitmapHandle);
    return static_cast&amp;lt;jint&amp;gt;(bitmap-&amp;gt;rowBytes());
}

size_t rowBytes() const {
     if (mBitmap) {
         return mBitmap-&amp;gt;rowBytes();
     }
     return mRowBytes;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;hwui/Bitmap.cpp
size_t Bitmap::getAllocationByteCount() const {
    switch (mPixelStorageType) {
        case PixelStorageType::Heap:
            return mPixelStorage.heap.size;
        case PixelStorageType::Ashmem:
            return mPixelStorage.ashmem.size;
        default:
            return rowBytes() * height();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;readpixels.cpp

size_t rowBytes = image-&amp;gt;width() * SkColorTypeBytesPerPixel(dstColorType);
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;参考文档&#34;&gt;参考文档：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/training/multiscreen/screendensities?hl=zh-cn&#34;&gt;https://developer.android.com/training/multiscreen/screendensities?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903428729094157&#34;&gt;https://juejin.cn/post/6844903428729094157&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;3如何正确的加载一张图片而不造成内存浪费&#34;&gt;3.如何正确的加载一张图片而不造成内存浪费&lt;/h4&gt;
&lt;p&gt;通过前两节知道可以通过减少bitmap的宽高或者色彩格式来降低内存消耗。&lt;/p&gt;
&lt;p&gt;1、可以通过在不同的drawable目录内置不同分辨率的图片，注意图片不能只放在默认的drawable中，需要尽量往高分辨率的目录放，由上面的测试结果可以知道，同一张192*192的图片，仅仅放在默认drawable目录比放在drawable-xxhdi（针对匹配的屏幕密度为480的机型，目前市面绝大部分机型都是这个值，小米手机90%机型是440屏幕密度）内存消耗多9倍（（480/160)^2）（这里暂时不考虑图片宽高减小造成的图片分辨率变低的问题）。&lt;/p&gt;
&lt;p&gt;2、通过代码修改bitmap的inSampleSize值直接等比例缩小图片宽高，从而适应imageview大小，来减少内存消耗，官网文档https://developer.android.com/topic/performance/graphics/load-bitmap建议我们用一些优秀的三方图片加载库来加载图片，也提供了一个方法找出适当的inSampleSize值来适应bitmap的宽高和imageview的宽高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 计算出合适的inSampleSize值
public static int calculateInSampleSize(
                BitmapFactory.Options options, int reqWidth, int reqHeight) {
        // Raw height and width of image
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;

        if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {

            final int halfHeight = height / 2;
            final int halfWidth = width / 2;

            // Calculate the largest inSampleSize value that is a power of 2 and keeps both
            // height and width larger than the requested height and width.
            while ((halfHeight / inSampleSize) &amp;gt;= reqHeight
                    &amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt;= reqWidth) {
                inSampleSize *= 2;
            }
        }

        return inSampleSize;
    }
// 通过计算出的inSampleSize值来调整bitmap的宽高    
     public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
            int reqWidth, int reqHeight) {

        // First decode with inJustDecodeBounds=true to check dimensions
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(res, resId, options);

        // Calculate inSampleSize
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

        // Decode bitmap with inSampleSize set
        options.inJustDecodeBounds = false;
        return BitmapFactory.decodeResource(res, resId, options);
    }
// 加载图片    
    imageView.setImageBitmap(
        decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Android Architecture Blueprints学习</title>
      <link>https://xuanliangdev.github.io/post/android-architecture-blueprints/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android-architecture-blueprints/</guid>
      
        <description>&lt;h3 id=&#34;google-android-architecture-blueprints学习&#34;&gt;google Android Architecture Blueprints学习&lt;/h3&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.google.cn/topic/libraries/architecture&#34;&gt;https://developer.android.google.cn/topic/libraries/architecture&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1todo-mvp&#34;&gt;1、todo-mvp&lt;/h3&gt;
&lt;p&gt;一个便签的demo，&lt;/p&gt;
&lt;p&gt;类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/architecture/mvpclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;核心：&lt;/p&gt;
&lt;p&gt;1、View：&lt;/p&gt;
&lt;p&gt;将对于view的操作封装成具体的接口，Activity或者Fragment来实现这些接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface AddEditTaskContract {

    interface View extends BaseView&amp;lt;Presenter&amp;gt; {

        void showEmptyTaskError();

        void showTasksList();

        void setTitle(String title);

        void setDescription(String description);

        boolean isActive();
    }
...
}

public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;持有Present接口（具体各个业务的Present对象），将界面对于数据的操作转接给Present层（比如保存编辑的数据），可以将原本Fragment繁重的数据操作逻辑转交给Present层实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fab.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        mPresenter.saveTask(mTitle.getText().toString(), mDescription.getText().toString());
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、Model：&lt;/p&gt;
&lt;p&gt;本地数据库采用了Room库，&lt;/p&gt;
&lt;p&gt;参考资料：https://developer.android.com/training/data-storage/room&lt;/p&gt;
&lt;p&gt;TasksRepository：管理数据的读取或者是保存，给present层提供Task控制接口&lt;/p&gt;
&lt;p&gt;3、Present：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface AddEditTaskContract {
...

    interface Presenter extends BasePresenter {

        void saveTask(String title, String description);

        void populateTask();

        boolean isDataMissing();
    }
}

public class AddEditTaskPresenter implements AddEditTaskContract.Presenter,
        TasksDataSource.GetTaskCallback {
...
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;持有View相关接口（Fragment对象），通过View接口更新界面元素&lt;/p&gt;
&lt;h3 id=&#34;2todo-mvvm-databinding&#34;&gt;2、todo-mvvm-databinding&lt;/h3&gt;
&lt;p&gt;待续。。。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>RecyclerView学习整理</title>
      <link>https://xuanliangdev.github.io/post/recyclerview/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/recyclerview/</guid>
      
        <description>&lt;h4 id=&#34;疑问&#34;&gt;疑问&lt;/h4&gt;
&lt;h5 id=&#34;1recyclerview缓存复用机制原理&#34;&gt;1、RecyclerView缓存复用机制原理？&lt;/h5&gt;
&lt;h5 id=&#34;2pre-layout和prefetch原理&#34;&gt;2、pre-layout和prefetch原理？&lt;/h5&gt;
&lt;h2 id=&#34;recyclerview-核心类图&#34;&gt;RecyclerView 核心类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/recyclerview/recyclerviewclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1核心流程&#34;&gt;1、核心流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/recyclerview/recyclerview.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;核心流程源码&#34;&gt;核心流程源码：&lt;/h5&gt;
&lt;p&gt;1、三个layout流程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * The first step of a layout where we;
 * - process adapter updates
 * - decide which animation should run
 * - save information about current views
 * - If necessary, run predictive layout and save its information
 */
private void dispatchLayoutStep1() {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * The second layout step where we do the actual layout of the views for the final state.
 * This step might be run multiple times if necessary (e.g. measure).
 */
private void dispatchLayoutStep2() {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * The final step of the layout where we save the information about views for animations,
 * trigger animations and do any necessary cleanup.
 */
private void dispatchLayoutStep3() {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;ViewHolder tryGetViewHolderForPositionByDeadline(int position,
        boolean dryRun, long deadlineNs) {
    ...
    ViewHolder holder = null;
    // 0) If there is a changed scrap, try to find from there
    if (mState.isPreLayout()) {
        holder = getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache = holder != null;
    }
    // 1) Find by position from scrap/hidden list/cache
    if (holder == null) {
        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
        ...
    }
    if (holder == null) {
        ...

        final int type = mAdapter.getItemViewType(offsetPosition);
        // 2) Find from scrap/cache via stable ids, if exists
        if (mAdapter.hasStableIds()) {
            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                    type, dryRun);
            ...
        }
        if (holder == null &amp;amp;&amp;amp; mViewCacheExtension != null) {
            // We are NOT sending the offsetPosition because LayoutManager does not
            // know it.
            final View view = mViewCacheExtension
                    .getViewForPositionAndType(this, position, type);
            if (view != null) {
                holder = getChildViewHolder(view);
                ...
            }
        }
        if (holder == null) { // fallback to pool
            ...
            holder = getRecycledViewPool().getRecycledView(type);
            if (holder != null) {
                holder.resetInternal();
                ...
            }
        }
        if (holder == null) {
            ...
            holder = mAdapter.createViewHolder(RecyclerView.this, type);
            ...
        }
    }
    ...
    boolean bound = false;
    if (mState.isPreLayout() &amp;amp;&amp;amp; holder.isBound()) {
        // do not update unless we absolutely have to.
        holder.mPreLayoutPosition = position;
    } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
        ...
        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
    }
...
    return holder;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;11屏幕内复用&#34;&gt;1.1、屏幕内复用&lt;/h4&gt;
&lt;p&gt;当屏幕内的内容进行更新时的缓存&lt;/p&gt;
&lt;h5 id=&#34;111-arraylistviewholder-mchangedscrap&#34;&gt;1.1.1 ArrayList&lt;!-- raw HTML omitted --&gt; mChangedScrap&lt;/h5&gt;
&lt;p&gt;1.1.1.1 缓存存入时机&lt;/p&gt;
&lt;p&gt;当执行notifyItemChanged方法（比如动画刷新某个列表项）时，会使holder.needsUpdate()为true，把除了做动画的item放进mChangedScrap，其余的item则放进mAttachedScrap。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void scrapView(View view) {
    final ViewHolder holder = getChildViewHolderInt(view);
    if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
            || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
        ...
        mAttachedScrap.add(holder);
    } else {
        ...
        mChangedScrap.add(holder);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.1.1.2 缓存取出时机，只有在mState.isPreLayout()状态下会从ChangedScrap中取缓存，dispatchLayoutStep1的时候会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
                ...
		// 0) If there is a changed scrap, try to find from there
		if (mState.isPreLayout()) {
   		 holder = getChangedScrapViewForPosition(position);
   		 fromScrapOrHiddenOrCache = holder != null;
		}
		...
}

public boolean isPreLayout() {
     return mInPreLayout;
}
        
private void dispatchLayoutStep1() {
..
   mState.mInPreLayout = mState.mRunPredictiveAnimations;
...
}

private void processAdapterUpdatesAndSetAnimationFlags() {
...
    mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
        &amp;amp;&amp;amp; animationTypeSupported
        &amp;amp;&amp;amp; !mDataSetHasChangedAfterLayout
        &amp;amp;&amp;amp; predictiveItemAnimationsEnabled();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由上代码调用知道preLayout的状态受到predictiveItemAnimationsEnabled方法影响，因此如果需要预布局，我们需要重写LinearLayoutManager的supportsPredictiveItemAnimations方法返回true（默认为false），才会从mChangedScrap取缓存。&lt;/p&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://frogermcs.github.io/recyclerview-animations-androiddevsummit-write-up/&#34;&gt;http://frogermcs.github.io/recyclerview-animations-androiddevsummit-write-up/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904146684870669&#34;&gt;https://juejin.cn/post/6844904146684870669&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;预布局核心原理&#34;&gt;预布局核心原理：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;LinearLayoutManager.java

private void dispatchLayoutStep1() {
        ...
        if (mState.mRunPredictiveAnimations) {
            // Step 1: run prelayout: This will use the old positions of items. The layout manager
            // is expected to layout everything, even removed items (though not to add removed
            // items back to the container). This gives the pre-layout position of APPEARING views
            // which come into existence as part of the real layout.

            // Save old positions so that LayoutManager can run its mapping logic.
            saveOldPositions();
            final boolean didStructureChange = mState.mStructureChanged;
            mState.mStructureChanged = false;
            // temporarily disable flag because we are asking for previous layout
            mLayout.onLayoutChildren(mRecycler, mState);
            mState.mStructureChanged = didStructureChange;

            ...
            // we don&#39;t process disappearing list because they may re-appear in post layout pass.
            clearOldPositions();
        } else {
            clearOldPositions();
        }
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
        mState.mLayoutStep = State.STEP_LAYOUT;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当删除一个可见的item时，额外增加一个将要显示的item，这样item进入的时候就可以滑入而不是渐变的方式展现&lt;/p&gt;
&lt;h5 id=&#34;112-arraylistviewholder-mattachedscrap&#34;&gt;1.1.2 ArrayList&lt;!-- raw HTML omitted --&gt; mAttachedScrap&lt;/h5&gt;
&lt;p&gt;1.1.2.1 缓存存入时机&lt;/p&gt;
&lt;p&gt;见1.1.1.1节&lt;/p&gt;
&lt;p&gt;1.1.2.2缓存取出时机&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
   ...             
		// 1) Find by position from scrap/hidden list/cache
		if (holder == null) {
  		  holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
		}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;113-getscraporcachedviewforid&#34;&gt;1.1.3 getScrapOrCachedViewForId&lt;/h5&gt;
&lt;p&gt;通过id取缓存，该机制只对设置了Adapter.hasStableIds()为true，并且配合重写getItemId(int position) 方法才会生效，可以解决一些数据刷新图片闪烁的问题（网上的说法，暂时还没验证）&lt;/p&gt;
&lt;h4 id=&#34;12滚动复用&#34;&gt;1.2、滚动复用&lt;/h4&gt;
&lt;h5 id=&#34;121-arraylistviewholder-mcachedviews&#34;&gt;1.2.1 ArrayList&lt;!-- raw HTML omitted --&gt; mCachedViews&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/recyclerview/cachedviews.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1.2.1.1&lt;/p&gt;
&lt;p&gt;屏幕外的第一级缓存，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int mViewCacheMax = DEFAULT_CACHE_SIZE;
...
static final int DEFAULT_CACHE_SIZE = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果支持预取操作（最新版默认开启，开发者可以自行选择关闭）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GapWorker.java
void collectPrefetchPositionsFromView(RecyclerView view, boolean nested) {
...
        if (nested) {
         ..
                layout.collectInitialPrefetchPositions(view.mAdapter.getItemCount(), this);
        } else {
        ..
                layout.collectAdjacentPrefetchPositions(mPrefetchDx, mPrefetchDy,
                        view.mState, this);
        }

        if (mCount &amp;gt; layout.mPrefetchMaxCountObserved) {
            layout.mPrefetchMaxCountObserved = mCount;
            layout.mPrefetchMaxObservedInInitialPrefetch = nested;
            view.mRecycler.updateViewCacheSize();
        }
}

Recycler.java
void updateViewCacheSize() {
    int extraCache = mLayout != null ? mLayout.mPrefetchMaxCountObserved : 0;
    mViewCacheMax = mRequestedCacheMax + extraCache;
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果recyclerview支持嵌套，用户可以设置预取的个数，走collectInitialPrefetchPositions逻辑，默认情况下走collectAdjacentPrefetchPositions逻辑，mCount++设置为1，从而赋值给mPrefetchMaxCountObserved，所以一级缓存默认情况下最大值是3&lt;/p&gt;
&lt;p&gt;1.2.1.2 预取机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/recyclerview/prefeching.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weishenhong/article/details/81150172&#34;&gt;https://blog.csdn.net/weishenhong/article/details/81150172&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/crazy_everyday_xrp/article/details/70344638?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&#34;&gt;https://blog.csdn.net/crazy_everyday_xrp/article/details/70344638?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/google-developers/recyclerview-prefetch-c2f269075710&#34;&gt;https://medium.com/google-developers/recyclerview-prefetch-c2f269075710&lt;/a&gt;（需要科学上网）&lt;/p&gt;
&lt;h5 id=&#34;gapworker预取加载原理将闲置的ui线程利用起来在ui线程将页面数据交由render线程渲染以后提前处理下一个显示的item的数据创建和绑定&#34;&gt;GapWorker预取加载原理：将闲置的UI线程利用起来，在UI线程将页面数据交由Render线程渲染以后提前处理下一个显示的item的数据创建和绑定。&lt;/h5&gt;
&lt;h5 id=&#34;122-viewcacheextension&#34;&gt;1.2.2 ViewCacheExtension&lt;/h5&gt;
&lt;p&gt;屏幕外的第二级缓存，开发者可以自定义的缓存，在RecycledViewPool前，CachedViews之后。&lt;/p&gt;
&lt;h5 id=&#34;123-recycledviewpool&#34;&gt;1.2.3 RecycledViewPool&lt;/h5&gt;
&lt;p&gt;屏幕外的第三级缓存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final int DEFAULT_MAX_SCRAP = 5;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RecycledViewPool默认最大缓存为5个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (holder == null) { // fallback to pool
...
    holder = getRecycledViewPool().getRecycledView(type);
    if (holder != null) {
        holder.resetInternal();
        if (FORCE_INVALIDATE_DISPLAY_LIST) {
            invalidateDisplayListInt(holder);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;void resetInternal() {
    mFlags = 0;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;boolean bound = false;
if (mState.isPreLayout() &amp;amp;&amp;amp; holder.isBound()) {
    // do not update unless we absolutely have to.
    holder.mPreLayoutPosition = position;
} else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
    if (DEBUG &amp;amp;&amp;amp; holder.isRemoved()) {
        throw new IllegalStateException(&amp;quot;Removed holder should be bound and it should&amp;quot;
                + &amp;quot; come here only in pre-layout. Holder: &amp;quot; + holder
                + exceptionLabel());
    }
    final int offsetPosition = mAdapterHelper.findPositionOffset(position);
    bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tryBindViewHolderByDeadline会回调onBindViewHolder逻辑，由判断条件知道，从RecycledViewPool取出的holder会清理标志位，!holder.isBound()为true，所以从RecycledViewPool取出的holder会重新走onBindViewHolder逻辑，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;holder.isBound()&lt;/td&gt;
&lt;td&gt;回调onBindViewHolder前会设置isBound为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;holder.needsUpdate()&lt;/td&gt;
&lt;td&gt;onItemRangeChanged进行更新时会触发，对应某个item更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;holder.isInvalid()&lt;/td&gt;
&lt;td&gt;notifyDataSetChanged被调用，对应整个数据集刷新&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;/**
 * This ViewHolder has been bound to a position; mPosition, mItemId and mItemViewType
 * are all valid.
 */
static final int FLAG_BOUND = 1 &amp;lt;&amp;lt; 0;

/**
 * The data this ViewHolder&#39;s view reflects is stale and needs to be rebound
 * by the adapter. mPosition and mItemId are consistent.
 */
static final int FLAG_UPDATE = 1 &amp;lt;&amp;lt; 1;

/**
 * This ViewHolder&#39;s data is invalid. The identity implied by mPosition and mItemId
 * are not to be trusted and may no longer match the item view type.
 * This ViewHolder must be fully rebound to different data.
 */
static final int FLAG_INVALID = 1 &amp;lt;&amp;lt; 2;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;一些api分析&#34;&gt;一些api分析：&lt;/h4&gt;
&lt;h5 id=&#34;1sethasfixedsize&#34;&gt;1、setHasFixedSize：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;        @Override
        public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
            assertNotInLayoutOrScroll(null);
            if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
                triggerUpdateProcessor();
            }
        }

        @Override
        public void onItemRangeInserted(int positionStart, int itemCount) {
            assertNotInLayoutOrScroll(null);
            if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) {
                triggerUpdateProcessor();
            }
        }

        @Override
        public void onItemRangeRemoved(int positionStart, int itemCount) {
            assertNotInLayoutOrScroll(null);
            if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {
                triggerUpdateProcessor();
            }
        }

        @Override
        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {
            assertNotInLayoutOrScroll(null);
            if (mAdapterHelper.onItemRangeMoved(fromPosition, toPosition, itemCount)) {
                triggerUpdateProcessor();
            }
        }

        void triggerUpdateProcessor() {
            if (POST_UPDATES_ON_ANIMATION &amp;amp;&amp;amp; mHasFixedSize &amp;amp;&amp;amp; mIsAttached) {
                ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);
            } else {
                mAdapterUpdateDuringMeasure = true;
                requestLayout();
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果设置setHasFixedSize为true，通过onItemRangeInserted、onItemRangeRemoved等方法更新列表时不会重新requestLayout，提升性能&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>一次列表卡顿分析</title>
      <link>https://xuanliangdev.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;内存专项测试问题发现：小米闻声第一版时自测发现，当连续识别时间过长超过半小时，界面列表滑动出现明显卡顿，重启应用后卡顿不复现。&lt;/p&gt;
&lt;h2 id=&#34;1问题定位&#34;&gt;1、问题定位&lt;/h2&gt;
&lt;p&gt;卡顿分析工具：&lt;/p&gt;
&lt;p&gt;1、开发者选项-GPU呈现模式分析（或者叫HWUI呈现模式分析）&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/profile/inspect-gpu-rendering?hl=zh-cn&#34;&gt;https://developer.android.com/studio/profile/inspect-gpu-rendering?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/topic/performance/rendering/profile-gpu&#34;&gt;https://developer.android.com/topic/performance/rendering/profile-gpu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpurendering.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;开发者选项开启GPU呈现分析，卡顿产生后可以明显看出来，每个竖条表示一帧渲染时间，很多都超过了水平线16ms，正常流畅情况下是如下图这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpurenderingnormal.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上这个图只能帮助我们大概定位卡顿的位置，为绿色部分。根据google开发文档&lt;/p&gt;
&lt;p&gt;深蓝区域为绘制流程，往前一个浅绿区域为测量/布局流程，再往前为动画流程。这个工具并不能帮助我们定位到具体的代码段。只是大致的一个范围&lt;/p&gt;
&lt;p&gt;2、Android Studio工具CPU Profiler&lt;/p&gt;
&lt;p&gt;参考资料：https://developer.android.google.cn/studio/profile/cpu-profiler&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpuprofile.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2原理分析&#34;&gt;2、原理分析&lt;/h2&gt;
&lt;h3 id=&#34;21-android刷新机制&#34;&gt;2.1 Android刷新机制&lt;/h3&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://hukai.me/android-performance-patterns/&#34;&gt;http://hukai.me/android-performance-patterns/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://hukai.me/android-performance-render/&#34;&gt;http://hukai.me/android-performance-render/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/dasusu/p/8311324.html&#34;&gt;https://www.cnblogs.com/dasusu/p/8311324.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gityuan.com/2017/02/25/choreographer/&#34;&gt;http://gityuan.com/2017/02/25/choreographer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VSYN&lt;/p&gt;
&lt;p&gt;Refresh rate:一秒内刷新屏幕次数&lt;/p&gt;
&lt;p&gt;Frame rate:gpu一秒内操作的帧数&lt;/p&gt;
&lt;p&gt;卡顿原因：大部分屏幕刷新率时60Hz，如果1000/60=16.67ms内没办法处理一帧任务，那么就会发生丢帧，也就是卡顿。&lt;/p&gt;
&lt;p&gt;cpu负责Measure、Layout、Record、Excecute的计算操作，GPU负责rasterization（栅格化）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/vsync.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fragment机制原理溯源</title>
      <link>https://xuanliangdev.github.io/post/fragment%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/fragment%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;1概述fragment机制&#34;&gt;1、概述Fragment机制&lt;/h2&gt;
&lt;p&gt;1、Android3.0引入，可以给大屏幕动态界面设计提供支持。&lt;/p&gt;
&lt;p&gt;2、现在主要用在一个页面内嵌多个Tab时使用。&lt;/p&gt;
&lt;h2 id=&#34;2fragment机制原理总结&#34;&gt;2、Fragment机制原理总结&lt;/h2&gt;
&lt;p&gt;当前Android最新版本已经是R，Fragment机制也增加了不少改动，复杂了很多，为了单纯了解核心机制，最快的方法可以直接从最初的代码入手。&lt;/p&gt;
&lt;h4 id=&#34;初版fragment机制三个核心类&#34;&gt;初版Fragment机制，三个核心类：&lt;/h4&gt;
&lt;h5 id=&#34;1fragmentmanager&#34;&gt;1）FragmentManager：&lt;/h5&gt;
&lt;p&gt;控制Fragment的生命周期，核心是控制Fragment的view状态，比如将fragment中的view添加到Activity中或者将view从Activity中移除，第一版时FragmentManager是放在Activity里的。&lt;/p&gt;
&lt;h5 id=&#34;2fragment&#34;&gt;2）Fragment：&lt;/h5&gt;
&lt;p&gt;应用的一个UI片段或行为，可以在Activity中被替换，持有自己的View，定义了自己的生命周期，但是生命周期依赖于依附的Activity的生命周期，当Activity销毁时，Fragment同时也会被销毁。&lt;/p&gt;
&lt;h5 id=&#34;3fragmenttransactionimplfragmenttransaction的实现类&#34;&gt;3）FragmentTransactionImpl（FragmentTransaction的实现类）：&lt;/h5&gt;
&lt;p&gt;对外提供控制Fragment操作的接口，初版只有添加、移除和comit操作，添加和移除只是对添加队列和移除队列操作，commit时委托FragmentManager真正执行操作，设置Fragment的生命周期状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentversion.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;初版类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentclass.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;初版时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentseq.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;当前最新的fragment机制&#34;&gt;当前最新的Fragment机制：&lt;/h4&gt;
&lt;p&gt;为了将Activity和FragmentManager解耦，方便其他地方也可以使用Fragment，比如我们其实可以在service中使用Fragment，虽然场景不是很多。&lt;/p&gt;
&lt;p&gt;比如如下博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mjlong123123/article/details/104156953&#34;&gt;https://blog.csdn.net/mjlong123123/article/details/104156953&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;4fragmentcontroller&#34;&gt;4）FragmentController：&lt;/h5&gt;
&lt;p&gt;FragmentController中的“所有”动作真正执行者都是FragmentHostCallback，绝大部分大部分的动作真正执行者是FragmentHostCallback中的FragmentManager。&lt;/p&gt;
&lt;h5 id=&#34;5hostcallbacksfragmenthostcallback&#34;&gt;5）HostCallbacks（FragmentHostCallback）：&lt;/h5&gt;
&lt;p&gt;为了将FragmentManager于FragmentManager解耦，必须有一个中间类来真正持有FragmentManager对象，这个类就是FragmentHostCallback，Activity中的实现是HostCallbacks，当然，如果我们想要在service中使用Fragment，可以自定义类来继承FragmentHostCallback类来实现。&lt;/p&gt;
&lt;p&gt;实际调用链&lt;/p&gt;
&lt;p&gt;Activity-&amp;gt;FragmentController-&amp;gt;FragmentHostCallback-&amp;gt;FragmentManager，&lt;/p&gt;
&lt;p&gt;BackStackRecord（FragmentTransaction的实现类）：第一版时叫FragmentTransactionImpl，对外提供控制Fragment操作的接口，比如添加或移除。&lt;/p&gt;
&lt;h2 id=&#34;3细节&#34;&gt;3、细节&lt;/h2&gt;
&lt;p&gt;P版本Fragment机制&lt;/p&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/lastestfragmentclass.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;时序图，以下面的代码为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    FragmentManager fragmentManager = getFragmentManager();
    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

    LearnFragment fragment = new LearnFragment();
    fragmentTransaction.add(R.id.fragment_contain, fragment);
    fragmentTransaction.commit();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/lastestfragmentseq.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    void moveToState(Fragment f, int newState, int transit, int transitionStyle,
            boolean keepActive) {
        ...
        if (f.mState &amp;lt;= newState) {
            ...
            switch (f.mState) {
                case Fragment.INITIALIZING:
                    if (newState &amp;gt; Fragment.INITIALIZING) {
                        ...
                        f.onAttach(mHost.getContext());
                        ...
                        if (f.mParentFragment == null) {
                            mHost.onAttachFragment(f);
                        } 
                      ...
                        if (!f.mIsCreated) {
...
                            f.performCreate(f.mSavedFragmentState);
                            dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                        } ...
                    }
                    // fall through
                case Fragment.CREATED:
                    ...
                    if (newState &amp;gt; Fragment.CREATED) {
                        if (DEBUG) Log.v(TAG, &amp;quot;moveto ACTIVITY_CREATED: &amp;quot; + f);
                        if (!f.mFromLayout) {
                            ViewGroup container = null;
                            ...
                            f.mView = f.performCreateView(f.performGetLayoutInflater(
                                    f.mSavedFragmentState), container, f.mSavedFragmentState);
                            if (f.mView != null) {
                                ...
                                    container.addView(f.mView);
                                ...
                                f.onViewCreated(f.mView, f.mSavedFragmentState);
                                ....
                            }
                        }

                        f.performActivityCreated(f.mSavedFragmentState);
                        ...
                    }
                    // fall through
                case Fragment.ACTIVITY_CREATED:
                    ...
                    // fall through
                case Fragment.STOPPED:
...
                        f.performStart();
...
                    // fall through
                case Fragment.STARTED:
...
                        f.performResume();
...
            }
        } else if (f.mState &amp;gt; newState) {
            switch (f.mState) {
                case Fragment.RESUMED:
...
                        f.performPause();
...
                    // fall through
                case Fragment.STARTED:
...
                        f.performStop();
...
                    // fall through
                case Fragment.STOPPED:
                case Fragment.ACTIVITY_CREATED:
...
                        f.performDestroyView();
...
                            f.mContainer.removeView(f.mView);
...
                    // fall through
                case Fragment.CREATED:
...
                                f.performDestroy();
...
                            f.performDetach();
                            ...
            }
        }
...
            f.mState = newState;
...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;FragmentTransaction：是接口类型，实现类在Activity中，为FragmentTransactionImpl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final class FragmentTransactionImpl implements FragmentTransaction {
    ArrayList&amp;lt;Fragment&amp;gt; mAdded;
    ArrayList&amp;lt;Fragment&amp;gt; mRemoved;
    
    public FragmentTransaction add(Fragment fragment, int containerViewId) {
        return add(fragment, null, containerViewId);
    }

    public FragmentTransaction add(Fragment fragment, String name, int containerViewId) {
        if (fragment.mActivity != null) {
            throw new IllegalStateException(&amp;quot;Fragment already added: &amp;quot; + fragment);
        }
        if (name != null) {
            fragment.mName = name;
        }
        if (mRemoved != null) {
            mRemoved.remove(fragment);
        }
        if (mAdded == null) {
            mAdded = new ArrayList&amp;lt;Fragment&amp;gt;();
        }
        fragment.mContainerId = containerViewId;
        mAdded.add(fragment);
        return this;
    }

    public FragmentTransaction remove(Fragment fragment) {
        if (fragment.mActivity == null) {
            throw new IllegalStateException(&amp;quot;Fragment not added: &amp;quot; + fragment);
        }
        if (mAdded != null) {
            mAdded.remove(fragment);
        }
        if (mRemoved == null) {
            mRemoved = new ArrayList&amp;lt;Fragment&amp;gt;();
        }
        mRemoved.add(fragment);
        return this;
    }

    public void commit() {
        if (mRemoved != null) {
            for (int i=mRemoved.size()-1; i&amp;gt;=0; i--) {
                mFragments.removeFragment(mRemoved.get(i));
            }
        }
        if (mAdded != null) {
            for (int i=mAdded.size()-1; i&amp;gt;=0; i--) {
                mFragments.addFragment(mAdded.get(i));
            }
        }
        if (mFragments != null) {
            mFragments.moveToState(mFragments.mCurState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Activity：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final void performCreate(Bundle icicle) {
    onCreate(icicle);
    mFragments.dispatchCreate(icicle);
}
    
final void performStart() {
    mCalled = false;
    mInstrumentation.callActivityOnStart(this);
。。。
    mFragments.dispatchStart();
}
    
final void performResume() {
    performRestart();
。。。
    mInstrumentation.callActivityOnResume(this);
。。。
        
    mFragments.dispatchResume();
        
    onPostResume();
。。。
}

final void performPause() {
    mFragments.dispatchPause();
    onPause();
}
    
final void performStop() {
。。。
     mFragments.dispatchStop();
。。。
     mInstrumentation.callActivityOnStop(this);
。。。
}
    
final void performDestroy() {
    mFragments.dispatchDestroy();
    onDestroy();
}

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>无障碍学习整理（基于talkback）</title>
      <link>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</guid>
      
        <description>&lt;h2 id=&#34;一整理原因&#34;&gt;一、整理原因：&lt;/h2&gt;
&lt;p&gt;为了辅助理解无障碍google官方开发文档api的原理。&lt;/p&gt;
&lt;h2 id=&#34;二参考文档&#34;&gt;二、参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.google.cn/guide/topics/ui/accessibility&#34;&gt;无障碍开发google官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;三无障碍服务框架结构分析&#34;&gt;三、无障碍服务框架结构分析&lt;/h2&gt;
&lt;h3 id=&#34;31结构&#34;&gt;3.1.结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/accessibility/%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;32相关类图&#34;&gt;3.2、相关类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/accessibilityclass.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;整个talkback机制涉及了4个进程，SystemServer（蓝色部分）、Talkback（黄色部分）、被辅助app进程（绿色部分），TTS引擎进程（暂不分析）&lt;/p&gt;
&lt;p&gt;四个AIDL接口，图上红色部分&lt;/p&gt;
&lt;h4 id=&#34;321talkback辅助app实现了accessibilityservice的app&#34;&gt;3.2.1、talkback（辅助app，实现了AccessibilityService的app）&lt;/h4&gt;
&lt;p&gt;辅助app需要用到的在framewors目录中相关的类，主要是继承AccessibilityService从而接收SystemServer进程发送过来的无障碍事件并进行相关处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yservice.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;322被辅助app进程被辅助app&#34;&gt;3.2.2、被辅助app进程（被辅助app）&lt;/h4&gt;
&lt;p&gt;被辅助的app的无障碍特性主要是通过扩展Android的View框架的功能对外提供，因此无障碍相关的类主要放在view包中，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/viewaccessibility.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;323system_process&#34;&gt;3.2.3、system_process&lt;/h4&gt;
&lt;p&gt;SystemServer进程中的无障碍服务管理类如下所示，比如核心的AccessibilityManagerService，用于协调辅助app进程和被辅助app进程的交互；TouchExpolorer用于实现“触摸浏览”手势功能等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yms.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;系统进程SystemServer中的AccessibilityManagerService，用来管理所有的无障碍服务，类似AMS，SystemServer启动时会在startOtherServices方法中启动AccessibilityManagerService，startOtherServices方法在ActivityManagerService、PackageManagerService等一些核心服务的后面启动。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.SystemServer.java

/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */
private void startOtherServices() {
...
            traceBeginAndSlog(&amp;quot;StartAccessibilityManagerService&amp;quot;);
            try {
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf(&amp;quot;starting Accessibility Manager&amp;quot;, e);
            }
            traceEnd();
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;334tts&#34;&gt;3.3.4、TTS&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/tts.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;暂不分析&lt;/p&gt;
&lt;h3 id=&#34;33-无障碍框架aidl接口&#34;&gt;3.3 无障碍框架AIDL接口&lt;/h3&gt;
&lt;p&gt;理解无障碍框架的aidl的设计是理解无障碍框架的关键。&lt;/p&gt;
&lt;p&gt;我们进行无障碍的开发通常会涉及到三个进程：&lt;/p&gt;
&lt;p&gt;辅助app（talkback、或者我们自己开发的无障碍应用（比如红包助手））&lt;/p&gt;
&lt;p&gt;SystemServer（系统服务进程，管理所有的无障碍服务，并且起到中转的作用，类似AMS的设计）&lt;/p&gt;
&lt;p&gt;被辅助的app（）&lt;/p&gt;
&lt;p&gt;跨进程通信需要用到aidl接口，无障碍服务框架也不例外，由于涉及到三个进程的通信，并且辅助app通常不需要直接跟被辅助的app通信，大部分通过SystemServer进行中转通信，因此主要涉及到了四个aidl接口：&lt;/p&gt;
&lt;p&gt;被辅助app-&amp;gt;SystemServer（IAccessibilityManager.aidl）&lt;/p&gt;
&lt;p&gt;SystemServer-&amp;gt;辅助app（IAccessibilityServiceClient.aidl）&lt;/p&gt;
&lt;p&gt;辅助app-&amp;gt;SystemServer（IAccessibilityServiceConnection.aidl）&lt;/p&gt;
&lt;p&gt;SystemServer-&amp;gt;被辅助app（IAccessibilityInteractionConnection.aidl）&lt;/p&gt;
&lt;h4 id=&#34;331iaccessibilitymanageraidl客户端被辅助app服务端systemserver&#34;&gt;3.3.1、IAccessibilityManager.aidl（客户端：被辅助app、服务端：SystemServer）&lt;/h4&gt;
&lt;p&gt;比如当被辅助app产生触摸事件后，会通过这个接口发送无障碍事件给SystemServer进程的AccessibilityManagerService&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityManager.aidl

/**
 * Interface implemented by the AccessibilityManagerService called by
 * the AccessibilityManagers.
 *
 * @hide
 */
interface IAccessibilityManager {

    oneway void sendAccessibilityEvent(in AccessibilityEvent uiEvent, int userId);

    long addClient(IAccessibilityManagerClient client, int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getInstalledAccessibilityServiceList(int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getEnabledAccessibilityServiceList(int feedbackType, int userId);

    int addAccessibilityInteractionConnection(IWindow windowToken,
            in IAccessibilityInteractionConnection connection,
            String packageName, int userId);

    void removeAccessibilityInteractionConnection(IWindow windowToken);

    void notifyAccessibilityButtonClicked();

    // Requires WRITE_SECURE_SETTINGS
    void performAccessibilityShortcut();

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;332-iaccessibilityserviceclientaidl客户端systemserver服务端辅助app&#34;&gt;3.3.2 、IAccessibilityServiceClient.aidl（客户端：SystemServer、服务端：辅助app）&lt;/h4&gt;
&lt;p&gt;当SystemServer接收到被辅助的app发送的无障碍事件时，会将事件通过该接口传递给辅助app进程进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceClient.aidl

/**
 * Top-level interface to an accessibility service component.
 */
oneway interface IAccessibilityServiceClient {

    void onAccessibilityEvent(in AccessibilityEvent event, in boolean serviceWantsEvent);

    void onSoftKeyboardShowModeChanged(int showMode);

    void onPerformGestureResult(int sequence, boolean completedSuccessfully);

    void onAccessibilityButtonClicked();

    void onAccessibilityButtonAvailabilityChanged(boolean available);
    
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;333iaccessibilityserviceconnectionaidl客户端辅助app服务端systemserver&#34;&gt;3.3.3、IAccessibilityServiceConnection.aidl（客户端：辅助app、服务端：SystemServer）&lt;/h4&gt;
&lt;p&gt;当我们需要找到被辅助的app的某个view的信息时，可以通过该接口的findAccessibilityNodeInfosByViewId方法实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceConnection.aidl

/**
 * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
 */
interface IAccessibilityServiceConnection {

    String[] findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId,
        in Bundle arguments);

    String[] findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    String[] findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    boolean isAccessibilityButtonAvailable();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;h4 id=&#34;334iaccessibilityinteractionconnectionaidl客户端systemserver服务端被辅助app&#34;&gt;3.3.4、IAccessibilityInteractionConnection.aidl（客户端：SystemServer、服务端：被辅助app）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityInteractionConnection.aidl

/**
 * Interface for interaction between the AccessibilityManagerService
 * and the ViewRoot in a given window.
 *
 * @hide
 */
oneway interface IAccessibilityInteractionConnection {

    void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId, in Region bounds,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid, in MagnificationSpec spec,
        in Bundle arguments);

    ...

    void findFocus(long accessibilityNodeId, int focusType, in Region bounds, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
        long interrogatingTid, in MagnificationSpec spec);

  ...

    void performAccessibilityAction(long accessibilityNodeId, int action, in Bundle arguments,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;四流程分析&#34;&gt;四、流程分析&lt;/h2&gt;
&lt;h3 id=&#34;41accessibilityservice启动流程以talkback开关打开后到talkbackservice启动进行分析&#34;&gt;4.1、AccessibilityService启动流程（以talkback开关打开后到TalkbackService启动进行分析）。&lt;/h3&gt;
&lt;p&gt;在设置中打开talback开关后，会调用到如下方法，最终会往Settings provider中key为Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES的字段写入Talkback注册的AccessibilityService值（TalkbackService），这个值保存在&lt;/p&gt;
&lt;p&gt;/data/system/users/0/settings_secure.xml文件中。（其他app的AccessibilityService也保存在同一个key中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.settingslib.accessibility.AccessibilityUtils.java

/**
 * Changes an accessibility component&#39;s state for {@param userId}.
 */
public static void setAccessibilityServiceState(Context context, ComponentName toggledService,
        boolean enabled, int userId) {
    ...
    Settings.Secure.putStringForUser(context.getContentResolver(),
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
            enabledServicesBuilder.toString(), userId);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于AccessibilityManagerService创建时注册了AccessibilityContentObserver，因此马上会收到Settings provider数据变化的监听。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

private void updateServicesLocked(UserState userState) {
    ...
        if (userState.mEnabledServices.contains(componentName)
                &amp;amp;&amp;amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
            if (service == null) {
                service = new AccessibilityServiceConnection(userState, mContext, componentName,
                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                        this, mWindowManagerService, mGlobalActionPerformer);
            } 
            ...
            service.bindLocked();
        } ...
    }
    ...
    updateAccessibilityEnabledSetting(userState);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据获取到的AccessibilityService信息（com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService）创建出AccessibilityServiceConnection。AccessibilityServiceConnection代表了一个无障碍服务，存储用于管理这个服务需要的所有数据，提供了开始/停止服务和在服务管理的数据结构中添加或者移除这个服务的api。&lt;/p&gt;
&lt;p&gt;接着调用bindServiceAsUser方法来绑定服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

public void bindLocked() {
    ...
    try {
        ...
        if (mService == null &amp;amp;&amp;amp; mContext.bindServiceAsUser(
                mIntent, this, flags, new UserHandle(userState.mUserId))) {
            userState.getBindingServicesLocked().add(mComponentName);
        }
    } ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务启动后会跨进程调用到TalkbackService(AccessibilityService)的onBind方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.AccessibilityService

/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        ...
        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }
...
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;onBind方法返回的是一个IAccessibilityServiceClientWrapper的binder对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implements the internal {@link IAccessibilityServiceClient} interface to convert
 * incoming calls to it back to calls on an {@link AccessibilityService}.
 *
 * @hide
 */
public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
        implements HandlerCaller.Callback {
    ...

    private final HandlerCaller mCaller;

    private final Callbacks mCallback;

    private int mConnectionId = AccessibilityInteractionClient.NO_ID;

    public IAccessibilityServiceClientWrapper(Context context, Looper looper,
            Callbacks callback) {
        mCallback = callback;
        mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);
    }

    public void init(IAccessibilityServiceConnection connection, int connectionId,
            IBinder windowToken) {
        Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                connection, windowToken);
        mCaller.sendMessage(message);
    }

    ...

    public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {
        Message message = mCaller.obtainMessageBO(
                DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);
        mCaller.sendMessage(message);
    }
...

    @Override
    public void executeMessage(Message message) {
        switch (message.what) {
            case DO_ON_ACCESSIBILITY_EVENT: {
                AccessibilityEvent event = (AccessibilityEvent) message.obj;
                boolean serviceWantsEvent = message.arg1 != 0;
                if (event != null) {
                    // Send the event to AccessibilityCache via AccessibilityInteractionClient
                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);
                    if (serviceWantsEvent
                            &amp;amp;&amp;amp; (mConnectionId != AccessibilityInteractionClient.NO_ID)) {
                        // Send the event to AccessibilityService
                        mCallback.onAccessibilityEvent(event);
                    }
                    ...
                }
            } return;

            ...
            case DO_INIT: {
                mConnectionId = message.arg1;
                SomeArgs args = (SomeArgs) message.obj;
                IAccessibilityServiceConnection connection =
                        (IAccessibilityServiceConnection) args.arg1;
                IBinder windowToken = (IBinder) args.arg2;
                args.recycle();
                if (connection != null) {
                    AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                            connection);
                    mCallback.init(mConnectionId, windowToken);
                    mCallback.onServiceConnected();
                }...
            } return;
...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;IAccessibilityServiceClientWrapper中保存了一个HandlerCaller和Callbacks对象，其中HandlerCaller主要是将SystemServer进程中AccessibilityServiceConnection的binder call的binder线程调研切换到AccessibilityService的主线程调用。Callbacks对象则将IAccessibilityServiceClientWrapper中的调用回调到AccessibilityService中。&lt;/p&gt;
&lt;p&gt;AccessibilityService返回binder后会走到AccessibilityServiceConnection的onServiceConnected调用中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        ...
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        ...
        userState.addServiceLocked(this);
        mSystemSupport.onClientChange(false);
        // Initialize the service on the main handler after we&#39;re done setting up for
        // the new configuration (for example, initializing the input filter).
        mMainHandler.sendMessage(obtainMessage(
                AccessibilityServiceConnection::initializeService, this));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;private void initializeService() {
    IAccessibilityServiceClient serviceInterface = null;
    ...
    try {
        serviceInterface.init(this, mId, mOverlayWindowToken);
    } catch (RemoteException re) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在serviceInterface.init方法中（binder调用）将这个AccessibilityServiceConnection、mId和mOverlayWindowToken传给AccessibilityService完成初始化工作。&lt;/p&gt;
&lt;p&gt;初始化时会调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
        connection);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将AccessibilityServiceConnection保存到AccessibilityInteractionClient中。&lt;/p&gt;
&lt;h3 id=&#34;42无障碍模式下视图状态初始化流程&#34;&gt;4.2、无障碍模式下视图状态初始化流程。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/findAccessibilityNodeInfoByAccessibilityId.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;getaccessibilitynodeprovider&#34;&gt;getAccessibilityNodeProvider&lt;/h5&gt;
&lt;h5 id=&#34;oninitializeaccessibilitynodeinfo&#34;&gt;onInitializeAccessibilityNodeInfo&lt;/h5&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、talkback打开状态下，新的应用打开时，TalkbackService会接收到类型为TYPE_WINDOWS_CHANGED的无障碍事件，这个事件是SystemServer进程接收到其他进程发出的TYPE_VIEW_ACCESSIBILITY_FOCUSED事件时附带发出的，应用发出TYPE_VIEW_ACCESSIBILITY_FOCUSED事件的流程在下一节分析，暂时跳过。&lt;/p&gt;
&lt;p&gt;2、当tailback收到TYPE_WINDOWS_CHANGED事件时，会间接调用调用父类AccessibilityService的getRootInActiveWindow方法，如上图，经过SystemServer进程中转后会调用到DecorView的getAccessibilityNodeProvider，由于DecorView没有重写getAccessibilityNodeProvider方法，因此会调用到View的createAccessibilityNodeInfo方法，进一步会调用到&lt;strong&gt;onInitializeAccessibilityNodeInfo&lt;/strong&gt;方法，如果没有重写该方法，则默认实现在onInitializeAccessibilityNodeInfoInternal中。&lt;/p&gt;
&lt;p&gt;3、AccessibilityNodePrefetcher在取出DecorView的无障碍节点后，会进一步通过prefetchDescendantsOfRealNode方法取子view的无障碍节点。同理，如果我们重写了&lt;strong&gt;getAccessibilityNodeProvider&lt;/strong&gt;方法（一些特殊的自定义view需要自己重写该方法，比如webview，android.widget.NumberPicker等），重写getAccessibilityNodeProvider，需要我们实现一个AccessibilityNodeProvider的子类，来实现虚拟的view来支持无障碍模式。通常实现比较复杂的view时会重写这两个方法&lt;/p&gt;
&lt;h3 id=&#34;43无障碍事件分发流程重要app适配无障碍以及处理无障碍相关问题主要通过该流程入手&#34;&gt;4.3、无障碍事件分发流程（重要，app适配无障碍以及处理无障碍相关问题主要通过该流程入手）。&lt;/h3&gt;
&lt;p&gt;流程：被辅助app将无障碍事件发送给辅助app，systemserver进程作为中转，接口为IAccessibilityManager.aidl和IAccessibilityServiceClient.aidl&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/sendaccessibilityevent.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因-1&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法-1&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;sendaccessibilityevent&#34;&gt;&lt;strong&gt;sendAccessibilityEvent&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;sendAccessibilityEventUnchecked&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onInitializeAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dispatchPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onRequestSendAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于talkback的无障碍服务中声明了android:canRequestTouchExplorationMode=&amp;quot;true&amp;rdquo;，因此开启talkback后AccessibilityManagerService会更新AccessibilityInputFilter成员变量的触摸浏览（FLAG_FEATURE_TOUCH_EXPLORATION）的特性为true。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityInputFilter

private void enableFeatures() {
    ...
    if ((mEnabledFeatures &amp;amp; FLAG_FEATURE_TOUCH_EXPLORATION) != 0) {
        mTouchExplorer = new TouchExplorer(mContext, mAms);
        addFirstEventHandler(mTouchExplorer);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;触摸浏览特性开启后会创建一个TouchExplorer对象。AccessibilityInputFilter继承自InputFilter，对输入事件进行过滤，通过和TouchExplorer配合从而实现talkback模式下的触摸浏览手势。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * This class is a strategy for performing touch exploration. It
 * transforms the motion event stream by modifying, adding, replacing,
 * and consuming certain events. The interaction model is:
 *
 * &amp;lt;ol&amp;gt;
 *   &amp;lt;li&amp;gt;1. One finger moving slow around performs touch exploration.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;2. One finger moving fast around performs gestures.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;3. Two close fingers moving in the same direction perform a drag.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;4. Multi-finger gestures are delivered to view hierarchy.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;5. Two fingers moving in different directions are considered a multi-finger gesture.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;7. Double tapping clicks on the on the last touch explored location if it was in
 *          a window that does not take focus, otherwise the click is within the accessibility
 *          focused rectangle.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;7. Tapping and holding for a while performs a long press in a similar fashion
 *          as the click above.&amp;lt;/li&amp;gt;
 * &amp;lt;ol&amp;gt;
 *
 * @hide
 */
class TouchExplorer extends BaseEventStreamTransformation
        implements AccessibilityGestureDetector.Listener {
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该类负责将普通的触摸事件转换为触摸浏览手势，比如将MotionEvent.ACTION_DOWN事件转换为悬停事件）（MotionEvent.ACTION_HOVER_ENTER）。因此在talkback模式下，当我们点击一次view上的控件时，应用收到的是（ACTION_HOVER_ENTER）事件，而只有双击才会传递我们熟悉的ACTION_DOWN事件&lt;/p&gt;
&lt;p&gt;*ViewRootImpl:View层次结构的根。View的&lt;strong&gt;绘制流程&lt;/strong&gt;（测量measure、布局layout、绘制draw）和输入&lt;strong&gt;事件的分发流程&lt;/strong&gt;都是从ViewRootImp开始。&lt;/p&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、ViewRootImpl的内部类WindowInputEventReceiver从native方法调起dispatchInputEvent方法。&lt;/p&gt;
&lt;p&gt;2、ViewRootImpl调用deliverInputEvent传递事件输入事件。&lt;/p&gt;
&lt;p&gt;3、从顶层的DecorView的dispatchPointerEvent开始分发输入事件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View.java

/**
 * Dispatch a pointer event.
 * &amp;lt;p&amp;gt;
 * Dispatches touch related pointer events to {@link #onTouchEvent(MotionEvent)} and all
 * other events to {@link #onGenericMotionEvent(MotionEvent)}.  This separation of concerns
 * reinforces the invariant that {@link #onTouchEvent(MotionEvent)} is really about touches
 * and should not be expected to handle other pointing device features.
 * &amp;lt;/p&amp;gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 * @hide
 */
public final boolean dispatchPointerEvent(MotionEvent event) {
    if (event.isTouchEvent()) {
        return dispatchTouchEvent(event);
    } else {
        return dispatchGenericMotionEvent(event);
    }
}

...

/**
 * Returns true if this motion event is a touch event.
 * &amp;lt;p&amp;gt;
 * Specifically excludes pointer events with action {@link #ACTION_HOVER_MOVE},
 * {@link #ACTION_HOVER_ENTER}, {@link #ACTION_HOVER_EXIT}, or {@link #ACTION_SCROLL}
 * because they are not actually touch events (the pointer is not down).
 * &amp;lt;/p&amp;gt;
 * @return True if this motion event is a touch event.
 * @hide
 */
public final boolean isTouchEvent() {
    return nativeIsTouchEvent(mNativePtr);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在dispatchPointerEvent方法中会有event.isTouchEvent()的判断，如果talkback模式下，由于收到的是ACTION_HOVER_ENTER事件，因此不会走dispatchTouchEvent方法而是dispatchGenericMotionEvent方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View.java
/**
 * Dispatch a generic motion event.
 * &amp;lt;p&amp;gt;
 * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
 * are delivered to the view under the pointer.  All other generic motion events are
 * delivered to the focused view.  Hover events are handled specially and are delivered
 * to {@link #onHoverEvent(MotionEvent)}.
 * &amp;lt;/p&amp;gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
public boolean dispatchGenericMotionEvent(MotionEvent event) {
...
    final int source = event.getSource();
    if ((source &amp;amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
        final int action = event.getAction();
        if (action == MotionEvent.ACTION_HOVER_ENTER
                || action == MotionEvent.ACTION_HOVER_MOVE
                || action == MotionEvent.ACTION_HOVER_EXIT) {
            if (dispatchHoverEvent(event)) {
                return true;
            }
        } else if (dispatchGenericPointerEvent(event)) {
            return true;
        }
    } else if (dispatchGenericFocusedEvent(event)) {
        return true;
    }
	...
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在dispatchGenericMotionEvent中，如果是Hover events，则会走到dispatchHoverEvent方法中。这个方法的机制类似dispatchTouchEvent的流程，是一个责任链模式的实现，不详细展开，默认会传到最后一个子节点的onHoverEvent方法。接着该方法会调用到sendAccessibilityHoverEvent里。&lt;/p&gt;
&lt;p&gt;3、sendAccessibilityHoverEvent方法接着会调用以下方法。&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;sendAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​       &lt;strong&gt;-&amp;gt;sendAccessibilityEventUnchecked&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;onInitializeAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;dispatchPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​                &lt;strong&gt;-&amp;gt;onPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;onRequestSendAccessibilityEvent&lt;/strong&gt;（只在ViewGroup中有默认实现）&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;重要：以上六个方法为当我们自定义view时适配无障碍模式可以覆盖实现的方法，可以重写view的这些方法或者实现View.AccessibilityDelegate来解决一些特殊场景下talkback播报的问题。更详细的用法可以参考官方文档。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以talkback模式下朗读一个textview上的文字为例，textview重写了view中的onPopulateAccessibilityEventInternal方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.widget.TextView.java

/** @hide */
@Override
public void onPopulateAccessibilityEventInternal(AccessibilityEvent event) {
    super.onPopulateAccessibilityEventInternal(event);

    final CharSequence text = getTextForAccessibility();
    if (!TextUtils.isEmpty(text)) {
        event.getText().add(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getTextForAccessibility方法会取到当前textview中显示的text，然后将该text的内容填充到AccessibilityEvent中发送出去。后面talkback会取出这个text并朗读出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View

public void onPopulateAccessibilityEvent(AccessibilityEvent event) {
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.onPopulateAccessibilityEvent(this, event);
    } else {
        onPopulateAccessibilityEventInternal(event);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此如果我们需要自定义textview在talkback模式下朗读的内容，或者不让某个view的内容在talkback模式下被朗读出来，可以考虑重写onPopulateAccessibilityEvent方法。&lt;/p&gt;
&lt;p&gt;4、当我们通过第3步修改view中无障碍节点的信息后，被点击的View的sendAccessibilityEventUnchecked方法会向上通过DecorView传递到ViewRootImpl的requestSendAccessibilityEvent方法中，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl

public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {
    ...
    final int eventType = event.getEventType();
    switch (eventType) {
        case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED: {
            final long sourceNodeId = event.getSourceNodeId();
            final int accessibilityViewId = AccessibilityNodeInfo.getAccessibilityViewId(
                    sourceNodeId);
            View source = mView.findViewByAccessibilityId(accessibilityViewId);
            if (source != null) {
                AccessibilityNodeProvider provider = source.getAccessibilityNodeProvider();
                if (provider != null) {
                    final int virtualNodeId = AccessibilityNodeInfo.getVirtualDescendantId(
                            sourceNodeId);
                    final AccessibilityNodeInfo node;
                    node = provider.createAccessibilityNodeInfo(virtualNodeId);
                    setAccessibilityFocus(source, node);
                }
            }
        } break;
        ...
    }
    mAccessibilityManager.sendAccessibilityEvent(event);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着无障碍事件会通过AccessibilityManager的sendAccessibilityEvent方法跨进程调用systemserver进程的AccessibilityManagerService，将类型为TYPE_VIEW_HOVER_ENTER的AccessibilityEvent事件传递到talkback的的TalkBackService（继承自AccessibilityService）的onAccessibilityEvent方法中（或者其他实现了AccessibilityService的应用）。&lt;/p&gt;
&lt;h3 id=&#34;44执行无障碍事件流程以talkback发出focus无障碍事件到被辅助的app端通过viewrootimpl绘制绿框焦点过程进行分析&#34;&gt;4.4、执行无障碍事件流程（以talkback发出focus无障碍事件，到被辅助的app端通过ViewRootImpl绘制绿框焦点过程进行分析）。&lt;/h3&gt;
&lt;p&gt;流程：辅助app（talkback）将无障碍事件发送给被辅助app，systemserver进程作为中转，接口为IAccessibilityServiceConnection.aidl和IAccessibilityInteractionConnection.aidl&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/requesfocus.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因-2&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法-2&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;accessibilitynodeinfoperformaction&#34;&gt;AccessibilityNodeInfo.performAction&lt;/h5&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、在talkback中有个AccessibilityEventProcessor类对无障碍事件进行集中处理，根据无障碍事件的不同类型分发到不同的处理器进行处理，比如ProcessorFocusAndSingleTap这个处理器会对类型为TYPE_VIEW_HOVER_ENTER的无障碍事件进行处理，ProcessorEventQueue（主要用于tts朗读，后面分析）这个处理器会处理所有的无障碍事件。&lt;/p&gt;
&lt;p&gt;2、在前面一节4.2中，触摸事件TYPE_VIEW_HOVER_ENTER传递到了TalkBackService，而ProcessorFocusAndSingleTap这个类会对TYPE_VIEW_HOVER_ENTER这个事件进行处理，tryFocusing函数中会调用AccessibilityNodeInfo的performAction方法，AccessibilityNodeInfo的节点信息就是4.2节中触摸到的view的信息，因此通过AccessibilityManagerService进程中转后，会最终调用到我们触摸到的view的&lt;strong&gt;performAccessibilityAction&lt;/strong&gt;方法中去（我们也可以通过调用这个方法处理一些无障碍焦点的问题）。&lt;/p&gt;
&lt;p&gt;3、在performAccessibilityAction会调用到performAccessibilityActionInternal，接着如果判断到是ACTION_ACCESSIBILITY_FOCUS事件，则会调用requestAccessibilityFocus函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View

public boolean requestAccessibilityFocus() {
    ...
    if ((mPrivateFlags2 &amp;amp; PFLAG2_ACCESSIBILITY_FOCUSED) == 0) {
        mPrivateFlags2 |= PFLAG2_ACCESSIBILITY_FOCUSED;
        ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            viewRootImpl.setAccessibilityFocus(this, null);
        }
        invalidate();
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数里有两个重要的操作，一是调用ViewRootImpl的setAccessibilityFocus将自身设置为focus的view，然后调用invalidate触发重绘操作，ViewRootImpl会在onPostDraw中执行drawAccessibilityFocusedDrawableIfNeeded来绘制出绿框。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl.java

/**
 * We want to draw a highlight around the current accessibility focused.
 * Since adding a style for all possible view is not a viable option we
 * have this specialized drawing method.
 *
 * Note: We are doing this here to be able to draw the highlight for
 *       virtual views in addition to real ones.
 *
 * @param canvas The canvas on which to draw.
 */
private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas) {
    final Rect bounds = mAttachInfo.mTmpInvalRect;
    if (getAccessibilityFocusedRect(bounds)) {
        final Drawable drawable = getAccessibilityFocusedDrawable();
        if (drawable != null) {
            drawable.setBounds(bounds);
            drawable.draw(canvas);
        }
    } else if (mAttachInfo.mAccessibilityFocusDrawable != null) {
        mAttachInfo.mAccessibilityFocusDrawable.setBounds(0, 0, 0, 0);
    }
}

private boolean getAccessibilityFocusedRect(Rect bounds) {
    final AccessibilityManager manager = AccessibilityManager.getInstance(mView.mContext);
    if (!manager.isEnabled() || !manager.isTouchExplorationEnabled()) {
        return false;
    }

    final View host = mAccessibilityFocusedHost;
    if (host == null || host.mAttachInfo == null) {
        return false;
    }

    final AccessibilityNodeProvider provider = host.getAccessibilityNodeProvider();
    if (provider == null) {
        host.getBoundsOnScreen(bounds, true);
    } else if (mAccessibilityFocusedVirtualView != null) {
        mAccessibilityFocusedVirtualView.getBoundsInScreen(bounds);
    } else {
        return false;
    }

    // Transform the rect into window-relative coordinates.
    final AttachInfo attachInfo = mAttachInfo;
    bounds.offset(0, attachInfo.mViewRootImpl.mScrollY);
    bounds.offset(-attachInfo.mWindowLeft, -attachInfo.mWindowTop);
    if (!bounds.intersect(0, 0, attachInfo.mViewRootImpl.mWidth,
            attachInfo.mViewRootImpl.mHeight)) {
        // If no intersection, set bounds to empty.
        bounds.setEmpty();
    }
    return !bounds.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个操作是调用sendAccessibilityEvent方法，将TYPE_VIEW_ACCESSIBILITY_FOCUSED事件发送出去，这个事件会被talkback处理，从而调用tts引擎读出view的内容，这个流程分析如下。&lt;/p&gt;
&lt;h3 id=&#34;45talkback调用tts读出view中的text的过程&#34;&gt;4.5、talkback调用TTS读出view中的text的过程。&lt;/h3&gt;
&lt;p&gt;由于talkback最新版本属于google维护，没有开源代码，网上公开的只有talkback6.0版本的代码，因此基于6.0版本的概要分析如下&lt;/p&gt;
&lt;p&gt;无障碍事件的分发跟4.2节流程一样，talkback处理TYPE_VIEW_ACCESSIBILITY_FOCUSED事件大致流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/talkbacktts.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;talkback调用tts进行朗读主要通过com.google.android.accessibility.compositor.Compositor这个类来控制，这个类中又有一个ParseTree的类来管理朗读的内容，ParseTree通过一个compositor.json的文件来定义朗读的内容的规则，比如一个简单的按钮，在talkback模式下不仅需要读出按钮的内容，还需要读出按钮的状态（比如disabled），因此朗读的内容是一个拼接起来的结果，比如下面就是通过解析compositor.json来读出一个按钮内容的大概流程。&lt;/p&gt;
&lt;p&gt;以下在compositor.json中某几个节点类型的定义，&lt;/p&gt;
&lt;p&gt;$开头会被解析成ParseTreeVariableNode，比如 &amp;ldquo;node.text&amp;quot;经过ParseTreeVariableNode的处理会取出Button中text（也就是AccessibilityEvent中AccessibilityNodeInfo中的mText）&lt;/p&gt;
&lt;p&gt;@开头会被解析成ParseTreeResourceNode，最后会通过Resource取出字段的内容，比如&amp;rdquo;@string/value_button&amp;quot;中文下会被解析为“按钮”，&lt;/p&gt;
&lt;p&gt;&amp;ldquo;@string/value_disabled&amp;quot;中文下会被解析为“已停用”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     &amp;quot;notify_disabled&amp;quot;: {
      &amp;quot;if&amp;quot;: &amp;quot;$node.isActionable &amp;amp;&amp;amp; !$node.isEnabled&amp;quot;,
      &amp;quot;then&amp;quot;: &amp;quot;@string/value_disabled&amp;quot;
     },

....

     &amp;quot;get_node_text&amp;quot;: {  // AccessibilityNodeInfoUtils.getNodeText()
      &amp;quot;fallback&amp;quot;: [
        {
          // If focusing on-screen keyboard key... apply speak-passwords policy to hide key name.
          &amp;quot;if&amp;quot;: &amp;quot;$event.sourceIsKeyboard &amp;amp;&amp;amp; $global.lastTextEditIsPassword &amp;amp;&amp;amp; !$global.speakPasswordOnAndroidShowingPasswords&amp;quot;,
          &amp;quot;then&amp;quot;: &amp;quot;@string/symbol_bullet&amp;quot;,
          &amp;quot;else&amp;quot;: &amp;quot;$node.contentDescription&amp;quot;
        },
        &amp;quot;$node.text&amp;quot;
      ]
    },
    &amp;quot;get_role_description_or_default&amp;quot;: {
      &amp;quot;fallback&amp;quot;: [
        &amp;quot;$node.roleDescription&amp;quot;,
        &amp;quot;%node_role&amp;quot;
      ]
    },
    &amp;quot;node_role&amp;quot;: {
      &amp;quot;switch&amp;quot;: &amp;quot;$node.role&amp;quot;,
      &amp;quot;cases&amp;quot;: {
        &amp;quot;button&amp;quot;: &amp;quot;@string/value_button&amp;quot;,
        &amp;quot;check_box&amp;quot;: &amp;quot;@string/value_checkbox&amp;quot;,
        &amp;quot;drop_down_list&amp;quot;: &amp;quot;@string/value_spinner&amp;quot;,
        &amp;quot;edit_text&amp;quot;: &amp;quot;@string/value_edit_box&amp;quot;,
        &amp;quot;grid&amp;quot;: &amp;quot;@string/value_gridview&amp;quot;,
        &amp;quot;image&amp;quot;: &amp;quot;@string/value_image&amp;quot;,
        &amp;quot;image_button&amp;quot;: &amp;quot;@string/value_button&amp;quot;, // Same as |button|
        &amp;quot;list&amp;quot;: &amp;quot;@string/value_listview&amp;quot;,
        &amp;quot;pager&amp;quot;: &amp;quot;@string/value_pager&amp;quot;,
        &amp;quot;progress_bar&amp;quot;: &amp;quot;@string/value_progress_bar&amp;quot;,
        &amp;quot;radio_button&amp;quot;: &amp;quot;@string/value_radio_button&amp;quot;,
        &amp;quot;seek_control&amp;quot;: &amp;quot;@string/value_seek_bar&amp;quot;,
        &amp;quot;switch&amp;quot;: &amp;quot;@string/value_switch&amp;quot;,
        &amp;quot;tab_bar&amp;quot;: &amp;quot;@string/value_tabwidget&amp;quot;,
        &amp;quot;toggle_button&amp;quot;: &amp;quot;@string/value_switch&amp;quot;, // Same as |switch|
        &amp;quot;view_group&amp;quot;: &amp;quot;&amp;quot;, // None
        &amp;quot;web_view&amp;quot;: &amp;quot;@string/value_webview&amp;quot;,
        &amp;quot;checked_text_view&amp;quot;: &amp;quot;&amp;quot; // None
      }
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ttsOutput&lt;/p&gt;
&lt;p&gt;TYPE_VIEW_ACCESSIBILITY_FOCUSED&lt;/p&gt;
&lt;p&gt;get_description_for_tree&lt;/p&gt;
&lt;p&gt;​        StateNameRolePosition&lt;/p&gt;
&lt;p&gt;​              tree_description_with_label&lt;/p&gt;
&lt;p&gt;​                 append_description_for_tree&lt;/p&gt;
&lt;p&gt;​                 |  &amp;ldquo;conditionalPrepend(%description_for_tree_status, %description_for_tree_nodes)&amp;rdquo;&lt;/p&gt;
&lt;p&gt;​                 |      description_for_tree_nodes&lt;/p&gt;
&lt;p&gt;​                 |           get_description_for_node&lt;/p&gt;
&lt;p&gt;​                 |             rule_default&lt;/p&gt;
&lt;p&gt;​                 |                node_text_and_role&lt;/p&gt;
&lt;p&gt;​                 |                    rule_view_group（%get_node_text）&lt;/p&gt;
&lt;p&gt;​                 |                    |    &amp;ldquo;$node.text&amp;rdquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;取出“Button的text”&lt;/p&gt;
&lt;p&gt;​                 |                    get_role_description_or_default&lt;/p&gt;
&lt;p&gt;​                 |                    |     %node_role&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-取出“按钮的String资源”&lt;/p&gt;
&lt;p&gt;​                  notify_disabled&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-取出“已停用的String资源”&lt;/p&gt;
&lt;p&gt;最后talkback朗读“xxx，按钮，已停用”&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>preference体系学习总结</title>
      <link>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;1preference体系学习总结&#34;&gt;1.preference体系学习总结&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一部分主要学习了preference体系的相关知识（类图中蓝色和绿色部分）&lt;/p&gt;
&lt;h2 id=&#34;11-数据结构描述&#34;&gt;1.1 数据结构描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1.1&lt;/strong&gt; &lt;strong&gt;preference&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;设置的基石，简单来讲可以认为是设置列表中的每一个项目。&lt;/p&gt;
&lt;p&gt;其中有个重要的方法getView，这个方法返回的View将会被添加到PreferenceFragment或PreferenceActivity里&lt;/p&gt;
&lt;p&gt;作用：提供一个view给即将被展示的activity并且关联一个sharepreferences来保存或取出preference数据，其他常用的preference子类都继承于该类从而进行view样式的改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.2（v7包的Preference）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;去除了getView方法，增加了继承于RecycleView.ViewHolder的PreferenceViewHolder类&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.3&lt;/strong&gt; &lt;strong&gt;PreferenceGroup&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;继承于PreferenceGroup，内部维护了一个元素为Preference的List，和Preference的关系类似于View和ViewGroup一样，采用了组合模式进行组织。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.4（v7包的PreferenceGroup）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现类似，改动不大&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.5&lt;/strong&gt; &lt;strong&gt;PreferenceScreen&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;继承于PreferenceGroup，是一个界面的root节点。当一个PreferenceScreen嵌套在另一个PreferenceScreen内部时会以Dialog的形式开启一个新的界面进行显示。&lt;/p&gt;
&lt;p&gt;内部持有一个listView，一个listAdapter（PreferenceGroupAdapter），持有一个layout文件&amp;quot;com.android.internal.R.layout.preference_list_fragment&amp;quot;的id，还有一个Dialog，用于展示嵌套的preferenceScreen&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.6 （v7包的PreferenceScreen）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现对比解耦了关联的View体系的东西，更加简洁。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.7 PreferenceManager&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;管理类，用XmlPullParser遍历解析xml文件来创建preference。&lt;/p&gt;
&lt;p&gt;1.重要的属性&lt;/p&gt;
&lt;p&gt;activity，fragment，sharepreference，preferenceDataStore，preferenceScreen；&lt;/p&gt;
&lt;p&gt;关联了一个根布局“PreferenceScreen”，和SharedPreference进行交互。&lt;/p&gt;
&lt;p&gt;2.重要的方法&lt;/p&gt;
&lt;p&gt;inflateFromResource：通过PreferenceInflater（继承于GenericInflater）递归地扫描xml文件取出所有节点信息来构建出PreferenceScreen对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.8 （v14包的PreferenceManager）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加了一些接口OnDisplayPreferenceDialogListener、OnNavigateToScreenListener&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.9 PreferenceFragment：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于显示preference对象列表&lt;/p&gt;
&lt;p&gt;持有一个listView，最终会关联到PreferenceScreen的listView，实现了onPreferenceTreeClick接口，这个接口会在ListView的项被点击时回调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.10（v14包的PreferenceFragment）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现相比改动较大。主要是采用了RecyclerView并且实现了一些Dialog的接口。&lt;/p&gt;
&lt;p&gt;关联了recycleView和preferenceManager&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.11 PreferenceActivity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承于ListActivity，重要的内部类&lt;/p&gt;
&lt;p&gt;Header：&lt;/p&gt;
&lt;p&gt;Header包含的属性：&lt;/p&gt;
&lt;p&gt;1.title； 2.summary；3.icon；4.fragment；5.intent；6.bundle；&lt;/p&gt;
&lt;p&gt;HeaderAdapter&lt;/p&gt;
&lt;p&gt;HeaderAdapter包含的属性：1.icon；2.title；3.summary&lt;/p&gt;
&lt;p&gt;从这个adapter和layout布局(preference_header_item.xml)可以看出一个header只有这三项。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;12-preferencefragment加载xml源码分析旧&#34;&gt;1.2 PreferenceFragment加载xml源码分析（旧）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/fragmentaddxml.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;重要流程说明：&lt;/p&gt;
&lt;p&gt;第8步：PreferenceInflater是一个xml解析器，通过解析xml取出节点，然后反射生成PreferenceScreen对象&lt;/p&gt;
&lt;h2 id=&#34;13--preferencefragment点击事件触发流程旧&#34;&gt;1.3  PreferenceFragment点击事件触发流程（旧）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            Preference的performClick
                PreferenceManager.OnPreferenceTreeClickListener的onPreferenceTreeClick
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-preferenceactivity加载xml源码分析&#34;&gt;1.4 PreferenceActivity加载xml源码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceactivityaddxml.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;重要流程说明：&lt;/p&gt;
&lt;p&gt;第4步：生成Header的方式也是通过xml解析器解析xml的header节点然后反射生成Header对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;无论是新的loadHeadersFromResource还是旧的addPreferencesFromResource，底层解析xml都用的XmlPullParser类。&lt;/p&gt;
&lt;h2 id=&#34;15-preferenceactivity点击事件触发流程&#34;&gt;1.5. PreferenceActivity点击事件触发流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp	
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            ListActivity里的onListItemClick
                PreferenceAcitvity里的onHeaderClick
                    然后根据fragment是否为空来执行switchToHeader或者startActivity
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2aosp中setting模块学习总结&#34;&gt;2.aosp中Setting模块学习总结&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要分析只在系统Settings中使用的部分（除去上面分析过的蓝色和绿色部分）&lt;/p&gt;
&lt;h4 id=&#34;21-settings主页面的显示分析&#34;&gt;2.1 Settings主页面的显示分析：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsettings.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;aosp中P版本设置界面如上图所示，除去没显示的，主界面中一共展示了12个列表项，先分析列表项，后面再分析搜索和suggestion项。&lt;/p&gt;
&lt;p&gt;主Activity为Settings，继承于SettingsActivity，内部包含一个DashboardSummary的Fragment，从类图上看出DashboardSummary并没有用到preference的那一套东西。布局也相对简单，只有一个FocusRecyclerView，页面的布局由DashboardAdapter负责，DashboardAdapter用到的所有数据由DashboardData进行描述。这里只分析DashboardData中的DashboardCategory，也就是12个列表项所属的DashboardCategory，对于设置主界面来说只有一个DashboardCategory，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta-data android:name=&amp;quot;com.android.settings.category&amp;quot;
    android:value=&amp;quot;com.android.settings.category.ia.homepage&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从android manifest中也可以看到12个这样的数据，代表主界面的12个列表项。&lt;/p&gt;
&lt;p&gt;从类图中可以看出一个列表项由&lt;strong&gt;Tile&lt;/strong&gt;这样一个数据结构进行描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Tile implements Parcelable {
    public CharSequence title;
    public CharSequence summary;
    public Icon icon;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;DashboardCategory&lt;/strong&gt;表示一个类别，持有一个元素为Tile的List表；&lt;/p&gt;
&lt;p&gt;可以发现Dashboard和Preference有很多相似的地方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Base fragment for dashboard style UI containing a list of static and dynamic setting items.
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从注释可以看出DashboardFragment是为了动态加载而设计的，相对于Preference是静态地从xml文件中解析读取的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CategoryManager&lt;/strong&gt;主要是对DashboardCategory进行管理，内部会借助于&lt;strong&gt;TileUtils&lt;/strong&gt;来生成DashboardCategory对象，在生成DashboardCategory对象时会借助PackageManager来查询手机中的安装包信息来进行分析，来动态决定是否展示一些项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DashboardFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;DashboardFeatureProvider&lt;/strong&gt;接口，持有CategoryManager对象，通过CategoryManager对象进行Category的获取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SuggestionFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;SuggestionFeatureProvider&lt;/strong&gt;接口，应该是用于获取推荐信息，后面再分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FeatureFactoryImpl&lt;/strong&gt;实现了&lt;strong&gt;FeatureFactory&lt;/strong&gt;接口，通过反射生成，用于生成DashboardFeatureProviderImpl和SuggestionFeatureProviderImpl等一些FeatureProvider对象。&lt;/p&gt;
&lt;p&gt;整个设置主界面加载流程大致如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/dashboardsummary.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中绿色为主线程，其他线程为后台线程。&lt;/p&gt;
&lt;p&gt;对于流程做个简单的分析。&lt;/p&gt;
&lt;h5 id=&#34;1-settingsactivity的oncreate流程&#34;&gt;1. SettingsActivity的onCreate流程&lt;/h5&gt;
&lt;p&gt;在这个过程中会进行FeatureFactory、DashboardFeatureProvider、CategoryManager的初始化，并且如果判断是主界面，则启动DashboardSummary这个Fragment。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.1 DashboardSummary在onAttach中会创建SuggestionFeatureProvider，使之来进行推荐功能的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1.2 DashboardSummary在onCreate中会成创建DashboardFeatureProvider，以及新建一个SummaryLoader，用&amp;quot;om.android.settings.category.ia.homepage&amp;quot;来作为CategoryKey，SummaryLoader构造时会启动一个HandlerThread来在后台运行，以便随时接受主线程发过来的消息从而触发SummaryProvider的setListening方法进行Summary的更新，比如更新存储空间或者电量的百分比，或者根据不同的手机特性显示不同的Summary，比如在安全设置Fragment中对于支持指纹的手机显示&amp;quot;屏幕锁定、指纹&amp;rdquo;，不支持指纹的手机仅显示&amp;quot;屏幕锁定&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1.3  DashboardSummary在onCreateView中会进行view相关的处理，rootview为R.layout.dashboard，这个view中只有一个简单的RecycleView，创建DashboardAdapter，执行rebuildUI方法，该方法启动一个后台线程调用updateCategory来进行Category的更新，更新完毕通过notifyDashboardDataChanged通知主线程进行view的更新，如果需要加载推荐项，推荐项没加载，则向主线程发送一个延迟更新view的消息，通过Handler的postDelayed方法实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-settingsactivity的onresume流程&#34;&gt;2. SettingsActivity的onResume流程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2.1 这个方法首先会在父类SettingsDrawerActivity的onResume中执行CategoriesUpdateTask，来在后台更新所有的Categories，调用完毕后回主线程调用CategoryListener接口的onCategoriesChanged方法，DashboardFrament和DashboardSummary实现了该接口来进行Category的刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.2 SettingsAcitvity在重写onResume后再次向AsyncTask中post一个doUpdateTilesList的方法，这个方法会排在CategoriesUpdateTask之后执行，也是用来更新Categories的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.3 在DashboardSummary的onResume中，会调用SummaryLoader的setListening方法，这个方法会向HandlerThread中post消息，分析这个消息类型MSG_GET_CATEGORY_TILES_AND_SET_LISTENING，对应时序图的47步，在后台线程获取到category后，遍历所有的tile，调用makeProviderW方法，因为所有该category下的Fragment都实现了SummaryProvider以及SummaryLoader.SummaryProviderFactory，SummaryProvider实现了SummaryLoader.SummaryProvider接口，因此通过tile找到相关的factory后，再通过反射生成SummaryProvider对象，如时序图的52步。紧接着在setListeningW中遍历调用所有的SummaryProvider的setListening方法，这个方法进一步触发SummaryLoader的setSummary方法来进行各个列表项summary的动态变化，比如电量的更新等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setSummary(SummaryProvider provider, final CharSequence summary) {
    final ComponentName component = mSummaryProviderMap.get(provider);
    ThreadUtils.postOnMainThread(() -&amp;gt; {
  
        final Tile tile = getTileFromCategory(
                mDashboardFeatureProvider.getTilesForCategory(mCategoryKey), component);
  
        if (tile == null) {
            if (DEBUG) {
                Log.d(TAG, &amp;quot;Can&#39;t find tile for &amp;quot; + component);
            }
            return;
        }
        if (DEBUG) {
            Log.d(TAG, &amp;quot;setSummary &amp;quot; + tile.title + &amp;quot; - &amp;quot; + summary);
        }
  
        updateSummaryIfNeeded(tile, summary);
    });
}
  
@VisibleForTesting
void updateSummaryIfNeeded(Tile tile, CharSequence summary) {
    if (TextUtils.equals(tile.summary, summary)) {
        if (DEBUG) {
            Log.d(TAG, &amp;quot;Summary doesn&#39;t change, skipping summary update for &amp;quot; + tile.title);
        }
        return;
    }
    mSummaryTextMap.put(mDashboardFeatureProvider.getDashboardKeyForTile(tile), summary);
    tile.summary = summary;
    if (mSummaryConsumer != null) {
        mSummaryConsumer.notifySummaryChanged(tile);
    } else {
        if (DEBUG) {
            Log.d(TAG, &amp;quot;SummaryConsumer is null, skipping summary update for &amp;quot;
                    + tile.title);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在SummaryLoader的setSummary方法中再通过SummaryConsumer接口的notifySummaryChanged方法进行界面的更新，对于主界面来说是DashboardAdapter实现了SummaryConsumer接口，会直接触发notifyItemChanged来进行view的更新（对于其他DashboardFragment的子类来说则是父类DashboardFragment实现了SummaryConsumer接口，会触发Preference的setSummary方法，这个方法会调用notifyChanged方法，进而触发OnPreferenceChangeInternalListener的onPreferenceChange方法，而PreferenceGroupAdapter实现了该接口，因而也会触发notifyItemChanged来进行view的更新）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-securitysettings页面的显示流程分析&#34;&gt;2.2 SecuritySettings页面的显示流程分析：&lt;/h3&gt;
&lt;p&gt;Settings主界面的显示完全是动态的，而除去主界面其他的Fragment的显示则是动态和静态相结合，以要分析的SecuritySettings来说明。SecuritySettings的继承于DashboardFragment，而DashboardFragment主要就是用来加载动态和静态的item。DashboardFragment最终继承于PreferenceFragment，因此可以解析xml中配置的preference来进行显示，而且持有DashboardFeatureProviderImpl对象，因此也可以加载DashboardCategory中的Tile进行显示。&lt;/p&gt;
&lt;p&gt;SecuritySettings界面显示是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/securitysettings.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;layout文件R.xml.security_dashboard_settings如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PreferenceScreen
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:settings=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    android:key=&amp;quot;security_dashboard_page&amp;quot;
    android:title=&amp;quot;@string/security_settings_title&amp;quot;
    settings:initialExpandedChildrenCount=&amp;quot;9&amp;quot;&amp;gt;

    &amp;lt;!-- security_settings_status.xml --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;-10&amp;quot;
        android:key=&amp;quot;security_status&amp;quot;
        android:title=&amp;quot;@string/security_status_title&amp;quot; /&amp;gt;

    &amp;lt;PreferenceCategory
        android:order=&amp;quot;1&amp;quot;
        android:key=&amp;quot;dashboard_tile_placeholder&amp;quot; /&amp;gt;

    &amp;lt;!-- security section --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;10&amp;quot;
        android:key=&amp;quot;security_category&amp;quot;
        android:title=&amp;quot;@string/lock_settings_title&amp;quot;&amp;gt;  &amp;lt;!-- 设备安全性--&amp;gt;

        &amp;lt;com.android.settings.widget.GearPreference
            android:key=&amp;quot;unlock_set_or_change&amp;quot;
            android:title=&amp;quot;@string/unlock_set_unlock_launch_picker_title&amp;quot;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_lockscreen&amp;quot; /&amp;gt; &amp;lt;!-- 屏幕锁定--&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;lockscreen_preferences&amp;quot;
            android:title=&amp;quot;@string/lockscreen_settings_title&amp;quot; &amp;lt;!-- 锁屏时的偏好设置--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            android:fragment=&amp;quot;com.android.settings.security.LockscreenDashboardFragment&amp;quot; /&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;fingerprint_settings&amp;quot;
            android:title=&amp;quot;@string/security_settings_fingerprint_preference_title&amp;quot; &amp;lt;!-- 指纹--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_fingerprint_settings&amp;quot;/&amp;gt;

    &amp;lt;/PreferenceCategory&amp;gt;
....

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码里会解析这个xml文件来构造PreferenceScreen对象。&lt;/p&gt;
&lt;p&gt;从图里看到并没有显示锁屏时的偏好设置这一个Preference的条目，从源码分析是LockScreenPreferenceController这个类动态的改变了这一个Preference的显示状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Override
    public int getAvailabilityStatus() {
        if (!mLockPatternUtils.isSecure(MY_USER_ID)) {
            return mLockPatternUtils.isLockScreenDisabled(MY_USER_ID)
                    ? DISABLED_FOR_USER : AVAILABLE;
        } else {
            return mLockPatternUtils.getKeyguardStoredPasswordQuality(MY_USER_ID)
                    == PASSWORD_QUALITY_UNSPECIFIED
                    ? DISABLED_FOR_USER : AVAILABLE;
        }
    }

    @Override
    public void updateState(Preference preference) {
        preference.setSummary(
                LockScreenNotificationPreferenceController.getSummaryResource(mContext));
    }

    @Override
    public void onResume() {
        mPreference.setVisible(isAvailable());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这三个item其实是通过动态从DashboardTiles中取出来的。下面简单分析SecuritySettings的显示过程，主要是DashboardFragment的流程分析。&lt;/p&gt;
&lt;h4 id=&#34;221dashboardfragmenet的onattach流程&#34;&gt;2.2.1.DashboardFragmenet的onAttach流程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mDashboardFeatureProvider = FeatureFactory.getFactory(context).
            getDashboardFeatureProvider(context);
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
    // Load preference controllers from code
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllersFromCode =
            createPreferenceControllers(context);
    // Load preference controllers from xml definition
    final List&amp;lt;BasePreferenceController&amp;gt; controllersFromXml = PreferenceControllerListHelper
            .getPreferenceControllersFromXml(context, getPreferenceScreenResId());
    // Filter xml-based controllers in case a similar controller is created from code already.
    final List&amp;lt;BasePreferenceController&amp;gt; uniqueControllerFromXml =
            PreferenceControllerListHelper.filterControllers(
                    controllersFromXml, controllersFromCode);

    // Add unique controllers to list.
    if (controllersFromCode != null) {
        controllers.addAll(controllersFromCode);
    }
    controllers.addAll(uniqueControllerFromXml);
...

    mPlaceholderPreferenceController =
            new DashboardTilePlaceholderPreferenceController(context);
    controllers.add(mPlaceholderPreferenceController);
    for (AbstractPreferenceController controller : controllers) {
        addPreferenceController(controller);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法里主要是一些controllers的创建，这些controller可以从代码创建，也可以从xml解析获取，&lt;/p&gt;
&lt;p&gt;在SecuritySettings里通过代码创建了一些controller，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private static List&amp;lt;AbstractPreferenceController&amp;gt; buildPreferenceControllers(Context context,
            Lifecycle lifecycle, SecuritySettings host) {
        final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
        controllers.add(new LocationPreferenceController(context, lifecycle));
        controllers.add(new ManageDeviceAdminPreferenceController(context));
        controllers.add(new EnterprisePrivacyPreferenceController(context));
        controllers.add(new ManageTrustAgentsPreferenceController(context));
        ...

        return controllers;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在xml中是通过声明settings:controller属性来创建的，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;SwitchPreference
    android:key=&amp;quot;visiblepattern_profile&amp;quot;
    android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
    android:title=&amp;quot;@string/lockpattern_settings_enable_visible_pattern_title_profile&amp;quot;
    settings:controller=&amp;quot;com.android.settings.security.VisiblePatternProfilePreferenceController&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;221dashboardfragmenet的oncreate流程&#34;&gt;2.2.1.DashboardFragmenet的onCreate流程&lt;/h4&gt;
&lt;p&gt;DashboardFragmenet最终继承于v14包里的PreferenceFragment的onCreate方法，里面会调用onCreatePreferences方法，DashboardFragmenet重写了onCreatePreferences方法，进而调用refreshAllPreferences方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Refresh all preference items, including both static prefs from xml, and dynamic items from
 * DashboardCategory.
 */
private void refreshAllPreferences(final String TAG) {
    // First remove old preferences.
    if (getPreferenceScreen() != null) {
        // Intentionally do not cache PreferenceScreen because it will be recreated later.
        getPreferenceScreen().removeAll();
    }

    // Add resource based tiles.
    displayResourceTiles();

    refreshDashboardTiles(TAG);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从注释可以看出这个方法是这个Fragment显示流程的核心。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Displays resource based tiles.
 */
private void displayResourceTiles() {
    final int resId = getPreferenceScreenResId();
    if (resId &amp;lt;= 0) {
        return;
    }
    addPreferencesFromResource(resId);
    final PreferenceScreen screen = getPreferenceScreen();
    mPreferenceControllers.values().stream().flatMap(Collection::stream).forEach(
            controller -&amp;gt; controller.displayPreference(screen));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;displayResourceTiles这个方法首先获取了PreferenceScreen，然后通过循环调用了每个controller的displayPreference方法&lt;/p&gt;
&lt;p&gt;以上面说的LockScreenPreferenceController为例，LockScreenPreferenceController继承于BasePreferenceController，因此会调用如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Displays preference in this controller.
 */
@Override
public void displayPreference(PreferenceScreen screen) {
    super.displayPreference(screen);
    if (getAvailabilityStatus() == DISABLED_DEPENDENT_SETTING) {
        // Disable preference if it depends on another setting.
        final Preference preference = screen.findPreference(getPreferenceKey());
        if (preference != null) {
            preference.setEnabled(false);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从而来决定一个preference是否该显示。&lt;/p&gt;
&lt;p&gt;执行完displayResourceTiles后接着会执行refreshDashboardTiles方法，从注释也可以看出这个方法是用来展示动态DashboardCategory的item的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Refresh preference items backed by DashboardCategory.
 */
@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
void refreshDashboardTiles(final String TAG) {
    final PreferenceScreen screen = getPreferenceScreen();

    final DashboardCategory category =
            mDashboardFeatureProvider.getTilesForCategory(getCategoryKey());
    ...
    final List&amp;lt;Tile&amp;gt; tiles = category.getTiles();
    ...
    mSummaryLoader = new SummaryLoader(getActivity(), getCategoryKey());
    mSummaryLoader.setSummaryConsumer(this);
    ...
    // Install dashboard tiles.
    for (Tile tile : tiles) {
        final String key = mDashboardFeatureProvider.getDashboardKeyForTile(tile);
        ...
        if (mDashboardTilePrefKeys.contains(key)) {
            // Have the key already, will rebind.
            ....
        } else {
            // Don&#39;t have this key, add it.
            final Preference pref = new Preference(getPrefContext());
            mDashboardFeatureProvider.bindPreferenceToTile(getActivity(), getMetricsCategory(),
                    pref, tile, key, mPlaceholderPreferenceController.getOrder());
            screen.addPreference(pref);
            mDashboardTilePrefKeys.add(key);
        }
        remove.remove(key);
    }
    ...
    mSummaryLoader.setListening(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5-11行取出相关key的tile对象。对于SecuritySettings来说key是&amp;quot;com.android.settings.category.ia.security&amp;rdquo;，三个tile的title为“Google Play 保护机制、查找我的设备、安全更新”，如前面一节所介绍的，这三项是从gms服务中取出的，并不是Settings app本身内置的，因此可以看作是动态加载。&lt;/p&gt;
&lt;p&gt;13行创建了一个SummaryLoader对象，从之前的分析可知，会创建一个HandlerThread置于后台运行。&lt;/p&gt;
&lt;p&gt;14行把自己设置为SummaryConsumer接口对象，当SummaryLoader后台更新完，会调用setListeningW，这个方法又会取出所有满足要求的SummaryProvider去执行setListening方法，SummaryProvider又会反过来调用SummaryLoader的setSummary方法，SummaryLoader这时会post一个updateSummaryIfNeeded方法到主线程执行，而这个方法会取出mSummaryConsumer也就是DashboardFragment去执行notifySummaryChanged方法，这个方法会获取tile关联的preference，执行其setSummary方法，这个方法又会调用notifyChanged方法，这个方法调用OnPreferenceChangeInternalListener接口的onPreferenceChange方法，而PreferenceGroupAdapter实现了这个接口，因此最终通过PreferenceGroupAdapter实现了view中Summary的更新。&lt;/p&gt;
&lt;p&gt;25-29行创建Preference对象，并且将Preference和Tile进行绑定，然后添加到PreferenceScreen中。&lt;/p&gt;
&lt;p&gt;34行调用SummaryLoader的setListening方法，从前面一节分析可知，这个操作会往后台HandlerThread发送一个消息，从而在后台监听Summary是否有更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private SummaryProvider getSummaryProvider(Tile tile) {
    if (!mActivity.getPackageName().equals(tile.intent.getComponent().getPackageName())) {
        // Not within Settings, can&#39;t load Summary directly.
        // TODO: Load summary indirectly.
        return null;
    }
    ...
    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SummaryLoader的getSummaryProvider方法第二行中当前包名为com.android.settings，而tile的包名为com.google.android.gms，因此返回空，从注释也可以看出，如果当前的tile不在Settings应用中，是不能获取到SummaryProvider的。因此后面的通知Adapter进行Summary的刷新操作也就不会执行了，&lt;/p&gt;
&lt;h1 id=&#34;3aosp-80-settingssearch分析&#34;&gt;3.aosp 8.0 SettingsSearch分析&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsettingsdatabase.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31搜索的数据源&#34;&gt;3.1搜索的数据源&lt;/h2&gt;
&lt;p&gt;SearchIndexableData:用于搜索的可索引数据&lt;/p&gt;
&lt;p&gt;SearchIndexableResource：xml资源&lt;/p&gt;
&lt;p&gt;SearchIndexableRaw：原始数据&lt;/p&gt;
&lt;p&gt;BaseColumns：基类，rank排名，className类名，iconResId等；&lt;/p&gt;
&lt;p&gt;XmlResource：xml的资源id，关联SearchIndexableResource&lt;/p&gt;
&lt;p&gt;RawData：原始数据，title标题，summary概要等；关联SearchIndexableData&lt;/p&gt;
&lt;p&gt;NonIndexableKey：描述一个不能被索引的数据&lt;/p&gt;
&lt;p&gt;SearchIndexablesProvider：用于搜索的可索引provider的基类，用于给搜索提供preference的xml文件数据或者原始数据。&lt;/p&gt;
&lt;p&gt;以上的类除了SearchIndexableRaw外其他都位于framework包中；&lt;/p&gt;
&lt;p&gt;以下的类或接口位于settings中；&lt;/p&gt;
&lt;p&gt;Indexable.SearchIndexProvider：接口，其实现类的实例可以提供可索引的数据&lt;/p&gt;
&lt;p&gt;SettingsSearchIndexablesProvider：设置app中的content provider，实现了SearchIndexablesPrevider的相关搜索方法，在phone的app中也有一个类似的实现:PhoneSearchIndexablesProvider，从而可以在设置的搜索中找到Phone中的xml数据进行跳转&lt;/p&gt;
&lt;p&gt;BaseSearchIndexProvider：&lt;/p&gt;
&lt;p&gt;IndexDatabaseHelper：提供数据库的操作，数据库文件位于data/user_de/0/com.android.settings/databases/search_index.db&lt;/p&gt;
&lt;h2 id=&#34;32数据库构建过程&#34;&gt;3.2数据库构建过程&lt;/h2&gt;
&lt;p&gt;设置中的界面大部分都是通过xml文件中声明的Preference类的各种子类构建而成，页面打开时通过解析xml文件中的各个节点从而构建成listview中的各个item从而进行显示，以日期和时间页面DateTimeSettings为例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/datatimephone.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;构成这个界面的文件date_time_prefs.xml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;

&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
        xmlns:settings=&amp;quot;http://schemas.android.com/apk/res/com.android.settings&amp;quot;
        android:title=&amp;quot;@string/date_and_time&amp;quot; 
        settings:keywords=&amp;quot;@string/keywords_date_and_time&amp;quot;&amp;gt;

    &amp;lt;com.android.settingslib.RestrictedSwitchPreference android:key=&amp;quot;auto_time&amp;quot;
        android:title=&amp;quot;@string/date_time_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/date_time_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/date_time_auto_summaryOff&amp;quot;
        settings:useAdditionalSummary=&amp;quot;true&amp;quot;
        settings:restrictedSwitchSummary=&amp;quot;@string/enabled_by_admin&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;auto_zone&amp;quot;
        android:title=&amp;quot;@string/zone_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/zone_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/zone_auto_summaryOff&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;date&amp;quot;
        android:title=&amp;quot;@string/date_time_set_date&amp;quot;
        android:summary=&amp;quot;03/10/2008&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;time&amp;quot;
        android:title=&amp;quot;@string/date_time_set_time&amp;quot;
        android:summary=&amp;quot;12:00am&amp;quot;
        /&amp;gt;

    &amp;lt;Preference
        android:fragment=&amp;quot;com.android.settings.datetime.ZonePicker&amp;quot;
        android:key=&amp;quot;timezone&amp;quot;
        android:title=&amp;quot;@string/date_time_set_timezone&amp;quot;
        android:summary=&amp;quot;GMT-8:00&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;24 hour&amp;quot;
        android:title=&amp;quot;@string/date_time_24hour&amp;quot;
        /&amp;gt;

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述的xml文件的每一项跟界面展示是一一对应的，实际情况也可能不一样，可以通过配置一些属性或者代码动态增删一些项。&lt;/p&gt;
&lt;p&gt;title为显示的标题，summary为摘要，keywords为关键词（不直接显示，用于搜索），留意上面的settings:keywords=&amp;rdquo;@string/keywords_date_and_time&amp;quot;中keywords_date_and_time的值为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string name=&amp;quot;keywords_date_and_time&amp;quot; msgid=&amp;quot;758325881602648204&amp;quot;&amp;gt;&amp;quot;时钟, 军用&amp;quot;&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面写的是界面跟xml的关系，搜索过程是一个数据库的检索过程，因此搜索需要用到数据库，数据库数据的来源就是上面的xml文件，从模拟器取出search_index.db数据库观察，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/seachdb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见xml的数据跟数据库中的记录也是一一对应的，因此搜索过程就是数据库的检索过程，输入搜索的字符串最终会转换成SQL数据库查询语句从而返回查询结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/searchdemo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之所以搜索军用能出现日期和时间的结果，是因为“军用”是keyword的一部分&lt;/p&gt;
&lt;p&gt;设置中也能搜索其他app的数据，只要其实现了SearchIndexablesProvider，以phone的app为例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PhoneSearchIndexablesProvider extends SearchIndexablesProvider {
    private static final String TAG = &amp;quot;PhoneSearchIndexablesProvider&amp;quot;;

    private static SearchIndexableResource[] INDEXABLE_RES = new SearchIndexableResource[] {
            new SearchIndexableResource(1, R.xml.network_setting_fragment,
                    MobileNetworkSettings.class.getName(),
                    R.mipmap.ic_launcher_phone),
    };

    ...

    @Override
    public Cursor queryXmlResources(String[] projection) {
        ....
    }
   ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样实现后（还需要在AndroidManifest里面做些配置），设置app就能跨进程取到network_setting_fragment.xml中的数据并加入search_index.db数据库，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/phonedb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面简单分析下数据库的创建过程：&lt;/p&gt;
&lt;p&gt;刚进入设置创建数据库流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsearchcreatedb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当点击搜索按钮后会启动SearchFragment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mSearchFeatureProvider = FeatureFactory.getFactory(context).getSearchFeatureProvider();
    mMetricsFeatureProvider = FeatureFactory.getFactory(context).getMetricsFeatureProvider();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先会创建mSearchFeatureProvider，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);

    final LoaderManager loaderManager = getLoaderManager();
    mSearchAdapter = new SearchResultsAdapter(this);
    mSavedQueryController = new SavedQueryController(
            getContext(), loaderManager, mSearchAdapter);
    mSearchFeatureProvider.initFeedbackButton();

    ...
    
    // Run the Index update only if we have some space
    if (!Utils.isLowStorage(activity)) {
        mSearchFeatureProvider.updateIndex(activity, this /* indexingCallback */);
    } else {
        Log.w(TAG, &amp;quot;Cannot update the Indexer as we are running low on storage space!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在onCreate中会执行索引过程，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void updateIndex(Context context, IndexingCallback callback) {
    long indexStartTime = System.currentTimeMillis();
    getIndexingManager(context).indexDatabase(callback);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着会执行IndexManager的indexDatabase方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void indexDatabase(IndexingCallback callback) {
    IndexingTask task = new IndexingTask(callback);
    task.execute();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启了一个台任务，IndexingTask是一个AsyncTask，后台执行performIndexing方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected Void doInBackground(Void... voids) {
    performIndexing();
    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * Accumulate all data and non-indexable keys from each of the content-providers.
 * Only the first indexing for the default language gets static search results - subsequent
 * calls will only gather non-indexable keys.
 */
@VisibleForTesting
void performIndexing() {
    final Intent intent = new Intent(SearchIndexablesContract.PROVIDER_INTERFACE);
    // 这里是返回手机中所有声明了action为&amp;quot;android.content.action.SEARCH_INDEXABLES_PROVIDER&amp;quot;的provider的信息，暂时只有三个应用做了这个声明，Settings，Phone和cellbroadcastreceiver，因此Settings的搜索中可以搜索到phone的app中的信息从而进行跳转。
    final List&amp;lt;ResolveInfo&amp;gt; list =
            mContext.getPackageManager().queryIntentContentProviders(intent, 0);

    String localeStr = Locale.getDefault().toString();
    String fingerprint = Build.FINGERPRINT;
    final boolean isFullIndex = isFullIndex(localeStr, fingerprint);

    if (isFullIndex) {
        rebuildDatabase();
    }

    for (final ResolveInfo info : list) {
        if (!DatabaseIndexingUtils.isWellKnownProvider(info, mContext)) {
            continue;
        }
        final String authority = info.providerInfo.authority;
        final String packageName = info.providerInfo.packageName;

        if (isFullIndex) {
        	加载外部app的索引
            addIndexablesFromRemoteProvider(packageName, authority);
        }
        addNonIndexablesKeysFromRemoteProvider(packageName, authority);
    }
	// 更新到数据库
    updateDatabase(isFullIndex, localeStr);
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;33数据搜索以及显示过程&#34;&gt;3.3数据搜索以及显示过程&lt;/h1&gt;
&lt;p&gt;在搜索框输入字符后，会回调到SearchFragment的onQueryTextChange方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean onQueryTextChange(String query) {
    ...
    if (isEmptyQuery) {
        ...
    } else {
        restartLoaders();
    }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个搜索过程涉及到了Loader机制，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; onCreateLoader(int id, Bundle args) {
    final Activity activity = getActivity();

    switch (id) {
        case LOADER_ID_DATABASE:
            return mSearchFeatureProvider.getDatabaseSearchLoader(activity, mQuery);
        case LOADER_ID_INSTALLED_APPS:
            return mSearchFeatureProvider.getInstalledAppSearchLoader(activity, mQuery);
        default:
            return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;@Override
public List&amp;lt;? extends SearchResult&amp;gt; loadInBackground() {
    ...

    primaryFirstWordResults = firstWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[0]);
    primaryMidWordResults = secondaryWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[1]);
    secondaryResults = anyWordQuery(MATCH_COLUMNS_SECONDARY, BASE_RANKS[2]);
    tertiaryResults = anyWordQuery(MATCH_COLUMNS_TERTIARY, BASE_RANKS[3]);

    final List&amp;lt;SearchResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(
            primaryFirstWordResults.size()
            + primaryMidWordResults.size()
            + secondaryResults.size()
            + tertiaryResults.size());

    results.addAll(primaryFirstWordResults);
    results.addAll(primaryMidWordResults);
    results.addAll(secondaryResults);
    results.addAll(tertiaryResults);

    return removeDuplicates(results);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;private List&amp;lt;SearchResult&amp;gt; firstWordQuery(String[] matchColumns, int baseRank) {
    final String whereClause = buildSingleWordWhereClause(matchColumns);
    final String query = mQueryText + &amp;quot;%&amp;quot;;
    final String[] selection = buildSingleWordSelection(query, matchColumns.length);

    return query(whereClause, selection, baseRank);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(data_title like ?  OR data_title_normalized like ? ) AND enabled = 1&lt;/p&gt;
&lt;p&gt;日期%&lt;/p&gt;
&lt;p&gt;% 日期%&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onLoadFinished(Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; loader,
        List&amp;lt;? extends SearchResult&amp;gt; data) {
    mSearchAdapter.addSearchResults(data, loader.getClass().getName());
    if (mUnfinishedLoadersCount.decrementAndGet() != 0) {
        return;
    }
    final int resultCount = mSearchAdapter.displaySearchResults();

    if (resultCount == 0) {
        mNoResultsView.setVisibility(View.VISIBLE);
    } else {
        mNoResultsView.setVisibility(View.GONE);
        mResultsRecyclerView.scrollToPosition(0);
    }
    mSearchFeatureProvider.showFeedbackButton(this, getView());
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * Merge the results from each of the loaders into one list for the adapter.
 * Prioritizes results from the local database over installed apps.
 *
 * @return Number of matched results
 */
public int displaySearchResults() {
    final List&amp;lt;? extends SearchResult&amp;gt; databaseResults = mResultsMap
            .get(DatabaseResultLoader.class.getName());
    final List&amp;lt;? extends SearchResult&amp;gt; installedAppResults = mResultsMap
            .get(InstalledAppResultLoader.class.getName());
    final int dbSize = (databaseResults != null) ? databaseResults.size() : 0;
    final int appSize = (installedAppResults != null) ? installedAppResults.size() : 0;
    final List&amp;lt;SearchResult&amp;gt; newResults = new ArrayList&amp;lt;&amp;gt;(dbSize + appSize);

    int dbIndex = 0;
    int appIndex = 0;
    int rank = TOP_RANK;

    while (rank &amp;lt;= BOTTOM_RANK) {
        while ((dbIndex &amp;lt; dbSize) &amp;amp;&amp;amp; (databaseResults.get(dbIndex).rank == rank)) {
            newResults.add(databaseResults.get(dbIndex++));
        }
        while ((appIndex &amp;lt; appSize) &amp;amp;&amp;amp; (installedAppResults.get(appIndex).rank == rank)) {
            newResults.add(installedAppResults.get(appIndex++));
        }
        rank++;
    }

    while (dbIndex &amp;lt; dbSize) {
        newResults.add(databaseResults.get(dbIndex++));
    }
    while (appIndex &amp;lt; appSize) {
        newResults.add(installedAppResults.get(appIndex++));
    }

    final DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(
            new SearchResultDiffCallback(mSearchResults, newResults), false /* detectMoves */);
    mSearchResults = newResults;
    diffResult.dispatchUpdatesTo(this);

    return mSearchResults.size();
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public void dispatchUpdatesTo(final RecyclerView.Adapter adapter) {
    dispatchUpdatesTo(new ListUpdateCallback() {
        @Override
        public void onInserted(int position, int count) {
            adapter.notifyItemRangeInserted(position, count);
        }

        @Override
        public void onRemoved(int position, int count) {
            adapter.notifyItemRangeRemoved(position, count);
        }

        @Override
        public void onMoved(int fromPosition, int toPosition) {
            adapter.notifyItemMoved(fromPosition, toPosition);
        }

        @Override
        public void onChanged(int position, int count, Object payload) {
            adapter.notifyItemRangeChanged(position, count, payload);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>从Android项目学习设计模式</title>
      <link>https://xuanliangdev.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>&lt;h1 id=&#34;从android项目学习设计模式&#34;&gt;从Android项目学习设计模式&lt;/h1&gt;
&lt;p&gt;这个月看了一遍《Android源码设计模式解析与实战》，又一次被android中framework层的设计震惊了，也得到了一些学习的心得体会，“想要理解一个概念，要先理解why，然后才深入how，不能深入细节而忘了初衷”。&lt;/p&gt;
&lt;h2 id=&#34;面向对象六大原则&#34;&gt;面向对象六大原则&lt;/h2&gt;
&lt;p&gt;设计模式其实就是面向对象的六大原则的体现。&lt;/p&gt;
&lt;p&gt;S:单一职责（Single Responsibility Principle）一个类的职责应该只有一个。&lt;/p&gt;
&lt;p&gt;O：开闭原则（Open Close Principle）一个对象应该对修改是封闭的，对扩展是开放的。（使用接口实现）&lt;/p&gt;
&lt;p&gt;L：里氏替换（Liskov Substitution Principle）（子类能替换父类）&lt;/p&gt;
&lt;p&gt;I：接口隔离（Interface Segregation Principle）(类依赖应该建立在最小接口上)&lt;/p&gt;
&lt;p&gt;D：依赖倒置（Dependence Inversion Principle）（参考UML图，使用类指向被依赖的类，倒置后使用类指向接口，实现类也指向接口）&lt;/p&gt;
&lt;p&gt;迪米特原则(Law of Demeter)一个对象应该与其他对象有最少的了解（参考中介模式，）&lt;/p&gt;
&lt;h3 id=&#34;一创建型模式&#34;&gt;一、创建型模式&lt;/h3&gt;
&lt;h4 id=&#34;1singleton单例&#34;&gt;1、Singleton（单例）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader（双重校验锁DCL），ActivityThread，ActivityManagerNative（懒汉式），WindowManagerGlobal（懒汉式）&lt;/p&gt;
&lt;p&gt;懒汉式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Singleton&amp;lt;T&amp;gt; {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
           if (mInstance == null) {
               mInstance = create();
           }
           return mInstance;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DCL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Singleton {
    private static volatile Singleton mInstance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (mInstance == null) {
            synchronized(Singleton.class) {
                if (mInstance == null) {
                    mInstance = new Singleton();
                }
            }
        }
        return mInstance;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Singleton {
    private Singleton() {}
    private static class SingletonHolder {
        private static Singleton mInstance = new Singleton();
    }
    public static Singleton getInstance() {
        return SingletonHolder.mInstance;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2factory-method工厂方法&#34;&gt;2、Factory Method（工厂方法）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/fc9a8e83d034a89a71476498c9846d97.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际应用：BitmapFactory（简单工厂或静态工厂），Iterable&lt;/p&gt;
&lt;p&gt;有的书上说简单工厂并不算工厂模式，真正意义上的工厂方法模式里，“工厂方法”其实是一个抽象方法，该模式拥有不同的工厂类，不同的工厂类实现了各自的工厂方法，例如ArrayListIterator，LinkIterator都可以算是一个工厂，next方法，previous方法都可以看做是一个工厂方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FactoryMethon {
    public static void main(String[] args) {
        // 简单工厂
        Product p = SimpleFactory.create(&amp;quot;A&amp;quot;);
        p.method();
        // 工厂方法
        Factory f = new ConreteFactoryA();
        p = f.create();
        p.method();
        f = new ConreteFactoryB();
        p = f.create();
        p.method();
    }
}

abstract class Product {
    abstract void method();
}

class ConcreteProductA extends Product {

    @Override
    void method() {
        System.out.println(&amp;quot;ConcreteProductA&amp;quot;);
    }
}

class ConcreteProductB extends Product {

    @Override
    void method() {
        System.out.println(&amp;quot;ConcreteProductB&amp;quot;);
    }
}

// 简单工厂
class SimpleFactory {
    public static Product create(String s) {
        if (&amp;quot;A&amp;quot;.equals(s))
            return new ConcreteProductA();
        if (&amp;quot;B&amp;quot;.equals(s))
            return new ConcreteProductB();
        else
            return null;
    }

}

// 工厂方法
abstract class Factory {
    abstract Product create();
}

class ConreteFactoryA extends Factory {
    Product create() {
        return new ConcreteProductA();
    }
}

class ConreteFactoryB extends Factory {
    Product create() {
        return new ConcreteProductB();
    }
}

//ouput:
ConcreteProductA
ConcreteProductA
ConcreteProductB
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3abstract-factory抽象工厂&#34;&gt;3、Abstract Factory（抽象工厂）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/91e85c0c1e75112413c4223aa29efd0e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际应用：MediaPlayerFactory&lt;/p&gt;
&lt;p&gt;抽象工厂相比于工厂方法，多了产品簇的概念，工厂方法是为了当出现新的工厂时可以用很小的代价进行扩展（比如生产智能手机实现了一个createPhone的抽象工厂方法，一开始只有ios和android的工厂实现该方法，当出现新的winphone系统时，只要新建一个winphone工厂来实现createPhone方法就行，代价很小），第一层抽象是根据手机系统的不同，但是如果产品之间也有关联，比如三种系统生产的手机都各自分为高端机型，中端机型，低端机型，这时出现了第二个层次的抽象，高、中、低分别可以抽象出一个接口，再实现三个抽象工厂方法分别生产高、中、低端的手机。&lt;/p&gt;
&lt;p&gt;抽象工厂有利于交换产品系列（从一个系统的高端机换到另一系统的高端机），有利于产品一致性（当一个系列的产品被设计成一起工作时）。&lt;/p&gt;
&lt;p&gt;抽象工厂不利于接入新的工厂，因为如果新工厂只打算生产低端机，也必须实现生产中端、高端机的接口。&lt;/p&gt;
&lt;p&gt;（和工厂方法的明显区别，抽象工厂生产的产品比工厂方法生产的产品多了一层抽象，工厂方法：手机&amp;lt;-android手机，抽象工厂：手机&amp;lt;-高端机&amp;lt;-android手机）&lt;/p&gt;
&lt;h4 id=&#34;4builder创建者&#34;&gt;4、Builder（创建者）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader(ImageLoaderConfiguration.Builder) AlertDialog（AlertDialog.Builder）&lt;/p&gt;
&lt;p&gt;builder中链式调用进行配置，最后通过build方法或create方法生成对象并返回。其实就是通过builder对象的相关方法对各个配置项进行配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BulderPattern {

    public static void main(String[] args) {
        new Dialog.Builder().setTitle(&amp;quot;Title&amp;quot;).setMessage(&amp;quot;Message&amp;quot;).build().show();
    }
}

class Dialog {
    String title = &amp;quot;defaultTitle&amp;quot;;
    String message = &amp;quot;defaultMessage&amp;quot;;

    public void show() {
        System.out.println(title + &amp;quot; &amp;quot; + message);
    }

    public static class Builder {
        private Dialog mD;

        Builder() {
            mD = new Dialog();
        }

        Builder setTitle(String title) {
            mD.title = title;
            return this;
        }

        Builder setMessage(String message) {
            mD.message = message;
            return this;
        }

        Dialog build() {
            return mD;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5prototype原型&#34;&gt;5、Prototype（原型）&lt;/h4&gt;
&lt;p&gt;实际应用：clone方法 Intent的clone方法是通过new自身来实现的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public Object clone() {
    return new Intent(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二结构型模式&#34;&gt;二、结构型模式&lt;/h3&gt;
&lt;h4 id=&#34;6adapter适配器&#34;&gt;6、Adapter（适配器）&lt;/h4&gt;
&lt;p&gt;实际应用：ListView中的Adapter&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AdapterPettern {

    public static void main(String[] args) {
        Target t = new Adapter();
        t.method();
    }
}

interface Target {
    void method();
}

class Adaptee {
    public void methodA() {
        System.out.println(&amp;quot;Adaptee Menthod&amp;quot;);
    };
}

class Adapter implements Target {
    Adaptee a = new Adaptee();

    @Override
    public void method() {
        a.methodA();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7bridge桥接&#34;&gt;7、Bridge（桥接）&lt;/h4&gt;
&lt;p&gt;实际应用：经常用在一些imp类中，比如WindowManagerImp（感觉其实没必要设计WindowManager接口）&lt;/p&gt;
&lt;p&gt;*这个设计模式对于理解android framework的很多设计相当有帮助，可以扩展到其他一些框架的接口类和相关的Imp类进行分析。 用于多维度变化类或者多个树状类之间的耦合的解耦。一个类存在两个独立变化的维度，并且两个维度都需要扩展。&lt;/p&gt;
&lt;p&gt;（想到了一个问题，只被一个类继承的接口到底有没有必要把接口抽象出来，比如WindowManagerImpl和WindowManager，有没有必要把WindowManager接口提取出来）&lt;/p&gt;
&lt;p&gt;这个模式诠释了（多用组合，少用继承）的好处&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Bridge {

    public static void main(String[] args) {
        //两个维度，Size和Additive
        LargeCoffee lc = new LargeCoffee(new Additives() {
        });
        lc.makeCoffee();
		
        Suger suger = new Suger();
        lc = new LargeCoffee(suger);
        lc.makeCoffee();
    }
}

abstract class Coffee {
    Additives add;

    Coffee(Additives add) {
        this.add = add;
    }

    abstract void makeCoffee();
}

abstract class Additives {
    String addSomething() {
        return &amp;quot;Nothing&amp;quot;;
    };
}

class Suger extends Additives {

    @Override
    String addSomething() {
        return &amp;quot;Suger&amp;quot;;
    }
}

class LargeCoffee extends Coffee {
    LargeCoffee(Additives add) {
        super(add);
    }

    @Override
    void makeCoffee() {
        System.out.println(&amp;quot;Large &amp;quot; + add.addSomething());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;8composite组成&#34;&gt;8、Composite（组成）&lt;/h4&gt;
&lt;p&gt;实际应用：View和ViewGroup&lt;/p&gt;
&lt;p&gt;ViewGrop继承于View，并且已聚合的方式包含View&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class View {
    public void create() {
    };
}

abstract class ViewGroup extends View {
    private ArrayList&amp;lt;View&amp;gt; views = new ArrayList&amp;lt;View&amp;gt;();

    public void addView(View v) {
        views.add(v);
    };

    public void removeView(View v) {
        views.remove(v);
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;9decorator装饰&#34;&gt;9、Decorator（装饰）&lt;/h4&gt;
&lt;p&gt;实际应用：Context和ContextWrapper，java中的各种输入输出流&lt;/p&gt;
&lt;p&gt;包装器Wrapper中包含实际对象的引用，并调用实际对象引用的方法，并对实际对象进行功能扩展。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Decorator {

    public static void main(String[] args) {
        ContextImpl ctImp = new ContextImpl();
        new ContextThemeWrapper(ctImp).doSomething();
    }
}

abstract class Context {
    abstract void doSomething();
}

class ContextImpl extends Context {
    void doSomething() {
        System.out.println(&amp;quot;ContextImpl doSomething&amp;quot;);
    };
}

class ContextWrapper extends Context {
    Context mBase;

    ContextWrapper(Context context) {
        mBase = context;
    }

    void doSomething() {
        mBase.doSomething();
    }
}

class ContextThemeWrapper extends ContextWrapper {

    ContextThemeWrapper(Context context) {
        super(context);
    }

    void doSomething() {
        super.doSomething();
        System.out.println(&amp;quot;ContextThemeWrapper doSomething&amp;quot;);
    }
}
//output:
ContextImpl doSomething
ContextThemeWrapper doSomething
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;10facade外观&#34;&gt;10、Facade（外观）&lt;/h4&gt;
&lt;p&gt;实际应用：ContextImpl（管理ActivityManagerNative，PackageManager，ResourcesManager等子系统）&lt;/p&gt;
&lt;p&gt;提供了一个高层次接口，方便各个子系统的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/166ddb9730698785966723efb3d8b8a8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ContextImpl {
    AMS ams;
    PKMS pkms;

    void startActivities() {
        ams.startActivity();
    };

    void getPackageManager() {
        pkms.getPackageManager();
    }

}

class AMS {
    void startActivity() {
        System.out.println(&amp;quot;startActivity&amp;quot;);
    };
}

class PKMS {
    void getPackageManager() {
        System.out.println(&amp;quot;getPackageManager&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ContextImpl相当于一个外观模式，Wrapper类是装饰器模式&lt;/p&gt;
&lt;h4 id=&#34;11flyweight享元&#34;&gt;11、Flyweight（享元）&lt;/h4&gt;
&lt;p&gt;实际应用：Message的重用，JDK中的String对象的常量池&lt;/p&gt;
&lt;p&gt;对象池的一种实现，比如一篇word文档中有一万个字符，创建一万个字符对象代价就太大了。通常和state模式或strategy模式一起使用&lt;/p&gt;
&lt;h4 id=&#34;12proxy代理&#34;&gt;12、Proxy（代理）&lt;/h4&gt;
&lt;p&gt;实际应用：Binder&lt;/p&gt;
&lt;p&gt;对于理解Binder机制很有帮助。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Proxy {

    public static void main(String[] args) {
        RealSub rs = new RealSub();
        ProxySub ps = new ProxySub(rs);
        ps.visit();
    }
}

abstract class Sub {
    abstract void visit();
}

class RealSub extends Sub {
    @Override
    void visit() {
        System.out.println(&amp;quot;RealVisit&amp;quot;);
    }
}

class ProxySub extends Sub {
    RealSub sub;

    ProxySub(RealSub sub) {
        this.sub = sub;
    }

    @Override
    void visit() {
        sub.visit();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三行为模式&#34;&gt;三、行为模式&lt;/h3&gt;
&lt;h4 id=&#34;13chain-of-responsibility责任链对象行为&#34;&gt;13、chain of responsibility（责任链）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：事件分发机制，比如屏幕的触摸事件&lt;/p&gt;
&lt;p&gt;要点是当前Handler保持一个下一节点Handler的引用，当前节点处理不了则把消息分发给下一节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ChainOfResponsibility {

    public static void main(String[] args) {
        Request1 r1 = new Request1();
        Request2 r2 = new Request2();

        Handler1 h1 = new Handler1();
        Handler2 h2 = new Handler2();
        h1.next = h2;
        h1.handlerRequest(r1);
        h1.handlerRequest(r2);
    }

}

abstract class AbsHandler {
    AbsHandler next;

    void handlerRequest(AbsRequest req) {
        if (getHanlderLevel() == req.getRequestLevel()) {
            handle(req);
        } else {
            next.handle(req);
        }
    }

    abstract String getHanlderLevel();

    abstract void handle(AbsRequest req);
}

class Handler1 extends AbsHandler {

    @Override
    String getHanlderLevel() {
        return &amp;quot;1&amp;quot;;
    }

    @Override
    void handle(AbsRequest req) {
        System.out.println(&amp;quot;Handler1 handle&amp;quot;);

    }
}

class Handler2 extends AbsHandler {

    @Override
    String getHanlderLevel() {
        return &amp;quot;2&amp;quot;;
    }

    @Override
    void handle(AbsRequest req) {
        System.out.println(&amp;quot;Handler2 handle&amp;quot;);
    }

}

abstract class AbsRequest {
    abstract String getRequestLevel();
}

class Request1 extends AbsRequest {

    @Override
    String getRequestLevel() {
        return &amp;quot;1&amp;quot;;
    }
}

class Request2 extends AbsRequest {

    @Override
    String getRequestLevel() {
        return &amp;quot;2&amp;quot;;
    }

}
//output:
Handler1 handle
Handler2 handle
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;14command命令对象行为&#34;&gt;14、command（命令）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：PackageManagerService中的MeasureParams、InstallParams和MoveParams&lt;/p&gt;
&lt;p&gt;通过把请求封装成对象，不同的命令对象子类持有各自的接收者，接受者可以相同也可以不同，然后不同的命令对象中，接收者执行不同的具体操作。&lt;/p&gt;
&lt;p&gt;command模式是过程语言中回调（callback）机制的一个面向对象的替代品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CommandPattern {

    public static void main(String[] args) {
        Car car = new Car();
        LeftCommand left = new LeftCommand(car);
        RightCommand right = new RightCommand(car);
        BackCommand back = new BackCommand(car);
        ForwardCommand forward = new ForwardCommand(car);

        Handler h = new Handler(car);
        h.setBack(back);
        h.setForward(forward);
        h.setLeft(left);
        h.setRight(right);

        h.toBack();
        h.toLeft();
        h.toForward();
        h.toRight();
		
        h.undo();
        h.undo();
        h.undo();
        h.undo();
    }
}

class Car {

    void toLeft() {
        System.out.println(&amp;quot;toLeft&amp;quot;);
    }

    void toRight() {
        System.out.println(&amp;quot;toRight&amp;quot;);
    }

    void toForward() {
        System.out.println(&amp;quot;toForward&amp;quot;);
    }

    void toBack() {
        System.out.println(&amp;quot;toBack&amp;quot;);
    }
}

interface Command {
    void execute();
    void undo();
}

class LeftCommand implements Command {
    Car car;

    public LeftCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toLeft();
    }

    @Override
    public void undo() {
        car.toRight();
		
    }
}

class RightCommand implements Command {
    Car car;

    public RightCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toRight();
    }

    @Override
    public void undo() {
        car.toLeft();
		
    }
}

class ForwardCommand implements Command {
    Car car;

    public ForwardCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toForward();
    }

    @Override
    public void undo() {
        car.toBack();
		
    }
}

class BackCommand implements Command {
    Car car;

    public BackCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toBack();
    }

    @Override
    public void undo() {
        car.toForward();
		
    }
}

class Handler {
    Car car;
    LeftCommand left;
    RightCommand right;
    BackCommand back;
    ForwardCommand forward;
    ArrayList&amp;lt;Command&amp;gt; commandList = new ArrayList&amp;lt;&amp;gt;();
    Handler(Car car) {
        this.car = car;
    }

    public void setLeft(LeftCommand left) {
        this.left = left;
    }

    public void setRight(RightCommand right) {
        this.right = right;
    }

    public void setBack(BackCommand back) {
        this.back = back;
    }

    public void setForward(ForwardCommand forward) {
        this.forward = forward;
    }

    void toLeft() {
        left.execute();
        commandList.add(left);
    }

    void toRight() {
        right.execute();
        commandList.add(right);
    }

    void toBack() {
        back.execute();
        commandList.add(back);
    }

    void toForward() {
        forward.execute();
        commandList.add(forward);
    }
	
    void undo(){
        if(commandList.size() &amp;gt; 0){
            commandList.get(commandList.size() - 1).undo();
            commandList.remove(commandList.size() - 1);
        }
    }
}
//output:
toBack
toLeft
toForward
toRight
toLeft
toBack
toRight
toForward
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;15interpreter解释器类行为&#34;&gt;15、interpreter（解释器）（类行为）&lt;/h4&gt;
&lt;p&gt;实际应用：xml解释器&lt;/p&gt;
&lt;p&gt;经常会用到一些正则表达式进行字符串匹配，比较复杂&lt;/p&gt;
&lt;h4 id=&#34;16iterator迭代器对象行为&#34;&gt;16、iterator（迭代器）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：容器对象的遍历&lt;/p&gt;
&lt;h4 id=&#34;17mediator中介者对象行为&#34;&gt;17、mediator（中介者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：KeyguardViewMediator&lt;/p&gt;
&lt;p&gt;将两个对象直接的操作通过实现一个中介者进行解耦。具体客户类都持有一个中介者对象，中介者持有具体客户类对象。缺点是中介者封装了协议，比任何一个客户类都复杂，业务太多的话会变得难以维护。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MediatorPattern {

    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();
        Owner owner = new Owner(mediator);
        Render render = new Render(mediator);
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
        render.action();
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
        owner.action();
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
    }

}

abstract class Trader {
    Mediator m;

    abstract void action();
}

class Owner extends Trader {

    public Owner(ConcreteMediator m) {
        this.m = m;
    }

    @Override
    void action() {
        m.giveMoney(100);
        System.out.println(&amp;quot;Owner receive money from mediator&amp;quot;);
    }

}

class Render extends Trader {

    public Render(ConcreteMediator m) {
        this.m = m;
    }

    @Override
    void action() {
        m.receiveMoney(100);
        System.out.println(&amp;quot;Render give money to mediator&amp;quot;);

    }

}

abstract class Mediator {
    Owner owner;
    Render render;

    abstract void receiveMoney(int money);

    abstract void giveMoney(int money);
}

class ConcreteMediator extends Mediator {
    int money = 0;

    @Override
    void receiveMoney(int money) {
        this.money += money;
    }

    @Override
    void giveMoney(int money) {
        this.money -= money;

    }
}
//output:
mediator has money : 0
Render give money to mediator
mediator has money : 100
Owner receive money from mediator
mediator has money : 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;18memento备忘录对象行为&#34;&gt;18、memento（备忘录）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：onSaveInstanceState（activity相当于caretaker，Bundle相当于memento，各种UI信息相当于originator）&lt;/p&gt;
&lt;p&gt;通过实现一个备忘录（memento）对象，保存原发器（originator）的状态，caretaker负责管理memento。&lt;/p&gt;
&lt;p&gt;*变量以及状态封装成对象进行保存&lt;/p&gt;
&lt;h4 id=&#34;19observer观察者对象行为&#34;&gt;19、observer（观察者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：ListView&lt;/p&gt;
&lt;p&gt;BaseAdapter创建的时候会同时创建一个DataSetObservable（被观察者），当listview调用setAdapter时会创建一个AdapterDataSetObserver（观察者），当Adapter调用notifyDataSetChanged时，被观察者调用notifyChanged遍历通知所有观察者执行onChanged方法，然后观察者会执行重新布局的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ObserverPattern {
    public static void main(String[] args) {
        ConcreteObserver osr1 = new ConcreteObserver(&amp;quot;osr1&amp;quot;);
        ConcreteObserver osr2 = new ConcreteObserver(&amp;quot;osr2&amp;quot;);
        ConcreteSubject sub = new ConcreteSubject();
        sub.attach(osr1);
        sub.attach(osr2);
        sub.notifyObservers();
    }
}

interface Observer {
    void update(Subject o, String arg);
}

class ConcreteObserver implements Observer {
    String name;

    public ConcreteObserver(String name) {
        super();
        this.name = name;
    }

    @Override
    public void update(Subject o, String arg) {
        System.out.println(name + &amp;quot; receive: &amp;quot; + arg);
    }
}

abstract class Subject {
    abstract void attach(Observer observer);

    abstract void detach(Observer observer);

    abstract void notifyObservers();
}

class ConcreteSubject extends Subject {
    ArrayList&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @Override
    void attach(Observer observer) {
        list.add(observer);
    }

    @Override
    void detach(Observer observer) {
        list.remove(observer);
    }

    @Override
    void notifyObservers() {
        for (Observer observer : list) {
            observer.update(this, &amp;quot;new content!&amp;quot;);
        }
    }
}
//output:
osr1 receive: new content!
osr2 receive: new content!
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;20state状态对象行为&#34;&gt;20、state（状态）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：WifiStateMachine&lt;/p&gt;
&lt;p&gt;状态模式把对象行为包装在不同的状态对象里，意图是让一个对象在内部状态改变的时候行为也跟着改变。&lt;/p&gt;
&lt;p&gt;*状态封装成接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class State {

    public static void main(String[] args) {
        TvController tvController = new TvController();
        tvController.downVolme();
        tvController.powerOn();
        tvController.downVolme();
        tvController.powerOff();
        tvController.preChannel();
        tvController.powerOn();
        tvController.nextChannel();
    }
}

interface TvState{
    void upVolume();
    void downVolme();
    void nextChannel();
    void preChannel();
}

class PowerOffState implements TvState{

    @Override
    public void upVolume() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void downVolme() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void nextChannel() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void preChannel() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }
}

class PowerOnState implements TvState{

    @Override
    public void upVolume() {
        System.out.println(&amp;quot;upVolume&amp;quot;);
    }

    @Override
    public void downVolme() {
        System.out.println(&amp;quot;downVolme&amp;quot;);
    }

    @Override
    public void nextChannel() {
        System.out.println(&amp;quot;nextChannel&amp;quot;);
    }

    @Override
    public void preChannel() {
        System.out.println(&amp;quot;preChannel&amp;quot;);
    }
}

class TvController implements TvState{
    TvState tvState = new PowerOffState();;
    public void powerOn(){
        tvState = new PowerOnState();
        System.out.println(&amp;quot;PowerOn TV!&amp;quot;);
    }
	
    public void powerOff(){
        tvState = new PowerOffState();
        System.out.println(&amp;quot;PowerOff TV!&amp;quot;);
    }

    @Override
    public void upVolume() {
        tvState.upVolume();
    }

    @Override
    public void downVolme() {
        tvState.downVolme();
    }

    @Override
    public void nextChannel() {
        tvState.nextChannel();
    }

    @Override
    public void preChannel() {
        tvState.preChannel();
    }
}
//output:
TV is PowerOff
PowerOn TV!
downVolme
PowerOff TV!
TV is PowerOff
PowerOn TV!
nextChannel
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;21strategy策略对象行为&#34;&gt;21、strategy（策略）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader中的各种MemoryCache算法，android实现动画效果的各种插值器算法。&lt;/p&gt;
&lt;p&gt;对算法进行封装，让各个算法直接可以相互替换。&lt;/p&gt;
&lt;p&gt;*方法封装成对象&lt;/p&gt;
&lt;h4 id=&#34;22template-method模板方法类行为&#34;&gt;22、template method（模板方法）（类行为）&lt;/h4&gt;
&lt;p&gt;实际应用：asyncTask，Activity（生命周期方法）&lt;/p&gt;
&lt;p&gt;定义一个算法框架，让其实现延迟到子类。&lt;/p&gt;
&lt;h4 id=&#34;23visitor访问者对象行为&#34;&gt;23、visitor（访问者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：注解框架的实现（ButterKnife）&lt;/p&gt;
&lt;p&gt;是为了将数据操作与数据结构分离的模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class VisitorPattern {

    public static void main(String[] args) {
        Report report = new Report();
        report.showReport(new VisitorA());
        System.out.println(&amp;quot;----------------&amp;quot;);
        report.showReport(new VisitorB());
    }
}

abstract class Staff {
    String name;
    String sex;

    public Staff(String name, String sex) {
        super();
        this.name = name;
        this.sex = sex;
    }

    abstract void accept(Visitor visitor);
}

class StaffA extends Staff {

    public StaffA(String name, String sex) {
        super(name, sex);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visitStaffA(this);
    }
}

class StaffB extends Staff {

    public StaffB(String name, String sex) {
        super(name, sex);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visitStaffB(this);
    }
}

interface Visitor {
    void visitStaffA(StaffA staffA);

    void visitStaffB(StaffB staffB);
}

class VisitorA implements Visitor {

    @Override
    public void visitStaffA(StaffA staffA) {
        System.out.println(staffA.name);
    }

    @Override
    public void visitStaffB(StaffB staffB) {
        System.out.println(staffB.name);
    }
}

class VisitorB implements Visitor {

    @Override
    public void visitStaffA(StaffA staffA) {
        System.out.println(staffA.sex);
    }

    @Override
    public void visitStaffB(StaffB staffB) {
        System.out.println(staffB.sex);
    }
}

class Report {
    List&amp;lt;Staff&amp;gt; list = new ArrayList&amp;lt;Staff&amp;gt;();

    public Report() {
        list.add(new StaffA(&amp;quot;AA&amp;quot;, &amp;quot;MALE&amp;quot;));
        list.add(new StaffA(&amp;quot;AB&amp;quot;, &amp;quot;FEMALE&amp;quot;));
        list.add(new StaffB(&amp;quot;BA&amp;quot;, &amp;quot;MALE&amp;quot;));
        list.add(new StaffB(&amp;quot;BB&amp;quot;, &amp;quot;FEMALE&amp;quot;));
    }

    public void showReport(Visitor visitor) {
        for (Staff staff : list) {
            staff.accept(visitor);
        }
    }
}
//output：
A
A
B
B
----------------
MALE
FEMALE
MALE
FEMALE&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>ActivityManagerService流程总结</title>
      <link>https://xuanliangdev.github.io/post/activitymanagerservice%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/activitymanagerservice%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;activitymanagerservice流程总结&#34;&gt;ActivityManagerService流程总结&lt;/h2&gt;
&lt;p&gt;ActivityManagerService是一个Binder服务，用来负责系统中四大组件的管理和调度。&lt;/p&gt;
&lt;h3 id=&#34;1activitymanagerservice启动流程分析&#34;&gt;1.ActivityManagerService启动流程分析&lt;/h3&gt;
&lt;p&gt;Android系统第一个启动的进程是Zygote进程，是通过脚本启动的，这个进程启动后马上会通过fork启动一个System Server进程，system server进程很重要，PackageManagerService和ActivityManagerService等一些重要服务都是运行在这个进程里。System Server进程启动后会开启一个ServerThread线程，这是一个开启了looper的线程，然后会在这个线程里调用ActivityManagerService的main函数进行启动。&lt;/p&gt;
&lt;p&gt;main函数执行的时序图如下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/d88c3b68bcb05192324ec63afcaeb194.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1.创建一个AThread的线程&lt;/p&gt;
&lt;p&gt;2.启动Athread线程&lt;/p&gt;
&lt;p&gt;3.等待ActivityManagerService对象的创建&lt;/p&gt;
&lt;p&gt;4.Athread这时会去创建ActivityManagerService对象，即执行ActivityManagerService的构造方法&lt;/p&gt;
&lt;p&gt;5.ActivityManagerService对象创建完成唤醒ServerThread线程&lt;/p&gt;
&lt;p&gt;6.Athread等待&lt;/p&gt;
&lt;p&gt;7.执行ActivityThread.systemMain()函数，（我们知道ActivityThread是一个app进程的主线程，借用《深入理解Android卷2》中一句话，systemMain的目的是为system_server进程搭建一个和普通app进程一样的android运行环境）&lt;/p&gt;
&lt;p&gt;8.创建ActivityThread对象（在这里其实是system/framework/framework-res.apk的主线程）&lt;/p&gt;
&lt;p&gt;9.关联到系统进程&lt;/p&gt;
&lt;p&gt;10.取得系统ContextImpl对象（同样是system/framework/framework-res.apk的context）&lt;/p&gt;
&lt;p&gt;11.返回ContextImpl对象，然后创建一个ActivityStack对象。&lt;/p&gt;
&lt;p&gt;12.唤醒Athread线程，Athread线程进入looper循环&lt;/p&gt;
&lt;p&gt;13.继续执行startRunning函数（此处由于系统没准备好，直接返回）&lt;/p&gt;
&lt;h2 id=&#34;2startactivity流程分析&#34;&gt;2.startActivity流程分析&lt;/h2&gt;
&lt;p&gt;在控制台可以通过adb shell登录，并通过am命令打开一个activity
比如&lt;/p&gt;
&lt;p&gt;am start -n demo.leakcanary.srain.in.leakcanarydemo/.MainActivity&lt;/p&gt;
&lt;p&gt;activity从桌面启动的时序图如下图所示：&lt;/p&gt;
&lt;p&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-X8FsQtIO-1613019571484)(https://i.imgur.com/TUdt4OH.png)]&lt;/p&gt;
&lt;h3 id=&#34;1-911步在amsactivitymanagerservice进程中执行&#34;&gt;1-9、11步在AMS（ActivityManagerService）进程中执行；&lt;/h3&gt;
&lt;p&gt;1.使用am命令启动一个activity，实质是Am类通过ActivityManagerNative.getDefault()获得一个ActivityManagerProxy代理，ActivityManagerProxy代理会调用startActivityAndWait方法，而这其实又会调用AMS的startActivityAndWait方法。（因为AMS是ActivityManagerNative子类）&lt;/p&gt;
&lt;p&gt;2.调用ActivityStack的startActivityAndWait方法，ActivityStack是AMS的一个实例，是对activity进行调度的核心，比如管理activity的启动模式。&lt;/p&gt;
&lt;p&gt;3.这里会获取launchFlags来取出启动模式，检查权限等。&lt;/p&gt;
&lt;p&gt;4.创建activityRecod。&lt;/p&gt;
&lt;p&gt;5.这里也会对不同的启动模式进行处理，即为新建的activity_record找task。&lt;/p&gt;
&lt;p&gt;6.里面有一些动画相关的处理&lt;/p&gt;
&lt;p&gt;7.判断当前是否有resume的activity，有就进行pause操作（当前是home界面，所以先对launcher当前显示的activity进行pause操作）&lt;/p&gt;
&lt;p&gt;8.取出launcher进程的ApplicationThreadProxy代理。&lt;/p&gt;
&lt;p&gt;9.调用launcher进程代理的schedulePauseActivity方法进行pause activity的操作&lt;/p&gt;
&lt;p&gt;11、AMS执行完毕进入等待。&lt;/p&gt;
&lt;h3 id=&#34;1012-14在launcher所在进程中执行&#34;&gt;10、12-14在launcher所在进程中执行；&lt;/h3&gt;
&lt;p&gt;10.取出AMS发过来的参数。&lt;/p&gt;
&lt;p&gt;12.launcher通过H向自己的主线程发送pause activity的消息&lt;/p&gt;
&lt;p&gt;13.处理activity的pause操作。&lt;/p&gt;
&lt;p&gt;14.通过ActivityManagerProxy通知AMS当前activity已经完成暂停操作了。由此可见打开一个activity，首先得先把当前显示的activity先暂停。而不是先创建新的activity。&lt;/p&gt;
&lt;h3 id=&#34;15-22在ams进程中执行&#34;&gt;15-22在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;15.AMS调用ActivityStack的activityPaused方法。&lt;/p&gt;
&lt;p&gt;16.该过程会检查系统是否正在进入睡眠或关闭，否则再次调用resumeTopActivityLocked函数。&lt;/p&gt;
&lt;p&gt;17.resumeTopActivityLocked这个函数在第7步调用过，当时前面的activity没pause所以直接返回了，现在launcher显示的activity已经pause成功，则马上调用startSpecificActivityLocked方法、&lt;/p&gt;
&lt;p&gt;18.该函数首先会检查当前要启动的activity所在进程是否存在，如果不存在则新建进程，如果存在则直接执行realStartActivityLocked方法（这个方法后面32步也会调到）。&lt;/p&gt;
&lt;p&gt;19.取出ProcessRecord对象，如果进程不存在，则新建ProcessRecord对象，并加入到AMS的mProcessNames中。&lt;/p&gt;
&lt;p&gt;20.调用另一个startProcessLocked来创建新的进程对象&lt;/p&gt;
&lt;p&gt;21.调用Process.start方法开启一个新进程&lt;/p&gt;
&lt;p&gt;22.AMS执行完进入等待。&lt;/p&gt;
&lt;h3 id=&#34;23-26在新开的应用进程中执行&#34;&gt;23-26在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;23.Process.start开启进程后会进入新的app的主线程的main方法，也就是ActivityThread的main方法。ActivityThread类加载时会new一个ApplicationThread的binder对象，AMS便会和这个ApplicationThread进行进程间通信。&lt;/p&gt;
&lt;p&gt;24.创建一个ActivityThread对象。&lt;/p&gt;
&lt;p&gt;25.调用对象的attach方法&lt;/p&gt;
&lt;p&gt;26.通过AMS代理调用AMS的attachApplication方法&lt;/p&gt;
&lt;h3 id=&#34;27-28在ams进程中执行&#34;&gt;27-28在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;27.目的是将新的app的ApplicationThread和pid在AMS中注册。&lt;/p&gt;
&lt;p&gt;28.通过ApplicationThreadProxy将信息返回给新的app进程。&lt;/p&gt;
&lt;h3 id=&#34;29-31在新开的应用进程中执行&#34;&gt;29-31在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;29.新应用取出AMS发过来的数据向自己主线程的H发送消息。&lt;/p&gt;
&lt;p&gt;30.H处理消息。&lt;/p&gt;
&lt;p&gt;31.执行handleBindApplication进行相关信息的绑定。此处的操作包括创建上下文ContextImpl，创建应用的application，并调用application的oncreate方法。&lt;/p&gt;
&lt;h3 id=&#34;32-33在ams进程中执行&#34;&gt;32-33在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;32.AMS执行完bindApplication后便开始调用ActivityStack的realStartActivityLocked进行activity的显示，（该方法在之前18步的一个分支也可能会调用到）&lt;/p&gt;
&lt;p&gt;33.调用scheduleLaunchActivity方法，通过ApplicationThreadPoxy通知应用进行打开activity。&lt;/p&gt;
&lt;h3 id=&#34;34-44在新开的应用进程中执行&#34;&gt;34-44在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;34.像主线程的H发送打开activity的message。&lt;/p&gt;
&lt;p&gt;35.处理打开activity的操作。&lt;/p&gt;
&lt;p&gt;36.调用performLaunchActivity进行创建并打开activity的操作。&lt;/p&gt;
&lt;p&gt;37.该函数内会调用activity声明周期的oncreate和onstart方法。&lt;/p&gt;
&lt;p&gt;38.通过反射创建activity对象。&lt;/p&gt;
&lt;p&gt;39.newActivity创建完成返回activity变量。&lt;/p&gt;
&lt;p&gt;40.调用Instrumentation的callActivityOnCreate方法。&lt;/p&gt;
&lt;p&gt;41.调用activity的oncreate方法。&lt;/p&gt;
&lt;p&gt;42.执行完后会紧接着执行activity.performStart方法，即回调activity的onstart方法。&lt;/p&gt;
&lt;p&gt;43.执行handleResumeActivity方法，当44步调用完后，接着还会往主线程的MessageQueue发送一个Idler对象，会在这里面通知AMS对已经暂停的activity调用onStop和onDestroy的生命周期&lt;/p&gt;
&lt;p&gt;44.该过程会调用activity的onresume方法。&lt;/p&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;Android AOSP代码&lt;/p&gt;
&lt;p&gt;《深入理解Android 卷2 邓凡平》&lt;/p&gt;
&lt;p&gt;《Android系统源代码情景分析 罗升阳》&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android内存性能分析</title>
      <link>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;h1 id=&#34;android内存性能分析&#34;&gt;Android内存性能分析&lt;/h1&gt;
&lt;p&gt;工具：Android Studio、MAT(Memory Analyzer Tool)&lt;/p&gt;
&lt;p&gt;第三方库：LeakCanary&lt;/p&gt;
&lt;h2 id=&#34;1android-profiler基础用法&#34;&gt;1、Android Profiler基础用法&lt;/h2&gt;
&lt;p&gt;首先附上Android Profilder的官方使用说明地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.google.cn/studio/profile/memory-profiler.html&#34;&gt;https://developer.android.google.cn/studio/profile/memory-profiler.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android Profiler可以实时查看app的cpu、memory和network状态，这里只说memory，简单写个用GridView加载大量网络图片的例子，对于加载到的bitmap对象分别采用HashMap和LruCache进行保存，观察内存变化。&lt;/p&gt;
&lt;p&gt;当使用HashMap时，观察Android Profiler中memory的变化
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/d2c75694fc47cc7d42d8d17f07808d93.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出内存不停增加，最终程序oom；&lt;/p&gt;
&lt;p&gt;接着用LruCache替换HashMap，LruCahe的配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // 获取应用程序最大可用内存
    int maxMemory = (int) Runtime.getRuntime().maxMemory();
    int cacheSize = maxMemory / 8;
    // 设置图片缓存大小为程序最大可用内存的1/8
    mMemoryCache = new android.util.LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getByteCount();
        }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/f9d15f24a08c15d50886f9356d4feb6c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，当内存达到一定的值时得到了回收。&lt;/p&gt;
&lt;p&gt;*AndroidManifest.xml文件&lt;!-- raw HTML omitted --&gt;中可以设置 android:largeHeap=&amp;quot;true&amp;quot;来增加app的可使用内存，实验发现默认情况下nexus5手机android6.0系统当内存达到300多M时产生oom，如果设置该选项内存达到500多M时才会oom，但是设置该值会导致gc时间变长从而一定程度上影响性能，所以要斟酌使用。&lt;/p&gt;
&lt;p&gt;*ActivityManager获取的内存值定义在系统rom中，编译时已经写入系统，而Runtime类可以获得运行时的内存数据，也是Android profiler显示的动态图数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHead am.getMemoryClass()为192
02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHead am.getLargeMemoryClass()为512
02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHeadRuntime.getRuntime().maxMemory()为：536870912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;android:largeHeap=&amp;quot;false&amp;quot;时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;02-02 20:44:46.550 17492-17492/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHeadRuntime.getRuntime().maxMemory()为：201326592
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2使用android-profiler进行内存泄露分析&#34;&gt;2、使用Android Profiler进行内存泄露分析。&lt;/h3&gt;
&lt;p&gt;一个简单的内存泄露例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestActivity extends Activity {
    TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        textView = (TextView) findViewById(R.id.test_text_view);
        TestDataModel.getInstance().setRetainedTextView(textView);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TestDataModel的class文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestDataModel {

    private static TestDataModel sInstance;
    private TextView mRetainedTextView;

    public static TestDataModel getInstance() {
        if (sInstance == null) {
            sInstance = new TestDataModel();
        }
        return sInstance;
    }

    public void setRetainedTextView(TextView textView) {
        mRetainedTextView = textView;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在例子中，当TestActivity finish后，由于静态变量sInstance引用了textView，而textView引用了TestActivity的context，最终导致TestActivity对象不能被回收产生了内存泄露。&lt;/p&gt;
&lt;p&gt;找出本应该回收但是并没有回收的对象（也就是发生了泄露的对象）：&lt;/p&gt;
&lt;p&gt;通过分析操作前和操作后的堆中的对象分配，首先找出堆计数异常大或者本该回收但是却没得到回收的对象，然后查看具体是哪些对象引用了他们导致他们没能回收。&lt;/p&gt;
&lt;p&gt;也可以从Android Studio中将堆转储保存为hprof文件来用其他工具（比如MAT）进行分析，比如上面的例子，TestActivity打开前保存一二hprof文件，然后打开后再finish，然后再在android studio中手动gc一下，再导出hprof文件。接着在MAT中对比这两个堆文件。结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/b6e1969b987f1b0b6ff134ce61001852.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见TestDataModel对象和TestActivity对象并没有被回收，这是因为静态的sInstance生命周期跟application一样，而sInstance引用了textView，textView引用了TestActivity的context，因此TestActivity也没有被回收。&lt;/p&gt;
&lt;h3 id=&#34;3使用leakcanary进行内存泄露分析&#34;&gt;3、使用LeakCanary进行内存泄露分析。&lt;/h3&gt;
&lt;p&gt;LeakCanary是square公司开源的一个检测内存泄露的工具库，使用很简单，只要在gradle中依赖一下，然后在application中注册一下就行了。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&#34;https://github.com/square/leakcanary&#34;&gt;https://github.com/square/leakcanary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用LeakCanary检测内存泄露实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestActivity2 extends Activity {
    TextView textView;
    Message msg;
    Handler mLeakyHandler= new Handler(){
        @Override
        public void handleMessage(Message msg) {
        }
    };
    Message msg;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        msg = Message.obtain();
        mLeakyHandler.sendMessageDelayed(msg, 40000);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中TestActivity打开后马上关闭，会产生内存泄露，LeakCanary会有如下内存泄露提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/03bf5ed49636637f47071953e5b7e741.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是因为handler发送一个消息给MessageQueue后，存在一条这样的引用链，主线程→mainLooper→MessageQueue→Message→handler→TestActivity，当activity destroy后，message还存在消息队列里，因此activity对象得不得回收。&lt;/p&gt;
&lt;p&gt;要使activity能得到回收，只要在activity关闭后在这个引用链的任意一处切断都行，有如下三种方法：&lt;/p&gt;
&lt;p&gt;1.切断Message和messageQueue的联系，即在activity的onDestroy中调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mLeakyHandler.removeCallbacksAndMessages(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法可以移除消息队列中的消息从而切断Message和MessageQueue的联系，使activity得到回收。&lt;/p&gt;
&lt;p&gt;2.切断Message和handler的联系，可以通过在activity的onDestroy中调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; msg.setTarget(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来实现，即把handler置空。&lt;/p&gt;
&lt;p&gt;3.由于非静态内部类或匿名类会持有外部类的引用，即handler持有activity的引用，因此可以通过把handler声明为静态内部类来切断handler对activity实例的引用，但是静态内部类的对象是不能调用外部类的实例变量的，因此可以通过传递一个外部activity实例的WeakReference给handler使用，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static class MyHandler extends Handler
    {
        private WeakReference&amp;lt;Context&amp;gt; reference;

        public MyHandler(Context activity)
        {
            reference = new WeakReference&amp;lt;Context&amp;gt;(activity);
        }

        @Override
        public void handleMessage(Message msg)
        {
            TestActivity2 mTestActivity = (TestActivity2) reference.get();
            if (reference.get() != null)
            {
                mTestActivity.textView.setText(&amp;quot;hello&amp;quot;);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;handler泄露的危害：有的人会说通常情况不会使用handler发送延迟太久的消息，而且消息达到延迟的时间后，activity不就可以自动被回收了么，因此handler泄露也没什么打不了啊，但是考虑这样一个情景，通常我们都会在onDestory里处理一些资源回收的操作，如果handler的handleMessage里面使用到了某些资源，而这些资源被回收了，那就会出问题了，最常见的就是产生空指针导致程序崩溃。&lt;/p&gt;
&lt;h3 id=&#34;3leakcanary原理简单介绍&#34;&gt;3、LeakCanary原理简单介绍。&lt;/h3&gt;
&lt;p&gt;leakCanary内存泄露检测完整时序图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/796a8176b9a07f8a39500a118cb8e8b6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码中我们只要简单使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LeakCanary.install(this);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就能完成LeakCanary的初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
        .buildAndInstall();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要看下buildAndInstall这个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      LeakCanary.enableDisplayLeakActivity(context);
      ActivityRefWatcher.install((Application) context, refWatcher);
    }
    return refWatcher;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面调用了ActivityRefWatcher.install方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void install(Application application, RefWatcher refWatcher) {
    new ActivityRefWatcher(application, refWatcher).watchActivities();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面调用了watchActivities这个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void watchActivities() {
    // Make sure you don&#39;t get installed twice.
    stopWatchingActivities();
    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lifecycleCallbacks定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
  new Application.ActivityLifecycleCallbacks() {
    @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    }

    @Override public void onActivityStarted(Activity activity) {
    }

    @Override public void onActivityResumed(Activity activity) {
    }

    @Override public void onActivityPaused(Activity activity) {
    }

    @Override public void onActivityStopped(Activity activity) {
    }

    @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }

    @Override public void onActivityDestroyed(Activity activity) {
      ActivityRefWatcher.this.onActivityDestroyed(activity);
    }
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是application提供的一个方法，可以用来监听我们应用中所有activity的生命周期，LeakCanay就是在这里通过监控所有activity的onDestroyed方法来检测内存泄露的。&lt;/p&gt;
&lt;p&gt;继续进入ActivityRefWatcher.this.onActivityDestroyed方法，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void onActivityDestroyed(Activity activity) {
    refWatcher.watch(activity);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LeakCanay内存泄露检测的核心就是这个watch方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
      return;
    }
    checkNotNull(watchedReference, &amp;quot;watchedReference&amp;quot;);
    checkNotNull(referenceName, &amp;quot;referenceName&amp;quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
        new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;retainedKeys是一个Set&lt;!-- raw HTML omitted --&gt;类型的集合，用来记录被监控的所有还在内存的对象（这里是刚调用了onDestoryed方法的activity对象），KeyedWeakReference继承自WeakReference，作用是用一个弱引用来引用被监控的对象（activity），queue是一个ReferenceQueue队列，作用后面说，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    long gcStartNanoTime = System.nanoTime();
    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);

    removeWeaklyReachableReferences();

    if (debuggerControl.isDebuggerAttached()) {
      // The debugger can create false leaks.
      return RETRY;
    }
    if (gone(reference)) {
      return DONE;
    }
    gcTrigger.runGc();

    removeWeaklyReachableReferences();
    if (!gone(reference)) {
      long startDumpHeap = System.nanoTime();
      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);

      File heapDumpFile = heapDumper.dumpHeap();
      if (heapDumpFile == RETRY_LATER) {
        // Could not dump the heap.
        return RETRY;
      }
      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
      heapdumpListener.analyze(
          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
              gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ensureGone是LeakCanay内存泄露检测主要逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
      retainedKeys.remove(ref.key);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先从removeWeaklyReachableReferences这个方法说起，从上面的注释我们可以看出ReferenceQueue的作用（如果一个对象变成弱引用，那么这个对象入队），也就是如果我们的activity被finish了，正常情况下这个activity是应该进入这个队列了，因此当我们通过queue.poll()把这个activity对象取出来，retainedKeys中就移除这个activity，表示这个activity被回收了，而gone(reference)这个方法就是来判断retainedKeys中是否还存在这个对象，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  private boolean gone(KeyedWeakReference reference) {
    return !retainedKeys.contains(reference.key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;removeWeaklyReachableReferences和gone方法都执行了两次，如果第一次对象就从retainedKeys移除了，那就是表示对象已经成功被回收了，如果没有，则调用gcTrigger.runGc()执行一次gc操作，再进一步确认对象是否还存在，如果还存在则猜测发生了内存泄露，因此取出dump文件进一步分析，对dump文件的分析使用了squareup的另一个haha库，如果确实出现了泄露，则找出泄露对象的引用路径通知用户。如有需要我们也可以导出LeakCanay生成的dump文件使用其他工具比如MAT，Android Studio进行分析。&lt;/p&gt;
&lt;p&gt;*看LeakCanary源码时发现使用到了一个&lt;a href=&#34;https://github.com/tbroyer/gradle-errorprone-plugin&#34;&gt;net.ltgt.gradle:gradle-errorprone-plugin&lt;/a&gt;的库，通过这个库，如果我们的handler有内存泄露的隐患，直接在运行app时就会报错，因此我们可以在项目中引用这个库来提前发现一些问题，从而避免一些安全隐患。&lt;/p&gt;
&lt;h3 id=&#34;推荐书籍&#34;&gt;推荐书籍&lt;/h3&gt;
&lt;p&gt;《Android群英传：神兵利器》&lt;/p&gt;
&lt;p&gt;《高性能Android应用开发》&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>APK的安装过程分析</title>
      <link>https://xuanliangdev.github.io/post/apk%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/apk%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;h2 id=&#34;apk的安装过程分析packagemanagerservice启动过程&#34;&gt;APK的安装过程分析（PackageManagerService启动过程）&lt;/h2&gt;
&lt;p&gt;时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/988c7fc940d83d6bdaa9d306e709bf70.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;步骤说明&#34;&gt;步骤说明&lt;/h2&gt;
&lt;p&gt;1.pkms的main函数入口&lt;/p&gt;
&lt;p&gt;2.加入android.uid.system，android.uid.phone等一些系统的shareUserId，保存到SharedUserSetting数据结构&lt;/p&gt;
&lt;p&gt;3.保存shareUserId到Uid的数据结构中&lt;/p&gt;
&lt;p&gt;4.从system/etc/permissions目录的xml读取权限，这些xml文件是编译完成后烧写进手机的。&lt;/p&gt;
&lt;p&gt;5.将xml的内容保存到特定的数据结构。&lt;/p&gt;
&lt;p&gt;6.解析data/system/目录下packages.xml，packages-backup.xml，packages.list，packages-stopped.xml，packages-stopped-backup.xml的信息&lt;/p&gt;
&lt;p&gt;7.读取packages.xml文件中package标签信息&lt;/p&gt;
&lt;p&gt;8.保存xml信息到PackageSetting的数据结构&lt;/p&gt;
&lt;p&gt;9.保存pakage到应用对应的uid数据结构，和3步骤相似&lt;/p&gt;
&lt;p&gt;10.读取packages.xml文件中shared-user标签信息&lt;/p&gt;
&lt;p&gt;11.保存xml信息到SharedUserSetting的数据结构&lt;/p&gt;
&lt;p&gt;12.保存shareUserId到应用对应的uid数据结构，和3，9步骤相似&lt;/p&gt;
&lt;p&gt;13.开始扫描package，此函数会调用多次，从而扫描不同目录下的apk文件，比如系统的apk默认路径有system/framework,system/app,system/vendor/app这三个，非系统apk安装路径为data/app,data/app-private&lt;/p&gt;
&lt;p&gt;14.对每个apk文件执行scanPackageLI操作&lt;/p&gt;
&lt;p&gt;15.PackageParser解析apk（即解析AndroidManifest.xml文件中的各个标签，主要通过AssetManager来取出apk中的AndroidManifest.xml文件）并返回Package对象&lt;/p&gt;
&lt;p&gt;16.生成Package对象&lt;/p&gt;
&lt;p&gt;17.返回Package对象并传入第二个scanPackageLI函数的参数中&lt;/p&gt;
&lt;p&gt;18.开始第二个scanPackageLI函数，这个函数做的事情比较多，比如将apk里的lib文件夹的动态库so文件解压出来&lt;/p&gt;
&lt;p&gt;19.获取一个pkg的setting信息&lt;/p&gt;
&lt;p&gt;20.获取一个pkg的setting信息&lt;/p&gt;
&lt;p&gt;21.为解析得到的pkg分配linux 的uid&lt;/p&gt;
&lt;p&gt;22.获取pkg的setting信息结束（后面还会把这个信息保存到mSettings变量里）&lt;/p&gt;
&lt;p&gt;23.这一步之前还会循环遍历所有四大组件的信息并保存到成员变量中，&lt;/p&gt;
&lt;p&gt;24.汇总并更新权限相关信息&lt;/p&gt;
&lt;p&gt;25.授予权限&lt;/p&gt;
&lt;p&gt;26.将应用的安装信息保存到data/system/目录下的package.xml,package.list等本地文件之中&lt;/p&gt;
&lt;p&gt;27.结束pkms的构造函数&lt;/p&gt;
&lt;p&gt;后续计划，permission，assetmanager和resource相关的学习。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>mac编译源码</title>
      <link>https://xuanliangdev.github.io/post/mac%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/mac%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/</guid>
      
        <description>&lt;h2 id=&#34;mac-编译-android-framework-60源码&#34;&gt;Mac 编译 android framework 6.0源码&lt;/h2&gt;
&lt;p&gt;工作到现在为止刚好一年半，一直做着公司Android产品的半开发半维护的工作，内心一直向往一份关于android framework开发方面的工作，前面几个月研读了一些设计模式和Sandroid framework源码的书，接下来的目标就是搭建调试framework的环境，听说mac不错，于是买了个mba 128g的笔记本，现在有点后悔，如果时间能重新选择，一定买mbp，本来打算编译2.3点源码的，但是看了官方的android版本于编译系统的对应关系，还是决定按要求来吧，选择了android6.0.1版本，而且自己有个nexus5，正好可以刷。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Android版本&lt;/th&gt;
&lt;th&gt;Mac OS (Intel/x86)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Android 6.0 (Marshmallow) - Android最新版本&lt;/td&gt;
&lt;td&gt;Mac OS v10.10 (Yosemite) or later with Xcode 4.5.2 and Command Line Tools&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 5.x (Lollipop)&lt;/td&gt;
&lt;td&gt;Mac OS v10.8 (Mountain Lion) with Xcode 4.5.2 and Command Line Tools&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 4.1.x-4.3.x (Jelly Bean) - Android 4.4.x (KitKat)&lt;/td&gt;
&lt;td&gt;Mac OS v10.6 (Snow Leopard) or Mac OS X v10.7 (Lion) and Xcode 4.2 (Apple’s Developer Tools)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 1.5 (Cupcake) - Android 4.0.x (Ice Cream Sandwich)&lt;/td&gt;
&lt;td&gt;Mac OS v10.5 (Leopard) or Mac OS X v10.6 (Snow Leopard) and the Mac OS X v10.5 SDK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;##1、本文相关配置&lt;/p&gt;
&lt;p&gt;硬件：&lt;/p&gt;
&lt;p&gt;1、MacBook Air i5双核处理器 硬盘128g 内存8g&lt;/p&gt;
&lt;p&gt;2、一块2T的移动硬盘&lt;/p&gt;
&lt;p&gt;3、nexus5&lt;/p&gt;
&lt;p&gt;软件：&lt;/p&gt;
&lt;p&gt;1、各个版本的jdk，jdk6、jdk7、jdk8，（本文选择android版本为6.0.1因此默认用jdk7）&lt;a href=&#34;https://pan.baidu.com/s/1bp8ouMr&#34;&gt;网盘地址&lt;/a&gt;  密码:tz95&lt;/p&gt;
&lt;p&gt;2、repo &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、清华镜像站的初始化包 &lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/help/AOSP/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、选择编译的android版本为android-6.0.1_r60（r60分支只支持刷入nexus5）&lt;/p&gt;
&lt;p&gt;5、xcode8（最新版为xcode9，但是编译过程提示xcode和aosp中externl库函数冲突，google发现别人也有这个问题，换xcode8后解决了）&lt;/p&gt;
&lt;p&gt;6、MacOSX10.11.sdk（xcode8默认的MacOSX10.12.sdk编译时会提示有些函数废弃了编译不了，因此需要下载10.11.sdk，并拷贝到10.12.sdk同一目录下）&lt;a href=&#34;https://pan.baidu.com/s/1jHE5wdo&#34;&gt;网盘地址&lt;/a&gt;密码:kv23&lt;/p&gt;
&lt;p&gt;7、MacPorts（用于方便安装make、git、gpg等相关工具）&lt;a href=&#34;https://www.macports.org/install.php&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、nexus5 r60分支版本的驱动&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/android/drivers#hammerheadlrx22c&#34;&gt;google官网驱动下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nexus5 r60分支版本MOB30Y的驱动&lt;a href=&#34;https://pan.baidu.com/s/1gf2GzBX&#34;&gt;网盘地址&lt;/a&gt;密码:2a33，不同版本对应不同驱动，这个要注意&lt;/p&gt;
&lt;p&gt;##2、下载源码&lt;/p&gt;
&lt;p&gt;国内有长城，google下不来，可以从&lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/help/AOSP/&#34;&gt;清华大学开源软件镜像站&lt;/a&gt;下,看介绍源码会有30g以上，但是自己的笔记本却只有128g，而且现在就剩40g了，查资料发现可以在移动硬盘弄，于是乎买了个2t的移动硬盘。&lt;/p&gt;
&lt;p&gt;##3、下载repo工具
1.这个命令会下载一个repo的文件到当前命令的目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*&lt;em&gt;第一个知识点：repo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2.在home目录下创建bin目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir ~/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.把上面下载的repo拷贝到~/bin目录下&lt;/p&gt;
&lt;p&gt;4.赋予权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod a+x ~/bin/repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.用文本编辑的方式打开repo，并且修改为REPO_URL为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##4、安装MacPorts&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.macports.org/install.php&#34;&gt;MacPorts下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接着使用下面等MacPorts命令安装make、git等工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo port install gmake libsdl git-core gnupg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##5、创建一个区分大小写的镜像文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdiutil create -type SPARSE -fs &#39;Case-sensitive Journaled HFS+&#39; -size 100g ~/android.dmg.sparsefile.sparseimage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个镜像主要是用来存放源代码的，由于我用的是移动硬盘来编译源码，因此把这个镜像文件移动到移动硬盘里，因为自己笔记本容量小，因此把镜像文件拷到移动硬盘后再进行使用镜像，这步很重要，这个100g是镜像的上限，新创建时并没有100g，只有200多m，而且可以动态改变大小，只要用下面的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdiutil resize -size 150g ~/android.dmg.sparsefile.sparseimage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我编译了模拟器以及真机的镜像，最后镜像大小为127g，当然如果编译时空间不够，可以把.repo删除了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4a21dc980710ba590aa2ee80226169fc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在~/根目录下看看有没有.bash_profile文件，没有就创建一个，这个文件主要是用来进行一些环境变量的配置，下面是我自己的.bash_profile文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 用来挂载镜像的函数
function mountAndroid { hdiutil attach /Volumes/mhdd/android.dmg.sparsefile.sparseimage -mountpoint /Volumes/android; }

# 推出镜像，跟在桌面推出效果一样
function umountAndroid() { hdiutil detach /Volumes/android; }

# 安装MacPorts的变量配置
PATH=/opt/local/bin:$PATH
PATH=/opt/local/sbin:$PATH

#解除1024限制 
ulimit -S -n 1024

# -------------java的环境变量start---------------------
# Mac默认 JDK 6  
export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`  
# 设置 JDK 7  
export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`  
# 设置 JDK 8  
export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`  
  
#默认JDK 7  
export JAVA_HOME=$JAVA_7_HOME  
  
#alias命令动态切换JDK版本，直接在命令行输入jdk6或其他版本就可切换了  
alias jdk6=&amp;quot;export JAVA_HOME=$JAVA_6_HOME&amp;quot;  
alias jdk7=&amp;quot;export JAVA_HOME=$JAVA_7_HOME&amp;quot;  
alias jdk8=&amp;quot;export JAVA_HOME=$JAVA_8_HOME&amp;quot;  
# -------------java的环境变量end---------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​
#&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-repo环境变量&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
export PATH=$PATH:$HOME/bin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-----------------android sdk环境变量--------------
#主要是执行adb命令，fastboot命令等用到，这是我本地的路径，根据需要自己修改
ANDROID_HOME=/Users/xuanliang/coding/android/android-sdk-macosx
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/platform-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*&lt;em&gt;第二个知识点：bash_profile文件是什么&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用命令行mountAndroid挂载好镜像文件后，就可以像硬盘一样使用镜像文件了，在镜像中建立aosp文件夹，接着从清华镜像站下载好40多g的原始包，把它解压到镜像文件aosp文件夹里，是一个.repo的文件。（一开始自己是先从笔记本硬盘把压缩文件拷到镜像里再解压，发现很慢，想起来是因为镜像在移动硬盘上的原因，于是采用直接从笔记本用命令把文件解压到镜像文件里，就快多了），命令行进入到aosp目录，执行初始化repo到命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;r60代表是nexus5的MOB30Y版本，_r60这个参数很重要，因为对应着机型版本以及驱动版本，版本不对烧写真机时容易出问题，可以根据需要取其他分支。然后执行下面的命令进行同步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repo sync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步完成后aosp目录会生成6.0.1_r60分支的所有代码，可以通过.repo目录里的manifest文件看看所下分支是否正确。（执行repo sync命令时遇到了一个坑，查了半天发现是当时解压用的软件解压的，解压的不完全，解压出的文件有问题，后来把文件都删除了，重新用命令行解压后再进行repo sync同步就好了，得了个教训以后对于大文件解压还是得用命令行）&lt;/p&gt;
&lt;p&gt;然后就是进行编译了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source build/envsetup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/75eb0732507c275146ef26586596aee2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lunch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/a5bbf7db3588501c7c41def2a1066810.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -j4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译成功会在products里生成hammerhead文件夹，烧写入真机时要进入这个文件夹执行fastboot等命令，如果上面lunch选择1则会generic文件夹，里面是模拟器用到的镜像相关文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/2a31ce2839c36b89d13b72e28ce2f152.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为要烧写入真机，因此先执行驱动的三个脚本文件生成相关文件，如果只需要模拟器则跳过这步
首先把驱动脚本拷进aosp目录，然后依次执行三个驱动脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/5389f217a75bc639473a83064016c58b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./extract-broadcom-hammerhead.sh
./extract-lge-hammerhead.sh
./extract-qcom-hammerhead.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行过程中会有一些条款，阅读完后会提示输入“同意”指令，输入完会在相关目录生成驱动文件。&lt;/p&gt;
&lt;p&gt;最后手机连上电脑，执行adb命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会让手机重启并进入刷机模式，如果adb命令找不到，先看看是否环境变量配置正确，adb工具以及fastboot工具在android的sdk里，参考步骤5里的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/0b47a76ac0ac6ea90070a673e1a5bbcc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cd 到源码编译输出的目录执行fastboot命令
fastboot -w flashall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后刷机成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/e3feef918e21dc2712f7f90e90039ccc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接着是生成android studio能导入的文件，使用如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make idegen &amp;amp;&amp;amp; development/tools/idegen/idegen.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在源码目录生成两个文件，如下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/cabff872caa4a2dc77ef324206f328c3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以对android.imp进行编辑去掉一些模块，这样android studio导入就会快点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/.repo&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/abi&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/art&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/bionic&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/bootable&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/build&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/cts&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/dalvik&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/developers&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/development&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/device&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/bluetooth&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/chromium&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/emma&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/icu4c&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/jdiff&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/webkit&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/frameworks/base/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/hardware&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/libcore&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/libnativehelper&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/ndk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/eclipse&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/host&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/common/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/product&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/packages&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/pdk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/prebuilt&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/prebuilts&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/sdk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/system&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/tools&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着还要在android stuidio中进行一些源码关联sdk的配置，&lt;/p&gt;
&lt;p&gt;然后就可以通过真机调试framework源代码了。手机连上电脑，关联debugger可以看到手机上的所有进程。选择system_process绑定，
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/e37498538bed10253f625e2e1bbfd221.png&#34; alt=&#34;&#34;&gt;
然后在activitymanagerservice中找个位置打上断点，随便打开一个app，发现可以跳进断点了。
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/43542de5f3bce0390cf4f9c178e56bd6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;编译过程完成，后面就是进一步对android framework的学习了，漫漫长路踏出第一步。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Binder机制学习</title>
      <link>https://xuanliangdev.github.io/post/binder%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 05 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/binder%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;binder机制学习&#34;&gt;Binder机制学习&lt;/h1&gt;
&lt;p&gt;Binder是用在Android系统中的一个进程间通信(IPC)机制，使用C/S架构，服务端和客户端通过Binder进行跨进程的数据交换，Binder继承自IBinder接口，因此IBinder接口最重要的一个方法是transact，所以虽然Android为了减少开发者开发工作量，采用了代理模式封装了一个复杂的Binder架构，但是其本质都是从源进程传递数据给目标进程，然后目标进程处理完后再把数据回传给源进程，所以在学习Binder实现原理时最好是要不时回想起框架实现的目的，才能不被架构里的各种类似的概念搞迷糊。&lt;/p&gt;
&lt;p&gt;关于Service，其实就是提供服务的代码，在java端是通过AIDL来定义进程间通信的接口，Service端实现接口并通过onBind方法向客户端公开该接口，客户端取得该接口后就可以调用接口的相关方法。调用方法也很简单，具体可以参考&lt;a href=&#34;https://developer.android.google.cn/guide/components/aidl.html#Defining&#34;&gt;官方API指南AIDL章节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4ead3d64921078d6d86346f1e0c22954.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;复杂的架构都是为了更方便别人进行调用，我们可以在java端或native端进行binder的使用，作为java开发者我们要使用Binder只要实现图上绿色部分的接口和类就够了（绿色部分的aidl类为android sdk自带的apidemo中的一个示例），而作为native端的开发者需要实现如蓝色部分的接口和类。&lt;/p&gt;
&lt;p&gt;关于Binder的源码分析的书籍有《Android系统源代码情景分析[罗升阳著]》《深入理解Android卷I[邓平凡著]》《Android技术内幕系统卷[杨丰盛著]》，写的都比较好，最好是边看源码边看书，看的时候多想想为什么这么设计，为了防止自己忘记，画了几幅时序图辅助理解。如下四幅图为Binder通信的四个主要过程：&lt;/p&gt;
&lt;p&gt;ServiceManagerProxy获取过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/0609d7a4f068d8ba811e5317df1c5a55.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;向ServiceManager注册Service过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/183c79904de0ae85ae16c07713e7d779.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;Service代理对象获取过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/621b0903549b48c66db5bdd89945411e.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;跨进程调用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/62fc2c1f41d27954757fa74d9cc688a7.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android 消息处理机制学习</title>
      <link>https://xuanliangdev.github.io/post/android-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;android-消息处理机制学习&#34;&gt;Android 消息处理机制学习&lt;/h1&gt;
&lt;p&gt;之前也看过不少的书或博客介绍Android 消息处理机制的知识点，但总是刚看完感觉懂了，过几天就忘，今天一边看源码，一边画了类图和时序图，希望可以加深自己的理解。&lt;/p&gt;
&lt;p&gt;Android应用启动时会创建一个主线程，与Android UI工具包交互，因此也叫UI线程，因此不能被一些耗时长的操作阻塞，阻塞时通常的表现是UI控件的事件不能得到响应，比如按钮按下去了弹不回来，长时间还会造成ANR，Android提供的消息处理机制就是来解决这个问题的，其中涉及的主要的类是Handler、Looper和MessageQueue。其类图如下，简单起见只列出了一些主要的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/a0e13532e9fa67407a2608cd0a801fb5.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中MessageQueue为消息队列，Looper负责创建并管理消息队列，使其进入一个循环，Handler负责发送消息以及处理消息。发送消息一般在耗时操作执行完后在工作线程进行，处理消息一般在主线程进行。以下为Android消息处理机制的时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/405232c48662550cefabd2c7b84b55f3.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;时序图中1-4步是消息队列的创建过程。&lt;/p&gt;
&lt;p&gt;5-11步为线程进入一个循环，并监听是否有消息要处理，如果没有消息，线程就会进入睡眠等待状态。&lt;/p&gt;
&lt;p&gt;12-16步为消息发送过程。&lt;/p&gt;
&lt;p&gt;17-19步为消息的处理过程。&lt;/p&gt;
&lt;p&gt;以上就是android异步消息处理的整个过程。下面结合具体应用进一步分析。&lt;/p&gt;
&lt;p&gt;下面是一段最简单的应用代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package blogxuan.bloghandler;
import android.app.Activity;
import android.app.ProgressDialog;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;

public class MainActivity extends Activity
{
	ProgressDialog progressDialog;
	Handler handler = new Handler()
	{
		@Override
		public void handleMessage(Message msg) {
			if (msg.what == 0) {
				progressDialog.cancel();
			}
		}
	};

	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Button startBtn = (Button) findViewById(R.id.button);
		progressDialog = new ProgressDialog(MainActivity.this);
		startBtn.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				progressDialog.show();
				new Thread(new Runnable() {
					@Override
					public void run() {
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        handler.sendEmptyMessage(0);
					}
				}).start();
			}
		});
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点击按钮后主界面会显示一个进度对话框，然后会新建一个线程，Thread的sleep方法模拟一个耗时操作，执行完后handler发送消息，然后在主线程中handler的handleMessage方法收到消息后关闭进度对话框。代码中可以看出只有流程图中的消息发送过程以及消息处理过程，并没看到1-11步消息队列的创建过程以及循环过程。这是因为UI线程默认会给我们进行这两个过程。在Acitvity的源码中可以找到一个叫mMainThread的ActivityThread类变量，而Looper和MessageQueue的创建就是在ActivityThread这个类的main方法中进行的，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Process.setArgV0(&amp;quot;&amp;lt;pre-initialized&amp;gt;&amp;quot;);

    Looper.prepareMainLooper();
    if (sMainThreadHandler == null) {
        sMainThreadHandler = new Handler();
    }

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &amp;quot;ActivityThread&amp;quot;));
    }

    Looper.loop();

    throw new RuntimeException(&amp;quot;Main thread loop unexpectedly exited&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然没有时序图中的Looper.prepare()方法，但其实Looper.prepareMainLooper()这个方法也会间接调用prepare()方法。一旦调用prepare()方法，便会完成Looper对象以及MessageQueue对象的创建，同时完成C++层的NativeMessageQueue和Looper的绑定，不在深入。&lt;/p&gt;
&lt;p&gt;调用Looper.prepare()只是创建消息队列的过程，调用Looper.loop()方法才能使消息队列进入一个循环过程并对消息进行监听。&lt;/p&gt;
&lt;p&gt;UI线程创建的时候自动建立了消息队列并进入循环过程，这样我们就可以在完成工作线程的耗时操作后往UI线程的消息队列发消息提示更新UI组件。&lt;/p&gt;
&lt;p&gt;但是如果我们希望一个相反的过程，也就是工作线程需要等待UI线程完成一些操作后再做一些操作，那么我们必须自己在工作线程中实现Looper和MessageQueue的创建以及循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LooperThread extends Thread {
    public Handler mHandler;

    public void run() {
        Looper.prepare();

        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // process incoming messages here
            }
        };

        Looper.loop();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是Looper源代码中的参考用例。这种用法自己暂时只用到过一次，当时项目中有个需求是实现异步数据库事务。当时开了一个子线程来调用了数据库的beginTransaction()方法，当又开了另一个线程进行数据库操作的时候发现报数据库被锁了，后来查资料发现一个完整的数据库事务必须放在一个线程执行才行，但是根据项目的需求执行数据库的操作是在UI线程发起的，因此就只能在开启事务的子线程中实现Looper和MessageQueue（线程默认是没有Looper和MessageQueue的），这样就实现了子线程也能进行消息循环监听，当UI线程需要执行数据库操作时再向子线程发送消息通知在子线程中继续进行数据库操作，就能保证数据库的操作跟开启事务是同一个子线程。&lt;/p&gt;
&lt;p&gt;Looper对象的创建还有一个概念是ThreadLocal，Looper.prepare()方法完成了Looper对象的创建，其源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void prepare() {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&amp;quot;Only one Looper may be created per thread&amp;quot;);
    }
    sThreadLocal.set(new Looper());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码中看到Looper对象创建并不像我们通常的方式new一个静态全局变量，或者是通过单例模式的方式创建，而是通过ThreadLocal对象来把这个Looper对象包含起来，ThreadLocal的源码的注释说明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implements a thread-local storage, that is, a variable for which each thread
 * has its own value. All threads share the same {@code ThreadLocal} object,
 * but each sees a different value when accessing it, and changes made by one
 * thread do not affect the other threads. The implementation supports
 * {@code null} values.
 *
 * @see java.lang.Thread
 * @author Bob Lee
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单来讲就是可以实现同一个ThreadLocal对象，在不同的线程中有不同的值，并且不同线程之间的值互不干扰，为什么需要这个东西呢，假设有两个线程都需要实现looper机制，这两个线程的Looper和MessageQueue肯定是不一样的，而且一个线程只能有一个Looper和MessageQueue，这点从上面Looper.prepare()的源码看出，当在两个线程各创建了一个Handler时，怎么保证这两个handler发的消息不会发到别的线程的消息队列中呢？这就需要handler跟各自线程的Looper和MessageQueue绑定起来，而怎么绑定呢？ 下面是Handler创建的构造函数的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Handler() {
   ...
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &amp;quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&amp;quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码可以看出是通过Looper.myLooper()；方法来进行关联的，Looper.myLooper()的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Looper myLooper() {
    return sThreadLocal.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单的一行代码就实现了绑定，而如果我们不用ThreadLocal，那么就必须提供一个全局的哈希表给Handler来查找关联的线程的Looper了，这就是ThreadLocal的好处，至于ThreadLocal为什么能实现这种效果，下面是ThreadLocal的set方法代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这个方法大致可以看出set进去的value值（Looper）和Thread对象以及this（ThreadLocal）对象关联了，而不同线程的values是不一样的，所以当调用get方法取出Looper时就可以根据不同的线程对象取出不同的值了，就不往下分析了。
以上是Looper和MessageQueue的创建以及循环过程，下面分析下消息的发送过程和处理过程。&lt;/p&gt;
&lt;p&gt;消息的发送过程通常是用handler的sendMessage方法，通过上面handler的类图可以发现还有好多类似的方法，但最终都会走导sendMessageAtTime方法，因此时序图中写的是这个方法，源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean sendMessageAtTime(Message msg, long uptimeMillis)
{
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    }
    else {
       ...
    }
    return sent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送消息过程其实就是消息入队过程，之后便会唤醒阻塞的queue.next()方法。这个方法是在Looper.loop()方法中调用的，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public static void loop() {
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&amp;quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&amp;quot;);
    }
    MessageQueue queue = me.mQueue;    
    ...
    while (true) {
        Message msg = queue.next(); // might block
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
		   ...
            msg.target.dispatchMessage(msg);
           ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;唤醒queue.next（）后就会进入消息处理过程，也就是msg.target.dispatchMessage(msg)，而msg.target其实就是handler对象，从sendMessageAtTime的源码中就可以看出来，handler.dispatchMessage的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第十行的代码就会调用到在new Handler时重写的方法。这里还有必要说下第三行的handleCallback(msg)方法：&lt;/p&gt;
&lt;p&gt;在公司的项目中经常看到一个这样的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;handler.post(new Runnable() {
    @Override
        public void run() {
        	progressDialog.cancel();
        }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;handler在创建的时候并没重写handleMessage方法，为什么可以这样在run方法中进行ui操作呢？查看handler的post源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而sendMessageDelayed方法其实最终也会调用到上面讲过的sendMessageAtTime方法，getPostMessage的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到getPostMessage构造了一个消息对象，对象的callback对象就是post方法中进行UI操作的的Runable对象，从上面dispatchMessage中源码的第三行查看handleCallback代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final void handleCallback(Message message) {
    message.callback.run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正是在这里执行了run方法的操作，因为直接调用Runable的run方法并不会创建一个线程，因此如果handler关联的是UI线程，在handler.post方法中进行UI操作是没问题的，同理不能在这里执行耗时操作。&lt;/p&gt;
&lt;p&gt;以上就是自己对于Android消息处理机制的理解，第一次认真写一篇博客，花费了快一天的时间，希望能坚持下去。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>多写一题是一题</title>
      <link>https://xuanliangdev.github.io/post/%E5%A4%9A%E5%86%99%E4%B8%80%E9%A2%98%E6%98%AF%E4%B8%80%E9%A2%98/</link>
      <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E5%A4%9A%E5%86%99%E4%B8%80%E9%A2%98%E6%98%AF%E4%B8%80%E9%A2%98/</guid>
      
        <description>&lt;h1 id=&#34;剑指offer&#34;&gt;剑指offer&lt;/h1&gt;
&lt;h5 id=&#34;1在一个二维数组中每个一维数组的长度相同每一行都按照从左到右递增的顺序排序每一列都按照从上到下递增的顺序排序请完成一个函数输入这样的一个二维数组和一个整数判断数组中是否含有该整数&#34;&gt;1、在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean Find(int target, int [][] array) {
        if (array == null || array[0] == null 
            || array.length &amp;lt;= 0 || array[0].length &amp;lt;= 0) {
            return false;
        }
        int top = 0;
        int right = array[0].length - 1;
        while (right &amp;gt;= 0 &amp;amp;&amp;amp; top &amp;lt;= array.length - 1) {
            if (array[top][right] == target) {
                return true;
            } else if (array[top][right] &amp;gt; target) {
                right--;
            } else {
                top++;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;2请实现一个函数将一个字符串中的每个空格替换成20例如当字符串为we-are-happy则经过替换之后的字符串为we20are20happy&#34;&gt;2、请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public String replaceSpace(StringBuffer str) {
        if (str == null || str.length() &amp;lt;= 0) {
            return str.toString();
        }
    	int blankCount = 0;
        for (int i = 0; i &amp;lt; str.length(); i++) {
            if (str.charAt(i) == &#39; &#39;) {
                blankCount++;
            }
        }
        char[] newString = new char[str.length() + blankCount * 2];
        int newStringIndex = newString.length - 1;
        for (int i = str.length() - 1; i &amp;gt;= 0; i--) {
            if (str.charAt(i) != &#39; &#39;) {
                newString[newStringIndex--] = str.charAt(i);
            } else {
                newString[newStringIndex--] = &#39;0&#39;;
                newString[newStringIndex--] = &#39;2&#39;;
                newString[newStringIndex--] = &#39;%&#39;;
            }
        }
        return new String(newString);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;3输入一个链表按链表从尾到头的顺序返回一个arraylist&#34;&gt;3、输入一个链表，按链表从尾到头的顺序返回一个ArrayList。&lt;/h5&gt;
&lt;p&gt;解法1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        while (listNode != null) {
            res.add(0, listNode.val);
            listNode = listNode.next;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解法2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        getListNodeVal(listNode, res);
        return res;
    }
    
    public void getListNodeVal(ListNode listNode, ArrayList&amp;lt;Integer&amp;gt; res) {
        if (listNode == null) {
            return;
        }
        getListNodeVal(listNode.next, res);
        res.add(listNode.val);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;4输入某二叉树的前序遍历和中序遍历的结果请重建出该二叉树假设输入的前序遍历和中序遍历的结果中都不含重复的数字例如输入前序遍历序列12473568和中序遍历序列47215386则重建二叉树并返回&#34;&gt;4、输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/h5&gt;
&lt;p&gt;// TO DO:&lt;/p&gt;
&lt;h5 id=&#34;5用两个栈来实现一个队列完成队列的push和pop操作-队列中的元素为int类型&#34;&gt;5、用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;Integer&amp;gt;();
    Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;Integer&amp;gt;();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;6把一个数组最开始的若干个元素搬到数组的末尾我们称之为数组的旋转输入一个非递减排序的数组的一个旋转输出旋转数组的最小元素note给出的所有元素都大于0若数组大小为0请返回0&#34;&gt;6、把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array == null || array.length == 0) {
            return 0;
        }
        int left = 0;
        int right = array.length - 1;
        while(left &amp;lt; right) {
            if (array[left] &amp;lt; array[right]) {
                return array[left];
            }
            int mid = (left + right) &amp;gt;&amp;gt;&amp;gt; 1;
            if (array[mid] &amp;gt; array[right]) {
                left = mid + 1;
            } else if (array[mid] &amp;lt; array[right]) {
                right = mid;
            } else {
                right = right - 1;
            }
        }
        return array[left];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;7大家都知道斐波那契数列现在要求输入一个整数n请你输出斐波那契数列的第n项从0开始第0项为0第1项是1nleq-39n39&#34;&gt;7、大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n\leq 39&lt;em&gt;n&lt;/em&gt;≤39&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int Fibonacci(int n) {
        if (n == 0 || n == 1) {
            return n;
        }
        int[] a = new int[n + 1];
        a[0] = 0;
        a[1] = 1;
        for (int i = 2; i &amp;lt;= n; i++) {
            a[i] = a[i - 1] + a[i - 2];
        }
        return a[n];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;8一只青蛙一次可以跳上1级台阶也可以跳上2级求该青蛙跳上一个n级的台阶总共有多少种跳法先后次序不同算不同的结果&#34;&gt;8、一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/h5&gt;
&lt;p&gt;递归&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int JumpFloor(int target) {
        if (target == 0 || target == 1 || target == 2) {
            return target;
        }
        return JumpFloor(target - 1) + JumpFloor(target - 2);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;动态规划&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int JumpFloor(int target) {
        if (target == 0 || target == 1) {
            return target;
        }
        int[] a = new int[target + 1];
        a[1] = 1;
        a[2] = 2;
        for (int i = 3; i &amp;lt;= target; i++) {
            a[i] = a[i - 1] + a[i - 2];
        }
        return a[target];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;减少空间复杂度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int JumpFloor(int target) {
        if (target == 1 || target == 2) {
            return target;
        }
        int[] a = new int[3];
        a[0] = 1;
        a[1] = 2;
        for (int i = 3; i &amp;lt;= target; i++) {
            a[2] = a[0] + a[1];
            a[0] = a[1];
            a[1] = a[2];
        }
        return a[2];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;9一只青蛙一次可以跳上1级台阶也可以跳上2级它也可以跳上n级求该青蛙跳上一个n级的台阶总共有多少种跳法&#34;&gt;9、一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int JumpFloorII(int target) {
        if (target &amp;lt;= 0) {
            return 0;
        }
        if (target == 1) {
            return 1;
        }
        return 2 * JumpFloorII(target - 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;10我们可以用21的小矩形横着或者竖着去覆盖更大的矩形请问用n个21的小矩形无重叠地覆盖一个2n的大矩形总共有多少种方法比如n3时23的矩形块有3种覆盖方法&#34;&gt;10、我们可以用2&lt;em&gt;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;/em&gt;1的小矩形无重叠地覆盖一个2&lt;em&gt;n的大矩形，总共有多少种方法？比如n=3时，2&lt;/em&gt;3的矩形块有3种覆盖方法：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int rectCover(int target) {
        if (target == 0 || target == 1) {
            return target;
        }
        int[] a = new int[target + 1];
        a[1] = 1;
        a[2] = 2;
        for (int i = 3; i &amp;lt;= target; i++) {
            a[i] = a[i - 1] + a[i - 2];
        }
        return a[target];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;11输入一个整数输出该数32位二进制表示中1的个数其中负数用补码表示&#34;&gt;11、输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while (n != 0) {
            n &amp;amp;= (n - 1);
            count++;
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;12给定一个double类型的浮点数base和int类型的整数exponent求base的exponent次方保证base和exponent不同时为0&#34;&gt;12、给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0&lt;/h5&gt;
&lt;p&gt;// TO DO:&lt;/p&gt;
&lt;h5 id=&#34;13输入一个整数数组实现一个函数来调整该数组中数字的顺序使得所有的奇数位于数组的前半部分所有的偶数位于数组的后半部分并保证奇数和奇数偶数和偶数之间的相对位置不变&#34;&gt;13、输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public void reOrderArray(int [] array) {
        ArrayList&amp;lt;Integer&amp;gt; evenList = new ArrayList&amp;lt;&amp;gt;();
        int oddIndex = -1;
        for (int i = 0; i &amp;lt; array.length; i++) {
            if (array[i] % 2 == 1) {
                oddIndex++;
                swap(array, i, oddIndex);
            } else {
                evenList.add(array[i]);
            }
        }
        for (int i = oddIndex + 1, j = 0; i &amp;lt; array.length; i++) {
            array[i] = evenList.get(j++);
        }
        
    }
    
    public void swap(int[] array, int a, int b) {
        if (a == b) {
            return;
        }
        int temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;14输入一个链表输出该链表中倒数第k个结点&#34;&gt;14、输入一个链表，输出该链表中倒数第k个结点。&lt;/h5&gt;
&lt;p&gt;两遍扫描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        int nodeCount = 0;
        ListNode scan = head;
        while (scan != null) {
            scan = scan.next;
            nodeCount++;
        }
        if (nodeCount &amp;lt; k) {
            return null;
        }
        scan = head;
        for (int i = 0; i &amp;lt; nodeCount - k; i++) {
            scan = scan.next;
        }
        return scan;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;快慢指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        ListNode fast = head;
        ListNode slow = head;
        for (int i = 0; i &amp;lt; k; i++) {
            if (fast == null) {
                return null;
            }
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;15输入一个链表反转链表后输出新链表的表头&#34;&gt;15、输入一个链表，反转链表后，输出新链表的表头。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;16输入两个单调递增的链表输出两个链表合成后的链表当然我们需要合成后的链表满足单调不减规则&#34;&gt;16、输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode head = dummy;
        while (list1 != null &amp;amp;&amp;amp; list2 != null) {
            if (list1.val &amp;lt; list2.val) {
                dummy.next = list1;
                list1 = list1.next;
            } else {
                dummy.next = list2;
                list2 = list2.next;
            }
            dummy = dummy.next;
        }
        if (list1 != null) {
            dummy.next = list1;
        }
        if (list2 != null) {
            dummy.next = list2;
        }
        return head.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }
        if (list1.val &amp;lt; list2.val) {
            list1.next = Merge(list1.next, list2);
            return list1;
        } else {
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;17输入两棵二叉树ab判断b是不是a的子结构ps我们约定空树不是任意一个树的子结构&#34;&gt;17、输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if (root2 == null || root1 == null) return false;
        return isSameTree(root1, root2) 
            || HasSubtree(root1.left, root2) 
            || HasSubtree(root1.right, root2);
    }
    
    public boolean isSameTree(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2 == null;
        }
        if (t2 == null) {
            return true;
        }
        return (t1.val == t2.val) 
            &amp;amp;&amp;amp; isSameTree(t1.left, t2.left) 
            &amp;amp;&amp;amp; isSameTree(t1.right, t2.right);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;18操作给定的二叉树将其变换为源二叉树的镜像&#34;&gt;18、操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public void Mirror(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        Mirror(root.left);
        Mirror(root.right);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;19输入一个矩阵按照从外向里以顺时针的顺序依次打印出每一个数字例如如果输入如下4-x-4矩阵-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-则依次打印出数字12348121615141395671110&#34;&gt;19、输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;20定义栈的数据结构请在该类型中实现一个能够得到栈中所含最小元素的min函数时间复杂度应为o1&#34;&gt;20、定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;21输入两个整数序列第一个序列表示栈的压入顺序请判断第二个序列是否可能为该栈的弹出顺序假设压入栈的所有数字均不相等例如序列12345是某栈的压入顺序序列45321是该压栈序列对应的一个弹出序列但43512就不可能是该压栈序列的弹出序列注意这两个序列的长度是相等的&#34;&gt;21、输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.ArrayDeque;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
      ArrayDeque&amp;lt;Integer&amp;gt; stack = new ArrayDeque&amp;lt;&amp;gt;();
        int j = 0;
        for (int i : pushA) {
            stack.push(i);
            while (!stack.isEmpty() &amp;amp;&amp;amp; stack.peek() == popA[j]) {
                stack.pop();
                j++;
            }
        }
        return stack.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;22从上往下打印出二叉树的每个节点同层节点从左至右打印&#34;&gt;22、从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.ArrayDeque;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; PrintFromTopToBottom(TreeNode root) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if (root == null) return res;
        ArrayDeque&amp;lt;TreeNode&amp;gt; queue = new ArrayDeque&amp;lt;&amp;gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i &amp;lt; size; i++) {
                TreeNode node = queue.poll();
                res.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;23输入一个整数数组判断该数组是不是某二叉搜索树的后序遍历的结果如果是则返回true否则返回false假设输入的数组的任意两个数字都互不相同&#34;&gt;23、输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;24输入一颗二叉树的根节点和一个整数按字典序打印出二叉树中结点值的和为输入整数的所有路径路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径&#34;&gt;24、输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;25输入一个复杂链表每个节点中有节点值以及两个指针一个指向下一个节点另一个特殊指针random指向一个随机节点请对此链表进行深拷贝并返回拷贝后的头结点注意输出结果中请不要返回参数中的节点引用否则判题程序会直接返回空&#34;&gt;25、输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;26输入一棵二叉搜索树将该二叉搜索树转换成一个排序的双向链表要求不能创建任何新的结点只能调整树中结点指针的指向&#34;&gt;26、输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;27输入一个字符串按字典序打印出该字符串中字符的所有排列例如输入字符串abc则按字典序打印出由字符abc所能排列出来的所有字符串abcacbbacbcacab和cba&#34;&gt;27、输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;28数组中有一个数字出现的次数超过数组长度的一半请找出这个数字例如输入一个长度为9的数组123222542由于数字2在数组中出现了5次超过数组长度的一半因此输出2如果不存在则输出0&#34;&gt;28、数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;29输入n个整数找出其中最小的k个数例如输入45162738这8个数字则最小的4个数字是1234&#34;&gt;29、输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;30输入一个整型数组数组里有正数也有负数数组中的一个或连续多个整数组成一个子数组求所有子数组的和的最大值要求时间复杂度为-on&#34;&gt;30、输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        int max = 0;
        int[] dp = new int[array.length];
        max = dp[0] = array[0];
        for (int i = 1; i &amp;lt; array.length; i++) {
            dp[i] = array[i] + (dp[i - 1] &amp;gt; 0 ? dp[i - 1] : 0);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;31求出113的整数中1出现的次数并算出1001300的整数中1出现的次数为此他特别数了一下113中包含1的数字有110111213因此共出现6次但是对于后面问题他就没辙了acmer希望你们帮帮他并把问题更加普遍化可以很快的求出任意非负整数区间中1出现的次数从1-到-n-中1出现的次数&#34;&gt;31、求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;32输入一个正整数数组把数组里所有数字拼接起来排成一个数打印能拼接出的所有数字中最小的一个例如输入数组332321则打印出这三个数字能排成的最小数字为321323&#34;&gt;32、输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;33把只包含质因子23和5的数称作丑数ugly-number例如68都是丑数但14不是因为它包含质因子7-习惯上我们把1当做是第一个丑数求按从小到大的顺序的第n个丑数&#34;&gt;33、把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;34在一个字符串0字符串长度10000全部由字母组成中找到第一个只出现一次的字符并返回它的位置-如果没有则返回--1需要区分大小写从0开始计数&#34;&gt;34、在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.HashMap;

public class Solution {
    public int FirstNotRepeatingChar(String str) {
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; str.length(); i++) {
            Character c = str.charAt(i);
            if (map.containsKey(c)) {
                map.put(c, map.get(c) + 1);
            } else {
                map.put(c, 1);
            }
        }
        for (int i = 0; i &amp;lt; str.length(); i++) {
            Character c = str.charAt(i);
            if (map.containsKey(c)) {
                if (map.get(c) == 1) {
                    return i;
                }
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;35在数组中的两个数字如果前面一个数字大于后面的数字则这两个数字组成一个逆序对输入一个数组求出这个数组中的逆序对的总数p并将p对1000000007取模的结果输出-即输出p1000000007&#34;&gt;35、在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007&lt;/h5&gt;
&lt;p&gt;对于50%50%的数据,size\leq 10^4&lt;em&gt;s&lt;strong&gt;i&lt;/strong&gt;z**e&lt;/em&gt;≤104
对于75%75%的数据,size\leq 10^5&lt;em&gt;s&lt;strong&gt;i&lt;/strong&gt;z**e&lt;/em&gt;≤105
对于100%100%的数据,size\leq 2&lt;em&gt;10^5&lt;/em&gt;s&lt;strong&gt;i&lt;/strong&gt;z**e*≤2∗105&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;36输入两个链表找出它们的第一个公共结点注意因为传入数据是链表所以错误测试数据的提示是用其他方式显示的保证传入数据是正确的&#34;&gt;36、输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode p1 = pHead1;
        ListNode p2 = pHead2;
         while (p1 != p2) {
              p1 = p1 == null ? pHead2 : p1.next;
              p2 = p2 == null ? pHead1 : p2.next;
         }
        return p1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;37统计一个数字在升序数组中出现的次数&#34;&gt;37、统计一个数字在升序数组中出现的次数。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;38输入一棵二叉树求该树的深度从根结点到叶结点依次经过的结点含根叶结点形成树的一条路径最长路径的长度为树的深度&#34;&gt;38、输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;39输入一棵二叉树判断该二叉树是否是平衡二叉树&#34;&gt;39、输入一棵二叉树，判断该二叉树是否是平衡二叉树。&lt;/h5&gt;
&lt;p&gt;在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        int left = getHeight(root.left);
        int right = getHeight(root.right);
        return Math.abs(left - right) &amp;lt; 2 
            &amp;amp;&amp;amp; IsBalanced_Solution(root.left) 
            &amp;amp;&amp;amp; IsBalanced_Solution(root.right);
    }
    
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(getHeight(root.left), getHeight(root.right));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;剪枝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return getDepth(root) != -1;
    }
    
    public int getDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = getDepth(root.left);
        if (left == -1) {
            return -1;
        }
        int right = getDepth(root.right);
        if (right == -1) {
            return -1;
        }
        return Math.abs(left - right) &amp;lt; 2 ? Math.max(left, right) + 1 : -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;40一个整型数组里除了两个数字之外其他的数字都出现了两次请写程序找出这两个只出现一次的数字&#34;&gt;40、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        if(array.length == 2){
            num1[0] = array[0];
            num2[0] = array[1];
            return;
        }
        int or = 0;
        for (int i = 0; i &amp;lt; array.length; i++) {
            or ^= array[i];
        }
        
        int index = 0;
        while (((or &amp;amp; 1) == 0) &amp;amp;&amp;amp; index &amp;lt; 32) {
            or &amp;gt;&amp;gt;= 1;
            index++;
        }
        
        for (int i = 0; i &amp;lt; array.length; i++) {
            if (isMatch(array[i], index)) {
                num1[0] ^= array[i];
            } else {
                num2[0] ^= array[i];
            }
        }
    }
    
    public boolean isMatch(int num, int index) {
        return ((num &amp;gt;&amp;gt;= index) &amp;amp; 1) == 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;41小明很喜欢数学有一天他在做数学作业时要求计算出916的和他马上就写出了正确答案是100但是他并不满足于此他在想究竟有多少种连续的正数序列的和为100至少包括两个数没多久他就得到另一组连续正数和为100的序列1819202122现在把问题交给你你能不能也很快的找出所有和为s的连续正数序列-good-luck&#34;&gt;41、小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;42输入一个递增排序的数组和一个数字s在数组中查找两个数使得他们的和正好是s如果有多对数字的和等于s输出两个数的乘积最小的&#34;&gt;42、输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; FindNumbersWithSum(int [] array,int sum) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if (array == null || array.length == 0) return res; 
        int l = 0;
        int h = array.length - 1;
        while (l &amp;lt;= h) {
            if (array[l] + array[h] == sum) {
                res.add(array[l]);
                res.add(array[h]);
                return res;
            } else if (array[l] + array[h] &amp;gt; sum) {
                h--;
            } else {
                l++;
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;43汇编语言中有一种移位指令叫做循环左移rol现在有个简单的任务就是用字符串模拟这个指令的运算结果对于一个给定的字符序列s请你把其循环左移k位后的序列输出例如字符序列sabcxyzdef要求输出循环左移3位后的结果即xyzdefabc是不是很简单ok搞定它&#34;&gt;43、汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public String LeftRotateString(String str,int n) {
        if (str == null || str.length() == 0) return str;
        if (n &amp;gt; str.length()) {
            n %= str.length();
        }
        char[] array = str.toCharArray();
        revert(array, 0, n - 1);
        revert(array, n, array.length - 1);
        revert(array, 0, array.length - 1);
        return new String(array);
        
    }
    
    public void revert(char[] array, int l, int r) {
        while (l &amp;lt; r) {
            char t = array[l];
            array[l++] = array[r];
            array[r--] = t;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;44牛客最近来了一个新员工fish每天早晨总是会拿着一本英文杂志写些句子在本子上同事cat对fish写的内容颇感兴趣有一天他向fish借来翻看但却读不懂它的意思例如student-a-am-i后来才意识到这家伙原来把句子单词的顺序翻转了正确的句子应该是i-am-a-studentcat对一一的翻转这些单词顺序可不在行你能帮助他么&#34;&gt;44、牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;45ll今天心情特别好因为他去买了一副扑克牌发现里面居然有2个大王2个小王一副牌原本是54张_他随机从中抽出了5张牌想测测自己的手气看看能不能抽到顺子如果抽到的话他决定去买体育彩票嘿嘿红心a黑桃3小王大王方片5oh-my-god不是顺子ll不高兴了他想了想决定大小-王可以看成任何数字并且a看作1j为11q为12k为13上面的5张牌就可以变成12345大小王分别看作2和4so-luckyll决定去买体育彩票啦-现在要求你使用这幅牌模拟上面的过程然后告诉我们ll的运气如何-如果牌能组成顺子就输出true否则就输出false为了方便起见你可以认为大小王是0&#34;&gt;45、LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&amp;hellip;他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子&amp;hellip;..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;46每年六一儿童节牛客都会准备一些小礼物去看望孤儿院的小朋友今年亦是如此hf作为牛客的资深元老自然也准备了一些小游戏其中有个游戏是这样的首先让小朋友们围成一个大圈然后他随机指定一个数m让编号为0的小朋友开始报数每次喊到m-1的那个小朋友要出列唱首歌然后可以在礼品箱中任意的挑选礼物并且不再回到圈中从他的下一个小朋友开始继续0m-1报数这样下去直到剩下最后一个小朋友可以不用表演并且拿到牛客名贵的名侦探柯南典藏版名额有限哦_请你试着想下哪个小朋友会得到这份礼品呢注小朋友的编号是从0到n-1如果没有小朋友请返回-1&#34;&gt;46、每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0&amp;hellip;m-1报数&amp;hellip;.这样下去&amp;hellip;.直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)如果没有小朋友，请返回-1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;47求123n要求不能使用乘除法forwhileifelseswitchcase等关键字及条件判断语句abc&#34;&gt;47、求1+2+3+&amp;hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;48写一个函数求两个整数之和要求在函数体内不得使用-四则运算符号&#34;&gt;48、写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;49将一个字符串转换成一个整数要求不能使用字符串转换整数的库函数-数值为0或者字符串不是一个合法的数值则返回0&#34;&gt;49、将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;50在一个长度为n的数组里的所有数字都在0到n-1的范围内-数组中某些数字是重复的但不知道有几个数字是重复的也不知道每个数字重复几次请找出数组中第一个重复的数字-例如如果输入长度为7的数组2310253那么对应的输出是第一个重复的数字2&#34;&gt;50、在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/h5&gt;
&lt;h5 id=&#34;返回描述&#34;&gt;返回描述：&lt;/h5&gt;
&lt;p&gt;如果数组中有重复的数字，函数返回true，否则返回false。&lt;/p&gt;
&lt;p&gt;如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;51给定一个数组a01n-1请构建一个数组b01n-1其中b中的元素bia0a1ai-1ai1an-1不能使用除法注意规定b0--a1--a2----an-1bn-1--a0--a1----an-2&#34;&gt;51、给定一个数组A[0,1,&amp;hellip;,n-1],请构建一个数组B[0,1,&amp;hellip;,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1]&lt;/em&gt;&amp;hellip;*A[i-1]&lt;em&gt;A[i+1]&lt;/em&gt;&amp;hellip;*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * &amp;hellip; * A[n-1]，B[n-1] = A[0] * A[1] * &amp;hellip; * A[n-2];）&lt;/h5&gt;
&lt;p&gt;对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;52请实现一个函数用来匹配包括和的正则表达式模式中的字符表示任意一个字符而表示它前面的字符可以出现任意次包含0次-在本题中匹配是指字符串的所有字符匹配整个模式例如字符串aaa与模式aa和abaca匹配但是与aaa和aba均不匹配&#34;&gt;52、请实现一个函数用来匹配包括&amp;rsquo;.&amp;lsquo;和&amp;rsquo;&lt;em&gt;&amp;lsquo;的正则表达式。模式中的字符&amp;rsquo;.&amp;lsquo;表示任意一个字符，而&amp;rsquo;&lt;/em&gt;&amp;lsquo;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;quot;aaa&amp;quot;与模式&amp;quot;a.a&amp;quot;和&amp;quot;ab&lt;em&gt;ac&lt;/em&gt;a&amp;quot;匹配，但是与&amp;quot;aa.a&amp;quot;和&amp;quot;ab*a&amp;quot;均不匹配&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;53请实现一个函数用来判断字符串是否表示数值包括整数和小数例如字符串1005e2-12331416和-1e-16都表示数值-但是12e1a314123-5和12e43都不是&#34;&gt;53、请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&amp;quot;+100&amp;rdquo;,&amp;ldquo;5e2&amp;rdquo;,&amp;quot;-123&amp;rdquo;,&amp;ldquo;3.1416&amp;quot;和&amp;rdquo;-1E-16&amp;quot;都表示数值。 但是&amp;quot;12e&amp;rdquo;,&amp;ldquo;1a3.14&amp;rdquo;,&amp;ldquo;1.2.3&amp;rdquo;,&amp;ldquo;+-5&amp;quot;和&amp;quot;12e+4.3&amp;quot;都不是&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;54请实现一个函数用来找出字符流中第一个只出现一次的字符例如当从字符流中只读出前两个字符go时第一个只出现一次的字符是g当从该字符流中读出前六个字符google时第一个只出现一次的字符是l&#34;&gt;54、请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;quot;go&amp;quot;时，第一个只出现一次的字符是&amp;quot;g&amp;rdquo;。当从该字符流中读出前六个字符“google&amp;quot;时，第一个只出现一次的字符是&amp;quot;l&amp;rdquo;。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;55给一个链表若其中包含环请找出该链表的环的入口结点否则输出null&#34;&gt;55、给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        ListNode fast = pHead;
        ListNode slow = pHead;
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                fast = pHead;
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;56在一个排序的链表中存在重复的结点请删除该链表中重复的结点重复的结点不保留返回链表头指针-例如链表1-2-3-3-4-4-5-处理后为-1-2-5&#34;&gt;56、在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;57给定一个二叉树和其中的一个结点请找出中序遍历顺序的下一个结点并且返回注意树中的结点不仅包含左右子结点同时包含指向父结点的指针&#34;&gt;57、给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;58请实现一个函数用来判断一棵二叉树是不是对称的注意如果一个二叉树同此二叉树的镜像是同样的定义其为对称的&#34;&gt;58、请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;59请实现一个函数按照之字形打印二叉树即第一行按照从左到右的顺序打印第二层按照从右至左的顺序打印第三行按照从左到右的顺序打印其他行以此类推&#34;&gt;59、请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;60从上到下按层打印二叉树同一层结点从左至右输出每一层输出一行&#34;&gt;60、从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;61请实现两个函数分别用来序列化和反序列化二叉树&#34;&gt;61、请实现两个函数，分别用来序列化和反序列化二叉树&lt;/h5&gt;
&lt;p&gt;二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。&lt;/p&gt;
&lt;p&gt;二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。&lt;/p&gt;
&lt;p&gt;例如，我们可以把一个只有根节点为1的二叉树序列化为&amp;quot;1,&amp;quot;，然后通过自己的函数来解析回这个二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;62给定一棵二叉搜索树请找出其中的第k小的treenode结点&#34;&gt;62、给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;63如何得到一个数据流中的中位数如果从数据流中读出奇数个数值那么中位数就是所有数值排序之后位于中间的数值如果从数据流中读出偶数个数值那么中位数就是所有数值排序之后中间两个数的平均值我们使用insert方法读取数据流使用getmedian方法获取当前读取数据的中位数&#34;&gt;63、如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;64给定一个数组和滑动窗口的大小找出所有滑动窗口里数值的最大值例如如果输入数组23426251及滑动窗口的大小3那么一共存在6个滑动窗口他们的最大值分别为446665-针对数组23426251的滑动窗口有以下6个-23426251-23426251-23426251-23426251-23426251-23426251&#34;&gt;64、给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/h5&gt;
&lt;p&gt;窗口大于数组长度的时候，返回空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;65请设计一个函数用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径路径可以从矩阵中的任意一个格子开始每一步可以在矩阵中向左向右向上向下移动一个格子如果一条路径经过了矩阵中的某一个格子则该路径不能再进入该格子-例如-beginbmatrix-a--b--c-e--s--f--c--s--a--d--e-e-endbmatrixquadasabfdcceese-矩阵中包含一条字符串bcced的路径但是矩阵中不包含abcb路径因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后路径不能再次进入该格子&#34;&gt;65、请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 \begin{bmatrix} a &amp;amp; b &amp;amp; c &amp;amp;e \ s &amp;amp; f &amp;amp; c &amp;amp; s \ a &amp;amp; d &amp;amp; e&amp;amp; e\ \end{bmatrix}\quad⎣⎡&lt;em&gt;a&lt;strong&gt;s&lt;/strong&gt;a&lt;strong&gt;b&lt;/strong&gt;f&lt;strong&gt;d&lt;/strong&gt;c&lt;strong&gt;c&lt;/strong&gt;e&lt;strong&gt;e&lt;/strong&gt;s**e&lt;/em&gt;⎦⎤ 矩阵中包含一条字符串&amp;quot;bcced&amp;quot;的路径，但是矩阵中不包含&amp;quot;abcb&amp;quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;66地上有一个m行和n列的方格一个机器人从坐标00的格子开始移动每一次只能向左右上下四个方向移动一格但是不能进入行坐标和列坐标的数位之和大于k的格子-例如当k为18时机器人能够进入方格3537因为3537--18但是它不能进入方格3538因为3538--19请问该机器人能够达到多少个格子&#34;&gt;66、地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;67给你一根长度为n的绳子请把绳子剪成整数长的m段mn都是整数n1并且m1mn每段绳子的长度记为k1km请问k1xxkm可能的最大乘积是多少例如当绳子的长度是8时我们把它剪成长度分别为233的三段此时得到的最大乘积是18&#34;&gt;67、给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1，m&amp;lt;=n），每段绳子的长度记为k[1],&amp;hellip;,k[m]。请问k[1]x&amp;hellip;xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;leetcode&#34;&gt;leetcode&lt;/h1&gt;
&lt;h3 id=&#34;1数组&#34;&gt;1、数组&lt;/h3&gt;
&lt;h3 id=&#34;2链表&#34;&gt;2、链表&lt;/h3&gt;
&lt;h3 id=&#34;3栈&#34;&gt;3、栈&lt;/h3&gt;
&lt;h3 id=&#34;4队列&#34;&gt;4、队列&lt;/h3&gt;
&lt;h3 id=&#34;5二叉树&#34;&gt;5、二叉树&lt;/h3&gt;
</description>
      
    </item>
    
  </channel>
</rss>
