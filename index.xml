<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xuanliang</title>
    <link>https://xuanliangdev.github.io/</link>
    <description>Recent content on xuanliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 12 Dec 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://xuanliangdev.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://xuanliangdev.github.io/about/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/about/</guid>
      
        <description>&lt;h3 id=&#34;小米android程序员&#34;&gt;小米android程序员&lt;/h3&gt;
&lt;p&gt;搬砖工&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>一次MIUI桌面编辑模式焦点浏览顺序错乱分析</title>
      <link>https://xuanliangdev.github.io/post/miui%E6%A1%8C%E9%9D%A2%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E7%84%A6%E7%82%B9%E9%A1%BA%E5%BA%8F%E9%94%99%E4%B9%B1%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/miui%E6%A1%8C%E9%9D%A2%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E7%84%A6%E7%82%B9%E9%A1%BA%E5%BA%8F%E9%94%99%E4%B9%B1%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;h2 id=&#34;一个miui桌面编辑模式焦点浏览顺序错乱的问题分析&#34;&gt;一个MIUI桌面编辑模式焦点浏览顺序错乱的问题分析&lt;/h2&gt;
&lt;p&gt;开启无障碍（talkback）模式，桌面编辑模式下右滑切换各个应用的launcher图标焦点时顺序错乱，没有按照正常的从左到右，从上到下顺序。&lt;/p&gt;
&lt;p&gt;此问题分析难点是由于无障碍模式涉及到talkback进程，系统进程，以及焦点所在的应用进程，无法确定焦点的顺序是哪个进程决定的，因此只能从talkback进程入手进行分析，调试切换焦点时talkback的执行逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Window could have its content views hierarchy. Views in that hierarchy could be traversed one
 * after another. Every view inside that hierarchy could change its natural traverse order by
 * setting traversal before/after view. See {@link android.view.View.getTraversalBefore()}, {@link
 * android.view.View.getTraversalAfter()}.
 *
 * &amp;lt;p&amp;gt;This strategy considers changes in the traverse order according to after/before view movements
 */
@SuppressWarnings(&amp;quot;JavadocReference&amp;quot;)
public class OrderedTraversalStrategy implements TraversalStrategy {

  private @Nullable AccessibilityNodeInfoCompat focusNext(AccessibilityNodeInfoCompat node) {
    AccessibilityNodeInfoCompat rootNode = AccessibilityNodeInfoCompat.obtain(node);
    AccessibilityNodeInfoCompat targetNode;
    try {
      targetNode = mController.findNext(rootNode);
    } finally {
      AccessibilityNodeInfoUtils.recycleNodes(rootNode);
    }

    return targetNode;
  }
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调试发现talkback切换焦点时会走focusNext上面的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderedTraversalController {

  public @Nullable AccessibilityNodeInfoCompat findNext(AccessibilityNodeInfoCompat node) {
    WorkingTree tree = mNodeTreeMap.get(node);
    if (tree == null) {
      LogUtils.w(TAG, &amp;quot;findNext(), can&#39;t find WorkingTree for AccessibilityNodeInfo&amp;quot;);
      return null;
    }

    WorkingTree nextTree = tree.getNext();
    if (nextTree != null) {
      return AccessibilityNodeInfoCompat.obtain(nextTree.getNode());
    }

    return null;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现直接从WorkingTree里取下一个节点了，此时的节点已经是乱的了，所以再看WorkingTree的构建过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderedTraversalController {

/**
   * before start next traversal node search the controller must be initialized. The initialisation
   * step includes traversal through all accessibility nodes hierarchy to collect information about
   * traversal order of separate subtrees and moving subtries that has custom befor/after traverse
   * view order
   *
   * @param compatRoot - accessibility node that serves as root node for tree hierarchy the
   *     controller works with
   * @param includeChildrenOfNodesWithWebActions whether to calculator order for nodes that support
   *     web actions. Although TalkBack uses the naviagation order specified by the nodes, Switch
   *     Access needs to know about all nodes at the time the tree is being created.
   */
  public void initOrder(
      AccessibilityNodeInfoCompat compatRoot, boolean includeChildrenOfNodesWithWebActions) {
...
    mTree =
        createWorkingTree(
            AccessibilityNodeInfoCompat.obtain(compatRoot),
            null,
            boundsCalculator,
            includeChildrenOfNodesWithWebActions);
    reorderTree();
  }

  /**
   * Creates tree that reproduces AccessibilityNodeInfoCompat tree hierarchy
   *
   * @param rootNode root node that is starting point for tree reproduction
   * @param parent parent WorkingTree node for subtree that would be returned in this method
   * @param includeChildrenOfNodesWithWebActions whether to calculator order for nodes that support
   *     web actions. Although TalkBack uses the naviagation order specified by the nodes, Switch
   *     Access needs to know about all nodes at the time the tree is being created.
   * @return subtree that reproduces accessibility node hierarchy
   */
  private @Nullable WorkingTree createWorkingTree(
      AccessibilityNodeInfoCompat rootNode,
      @Nullable WorkingTree parent,
      NodeCachedBoundsCalculator boundsCalculator,
      boolean includeChildrenOfNodesWithWebActions) {
   ....

    WorkingTree tree = new WorkingTree(rootNode, parent);
    mNodeTreeMap.put(rootNode, tree);

....
    ReorderedChildrenIterator iterator =
        ReorderedChildrenIterator.createAscendingIterator(rootNode, boundsCalculator);
    while (iterator != null &amp;amp;&amp;amp; iterator.hasNext()) {
      AccessibilityNodeInfoCompat child = iterator.next();
      WorkingTree childSubTree =
          createWorkingTree(child, tree, boundsCalculator, includeChildrenOfNodesWithWebActions);
      if (childSubTree != null) {
        tree.addChild(childSubTree);
      }
    }

    if (iterator != null) {
      iterator.recycle();
    }
    return tree;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面值得注意的是ReorderedChildrenIterator&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Children nodes iterator that iterates its children according the order of AccessibilityNodeInfo
 * hierarchy. But for nodes that are not considered to be focused according to
 * AccessibilityNodeInfoUtils.shouldFocusNode() rules we calculate new bounds that is minimum
 * rectangle that contains all focusable children nodes. If that rectangle differs from real node
 * bounds that node is reordered according needSwapNodeOrder() logic and could be traversed later.
 *
 * &amp;lt;p&amp;gt;This class obtains new instances of AccessibilityNodeCompat. Call recycle to recycle those
 * instances. Do not use the iterator once it&#39;s been recycled.
 */
public class ReorderedChildrenIterator implements Iterator&amp;lt;AccessibilityNodeInfoCompat&amp;gt; {

  public static ReorderedChildrenIterator createAscendingIterator(
      AccessibilityNodeInfoCompat parent) {
    return createAscendingIterator(parent, null);
  }
  
    private ReorderedChildrenIterator(
      AccessibilityNodeInfoCompat parent,
      boolean isAscending,
      @Nullable NodeCachedBoundsCalculator boundsCalculator) {
    ...
    init(mParent);
...
  }
  
    private void init(AccessibilityNodeInfoCompat node) {
    fillNodesFromParent();
    if (!WebInterfaceUtils.isWebContainer(node) &amp;amp;&amp;amp; needReordering(mNodes)) {
      reorder(mNodes);
    }
  }
  
  private void fillNodesFromParent() {
    int count = mParent.getChildCount();
    for (int i = 0; i &amp;lt; count; i++) {
      AccessibilityNodeInfoCompat node = mParent.getChild(i);
      if (node != null) {
        mNodes.add(node);
      }
    }
  }
  
    private void reorder(List&amp;lt;AccessibilityNodeInfoCompat&amp;gt; nodes) {
    if (nodes == null || nodes.size() == 1) {
      return;
    }

    int size = nodes.size();
    AccessibilityNodeInfoCompat[] nodeArray = new AccessibilityNodeInfoCompat[size];
    nodes.toArray(nodeArray);

    int currentIndex = size - 2;
    while (currentIndex &amp;gt;= 0) {
      AccessibilityNodeInfoCompat currentNode = nodeArray[currentIndex];
      if (mBoundsCalculator.usesChildrenBounds(currentNode)) {
        moveNodeIfNecessary(nodeArray, currentIndex);
      }

      currentIndex--;
    }

    nodes.clear();
    nodes.addAll(Arrays.asList(nodeArray));
  }
  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调试到reorder函数，发现只是简单把nodes转换为了Array，没有做什么特殊排序，而且nodes里各个焦点的顺序也是错乱的顺序，所以还得找这个nodes的来源才能得到顺序是在哪里排的。猜测从桌面应用中取到viewGroup时，子view顺序就已经定了。由于无障碍焦点的信息会通过桌面进程（com.miui.home）经由SystemProcess进程传递给talkback应用，因此直接调试桌面进程,&lt;/p&gt;
&lt;p&gt;在AccessibilityNodeInfo的addChild方法打断点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AccessibilityNodeInfo implements Parcelable {

    public void addChild(View child) {
        addChildInternal(child, AccessibilityNodeProvider.HOST_VIEW_ID, true);
    }
    
    public void addChildUnchecked(View child) {
        addChildInternal(child, AccessibilityNodeProvider.HOST_VIEW_ID, false);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现AccessibilityNodeInfo的addChildUnchecked方法ViewGroup会调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class ViewGroup extends View implements ViewParent, ViewManager {

    public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info) {
        super.onInitializeAccessibilityNodeInfoInternal(info);
。。。
        if (mAttachInfo != null) {
            final ArrayList&amp;lt;View&amp;gt; childrenForAccessibility = mAttachInfo.mTempArrayList;
            childrenForAccessibility.clear();
            addChildrenForAccessibility(childrenForAccessibility);
            final int childrenForAccessibilityCount = childrenForAccessibility.size();
            for (int i = 0; i &amp;lt; childrenForAccessibilityCount; i++) {
                final View child = childrenForAccessibility.get(i);
                info.addChildUnchecked(child);
            }
            childrenForAccessibility.clear();
        }
。。。
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;断点到addChildrenForAccessibility发现mTempArrayList的顺序已经是错乱的顺序了，所以要继续找mTempArrayList是怎么排序的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void addChildrenForAccessibility(ArrayList&amp;lt;View&amp;gt; outChildren) {
。。。
    ChildListForAccessibility children = ChildListForAccessibility.obtain(this, true);
    try {
        final int childrenCount = children.getChildCount();
        for (int i = 0; i &amp;lt; childrenCount; i++) {
            View child = children.getChildAt(i);
            if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE) {
                if (child.includeForAccessibility()) {
                    outChildren.add(child);
                } else {
                    child.addChildrenForAccessibility(outChildren);
                }
            }
        }
    } 。。。
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;static class ChildListForAccessibility {

        public static ChildListForAccessibility obtain(ViewGroup parent, boolean sort) {
            ChildListForAccessibility list = sPool.acquire();
            if (list == null) {
                list = new ChildListForAccessibility();
            }
            list.init(parent, sort);
            return list;
        }
        
        private void init(ViewGroup parent, boolean sort) {
            ArrayList&amp;lt;View&amp;gt; children = mChildren;
            final int childCount = parent.getChildCount();
            for (int i = 0; i &amp;lt; childCount; i++) {
                View child = parent.getChildAt(i);
                children.add(child);
            }
            if (sort) {
                ArrayList&amp;lt;ViewLocationHolder&amp;gt; holders = mHolders;
                for (int i = 0; i &amp;lt; childCount; i++) {
                    View child = children.get(i);
                    ViewLocationHolder holder = ViewLocationHolder.obtain(parent, child);
                    holders.add(holder);
                }
                sort(holders);
                for (int i = 0; i &amp;lt; childCount; i++) {
                    ViewLocationHolder holder = holders.get(i);
                    children.set(i, holder.mView);
                    holder.recycle();
                }
                holders.clear();
            }
        }
        
       private void sort(ArrayList&amp;lt;ViewLocationHolder&amp;gt; holders) {
            // This is gross but the least risky solution. The current comparison
            // strategy breaks transitivity but produces very good results. Coming
            // up with a new strategy requires time which we do not have, so ...
            try {
                ViewLocationHolder.setComparisonStrategy(
                        ViewLocationHolder.COMPARISON_STRATEGY_STRIPE);
                Collections.sort(holders);
            } 。。。
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最终调试发现sort(holders)前顺序虽然也是乱的，但是并不是焦点滑动的错乱顺序，调用sort后才是焦点滑动的错乱顺序，Collections.sort是针对的ViewLocationHolder，进一步查看ViewLocationHolder的compareTo方法，得到结果，无障碍焦点的排序大致是根据焦点的上下左右边距进行对比，首先比较上边界和下边界，如果一个view的焦点下边界比另一个view焦点的上边界高，那么前者顺序优先，否则就根据左右边界比较，靠左的优先。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Pooled class that holds a View and its location with respect to
 * a specified root. This enables sorting of views based on their
 * coordinates without recomputing the position relative to the root
 * on every comparison.
 */
static class ViewLocationHolder implements Comparable&amp;lt;ViewLocationHolder&amp;gt; {

        @Override
        public int compareTo(ViewLocationHolder another) {
。。。。

            int boundsResult = compareBoundsOfTree(this, another);
            if (boundsResult != 0) {
                return boundsResult;
            }
。。。
            return mView.getAccessibilityViewId() - another.mView.getAccessibilityViewId();
        }
        
        /**
         * Compare two views based on their bounds. Use the bounds of their children to break ties.
         *
         * @param holder1 Holder of first view to compare
         * @param holder2 Holder of second view to compare. Must have the same root as holder1.
         * @return The compare result, with equality if no good comparison was found.
         */
        private static int compareBoundsOfTree(
                ViewLocationHolder holder1, ViewLocationHolder holder2) {
            if (sComparisonStrategy == COMPARISON_STRATEGY_STRIPE) {
                // First is above second.
                if (holder1.mLocation.bottom - holder2.mLocation.top &amp;lt;= 0) {
                    return -1;
                }
                // First is below second.
                if (holder1.mLocation.top - holder2.mLocation.bottom &amp;gt;= 0) {
                    return 1;
                }
            }

            // We are ordering left-to-right, top-to-bottom.
            if (holder1.mLayoutDirection == LAYOUT_DIRECTION_LTR) {
                final int leftDifference = holder1.mLocation.left - holder2.mLocation.left;
                if (leftDifference != 0) {
                    return leftDifference;
                }
            } else { // RTL
                final int rightDifference = holder1.mLocation.right - holder2.mLocation.right;
                if (rightDifference != 0) {
                    return -rightDifference;
                }
            }
            // We are ordering left-to-right, top-to-bottom.
            final int topDifference = holder1.mLocation.top - holder2.mLocation.top;
            if (topDifference != 0) {
                return topDifference;
            }
            // Break tie by height.
            final int heightDiference = holder1.mLocation.height() - holder2.mLocation.height();
            if (heightDiference != 0) {
                return -heightDiference;
            }
            // Break tie by width.
            final int widthDifference = holder1.mLocation.width() - holder2.mLocation.width();
            if (widthDifference != 0) {
                return -widthDifference;
            }

            // Find a child of each view with different screen bounds.
            final Rect view1Bounds = new Rect();
            final Rect view2Bounds = new Rect();
            final Rect tempRect = new Rect();
            holder1.mView.getBoundsOnScreen(view1Bounds, true);
            holder2.mView.getBoundsOnScreen(view2Bounds, true);
            final View child1 = holder1.mView.findViewByPredicateTraversal((view) -&amp;gt; {
                view.getBoundsOnScreen(tempRect, true);
                return !tempRect.equals(view1Bounds);
            }, null);
            final View child2 = holder2.mView.findViewByPredicateTraversal((view) -&amp;gt; {
                view.getBoundsOnScreen(tempRect, true);
                return !tempRect.equals(view2Bounds);
            }, null);


            // Compare the children recursively
            if ((child1 != null) &amp;amp;&amp;amp; (child2 != null)) {
                final ViewLocationHolder childHolder1 =
                        ViewLocationHolder.obtain(holder1.mRoot, child1);
                final ViewLocationHolder childHolder2 =
                        ViewLocationHolder.obtain(holder1.mRoot, child2);
                return compareBoundsOfTree(childHolder1, childHolder2);
            }

            // If only one has a child, use that one
            if (child1 != null) {
                return 1;
            }

            if (child2 != null) {
                return -1;
            }

            // Give up
            return 0;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;分析结果无障碍焦点的顺序定义在viewgroup中在该问题中也就是桌面编辑模式的自定义view中最终把该问题转交给了miui桌面的同事处理了后面相关同学分析结果是因为桌面编辑模式下桌面图标行与行之间的图标的view有重叠导致的问题&#34;&gt;分析结果：无障碍焦点的顺序定义在ViewGroup中，在该问题中也就是桌面编辑模式的自定义View中，最终把该问题转交给了MIUI桌面的同事处理了，后面相关同学分析结果是因为桌面编辑模式下，桌面图标行与行之间的图标的View有重叠导致的问题。&lt;/h5&gt;
</description>
      
    </item>
    
    <item>
      <title>一次列表卡顿分析</title>
      <link>https://xuanliangdev.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;内存专项测试问题发现：小米闻声第一版时自测发现，当连续识别时间过长超过半小时，界面列表滑动出现明显卡顿，重启应用后卡顿不复现。&lt;/p&gt;
&lt;h2 id=&#34;1问题定位&#34;&gt;1、问题定位&lt;/h2&gt;
&lt;p&gt;卡顿分析工具：&lt;/p&gt;
&lt;p&gt;1、开发者选项-GPU呈现模式分析（或者叫HWUI呈现模式分析）&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/profile/inspect-gpu-rendering?hl=zh-cn&#34;&gt;https://developer.android.com/studio/profile/inspect-gpu-rendering?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/topic/performance/rendering/profile-gpu&#34;&gt;https://developer.android.com/topic/performance/rendering/profile-gpu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpurendering.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;开发者选项开启GPU呈现分析，卡顿产生后可以明显看出来，每个竖条表示一帧渲染时间，很多都超过了水平线16ms，正常流畅情况下是如下图这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpurenderingnormal.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上这个图只能帮助我们大概定位卡顿的位置，为绿色部分。根据google开发文档&lt;/p&gt;
&lt;p&gt;深蓝区域为绘制流程，往前一个浅绿区域为测量/布局流程，再往前为动画流程。这个工具并不能帮助我们定位到具体的代码段。只是大致的一个范围&lt;/p&gt;
&lt;p&gt;2、Android Studio工具CPU Profiler&lt;/p&gt;
&lt;p&gt;参考资料：https://developer.android.google.cn/studio/profile/cpu-profiler&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/gpuprofile.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2原理分析&#34;&gt;2、原理分析&lt;/h2&gt;
&lt;h3 id=&#34;21-android刷新机制&#34;&gt;2.1 Android刷新机制&lt;/h3&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://hukai.me/android-performance-patterns/&#34;&gt;http://hukai.me/android-performance-patterns/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://hukai.me/android-performance-render/&#34;&gt;http://hukai.me/android-performance-render/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/dasusu/p/8311324.html&#34;&gt;https://www.cnblogs.com/dasusu/p/8311324.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gityuan.com/2017/02/25/choreographer/&#34;&gt;http://gityuan.com/2017/02/25/choreographer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VSYN&lt;/p&gt;
&lt;p&gt;Refresh rate:一秒内刷新屏幕次数&lt;/p&gt;
&lt;p&gt;Frame rate:gpu一秒内操作的帧数&lt;/p&gt;
&lt;p&gt;卡顿原因：大部分屏幕刷新率时60Hz，如果1000/60=16.67ms内没办法处理一帧任务，那么就会发生丢帧，也就是卡顿。&lt;/p&gt;
&lt;p&gt;cpu负责Measure、Layout、Record、Excecute的计算操作，GPU负责rasterization（栅格化）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/vsync.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-recyclerview源码分析&#34;&gt;2.2 RecyclerView源码分析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weishenhong/article/details/81150172&#34;&gt;https://blog.csdn.net/weishenhong/article/details/81150172&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/crazy_everyday_xrp/article/details/70344638?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&#34;&gt;https://blog.csdn.net/crazy_everyday_xrp/article/details/70344638?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/google-developers/recyclerview-prefetch-c2f269075710&#34;&gt;https://medium.com/google-developers/recyclerview-prefetch-c2f269075710&lt;/a&gt;（需要科学上网）&lt;/p&gt;
&lt;p&gt;recyclerview测量时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/renderinganalysis/recyclerviewmesure.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fragment机制原理溯源</title>
      <link>https://xuanliangdev.github.io/post/fragment%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/fragment%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;1概述fragment机制&#34;&gt;1、概述Fragment机制&lt;/h2&gt;
&lt;p&gt;1、Android3.0引入，可以给大屏幕动态界面设计提供支持。&lt;/p&gt;
&lt;p&gt;2、现在主要用在一个页面内嵌多个Tab时使用。&lt;/p&gt;
&lt;h2 id=&#34;2fragment机制原理总结&#34;&gt;2、Fragment机制原理总结&lt;/h2&gt;
&lt;p&gt;当前Android最新版本已经是R，Fragment机制也增加了不少改动，复杂了很多，为了单纯了解核心机制，最快的方法可以直接从最初的代码入手。&lt;/p&gt;
&lt;h4 id=&#34;初版fragment机制三个核心类&#34;&gt;初版Fragment机制，三个核心类：&lt;/h4&gt;
&lt;h5 id=&#34;1fragmentmanager&#34;&gt;1）FragmentManager：&lt;/h5&gt;
&lt;p&gt;控制Fragment的生命周期，核心是控制Fragment的view状态，比如将fragment中的view添加到Activity中或者将view从Activity中移除，第一版时FragmentManager是放在Activity里的。&lt;/p&gt;
&lt;h5 id=&#34;2fragment&#34;&gt;2）Fragment：&lt;/h5&gt;
&lt;p&gt;应用的一个UI片段或行为，可以在Activity中被替换，持有自己的View，定义了自己的生命周期，但是生命周期依赖于依附的Activity的生命周期，当Activity销毁时，Fragment同时也会被销毁。&lt;/p&gt;
&lt;h5 id=&#34;3fragmenttransactionimplfragmenttransaction的实现类&#34;&gt;3）FragmentTransactionImpl（FragmentTransaction的实现类）：&lt;/h5&gt;
&lt;p&gt;对外提供控制Fragment操作的接口，初版只有添加、移除和comit操作，添加和移除只是对添加队列和移除队列操作，commit时委托FragmentManager真正执行操作，设置Fragment的生命周期状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentversion.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;初版类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentclass.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;初版时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/inifragmentseq.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;当前最新的fragment机制&#34;&gt;当前最新的Fragment机制：&lt;/h4&gt;
&lt;p&gt;为了将Activity和FragmentManager解耦，方便其他地方也可以使用Fragment，比如我们其实可以在service中使用Fragment，虽然场景不是很多。&lt;/p&gt;
&lt;p&gt;比如如下博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mjlong123123/article/details/104156953&#34;&gt;https://blog.csdn.net/mjlong123123/article/details/104156953&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;4fragmentcontroller&#34;&gt;4）FragmentController：&lt;/h5&gt;
&lt;p&gt;FragmentController中的“所有”动作真正执行者都是FragmentHostCallback，绝大部分大部分的动作真正执行者是FragmentHostCallback中的FragmentManager。&lt;/p&gt;
&lt;h5 id=&#34;5hostcallbacksfragmenthostcallback&#34;&gt;5）HostCallbacks（FragmentHostCallback）：&lt;/h5&gt;
&lt;p&gt;为了将FragmentManager于FragmentManager解耦，必须有一个中间类来真正持有FragmentManager对象，这个类就是FragmentHostCallback，Activity中的实现是HostCallbacks，当然，如果我们想要在service中使用Fragment，可以自定义类来继承FragmentHostCallback类来实现。&lt;/p&gt;
&lt;p&gt;实际调用链&lt;/p&gt;
&lt;p&gt;Activity-&amp;gt;FragmentController-&amp;gt;FragmentHostCallback-&amp;gt;FragmentManager，&lt;/p&gt;
&lt;p&gt;BackStackRecord（FragmentTransaction的实现类）：第一版时叫FragmentTransactionImpl，对外提供控制Fragment操作的接口，比如添加或移除。&lt;/p&gt;
&lt;h2 id=&#34;3细节&#34;&gt;3、细节&lt;/h2&gt;
&lt;p&gt;P版本Fragment机制&lt;/p&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/lastestfragmentclass.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;时序图，以下面的代码为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    FragmentManager fragmentManager = getFragmentManager();
    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

    LearnFragment fragment = new LearnFragment();
    fragmentTransaction.add(R.id.fragment_contain, fragment);
    fragmentTransaction.commit();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/fragmentlearn/lastestfragmentseq.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    void moveToState(Fragment f, int newState, int transit, int transitionStyle,
            boolean keepActive) {
        ...
        if (f.mState &amp;lt;= newState) {
            ...
            switch (f.mState) {
                case Fragment.INITIALIZING:
                    if (newState &amp;gt; Fragment.INITIALIZING) {
                        ...
                        f.onAttach(mHost.getContext());
                        ...
                        if (f.mParentFragment == null) {
                            mHost.onAttachFragment(f);
                        } 
                      ...
                        if (!f.mIsCreated) {
...
                            f.performCreate(f.mSavedFragmentState);
                            dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                        } ...
                    }
                    // fall through
                case Fragment.CREATED:
                    ...
                    if (newState &amp;gt; Fragment.CREATED) {
                        if (DEBUG) Log.v(TAG, &amp;quot;moveto ACTIVITY_CREATED: &amp;quot; + f);
                        if (!f.mFromLayout) {
                            ViewGroup container = null;
                            ...
                            f.mView = f.performCreateView(f.performGetLayoutInflater(
                                    f.mSavedFragmentState), container, f.mSavedFragmentState);
                            if (f.mView != null) {
                                ...
                                    container.addView(f.mView);
                                ...
                                f.onViewCreated(f.mView, f.mSavedFragmentState);
                                ....
                            }
                        }

                        f.performActivityCreated(f.mSavedFragmentState);
                        ...
                    }
                    // fall through
                case Fragment.ACTIVITY_CREATED:
                    ...
                    // fall through
                case Fragment.STOPPED:
...
                        f.performStart();
...
                    // fall through
                case Fragment.STARTED:
...
                        f.performResume();
...
            }
        } else if (f.mState &amp;gt; newState) {
            switch (f.mState) {
                case Fragment.RESUMED:
...
                        f.performPause();
...
                    // fall through
                case Fragment.STARTED:
...
                        f.performStop();
...
                    // fall through
                case Fragment.STOPPED:
                case Fragment.ACTIVITY_CREATED:
...
                        f.performDestroyView();
...
                            f.mContainer.removeView(f.mView);
...
                    // fall through
                case Fragment.CREATED:
...
                                f.performDestroy();
...
                            f.performDetach();
                            ...
            }
        }
...
            f.mState = newState;
...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;FragmentTransaction：是接口类型，实现类在Activity中，为FragmentTransactionImpl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final class FragmentTransactionImpl implements FragmentTransaction {
    ArrayList&amp;lt;Fragment&amp;gt; mAdded;
    ArrayList&amp;lt;Fragment&amp;gt; mRemoved;
    
    public FragmentTransaction add(Fragment fragment, int containerViewId) {
        return add(fragment, null, containerViewId);
    }

    public FragmentTransaction add(Fragment fragment, String name, int containerViewId) {
        if (fragment.mActivity != null) {
            throw new IllegalStateException(&amp;quot;Fragment already added: &amp;quot; + fragment);
        }
        if (name != null) {
            fragment.mName = name;
        }
        if (mRemoved != null) {
            mRemoved.remove(fragment);
        }
        if (mAdded == null) {
            mAdded = new ArrayList&amp;lt;Fragment&amp;gt;();
        }
        fragment.mContainerId = containerViewId;
        mAdded.add(fragment);
        return this;
    }

    public FragmentTransaction remove(Fragment fragment) {
        if (fragment.mActivity == null) {
            throw new IllegalStateException(&amp;quot;Fragment not added: &amp;quot; + fragment);
        }
        if (mAdded != null) {
            mAdded.remove(fragment);
        }
        if (mRemoved == null) {
            mRemoved = new ArrayList&amp;lt;Fragment&amp;gt;();
        }
        mRemoved.add(fragment);
        return this;
    }

    public void commit() {
        if (mRemoved != null) {
            for (int i=mRemoved.size()-1; i&amp;gt;=0; i--) {
                mFragments.removeFragment(mRemoved.get(i));
            }
        }
        if (mAdded != null) {
            for (int i=mAdded.size()-1; i&amp;gt;=0; i--) {
                mFragments.addFragment(mAdded.get(i));
            }
        }
        if (mFragments != null) {
            mFragments.moveToState(mFragments.mCurState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Activity：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final void performCreate(Bundle icicle) {
    onCreate(icicle);
    mFragments.dispatchCreate(icicle);
}
    
final void performStart() {
    mCalled = false;
    mInstrumentation.callActivityOnStart(this);
。。。
    mFragments.dispatchStart();
}
    
final void performResume() {
    performRestart();
。。。
    mInstrumentation.callActivityOnResume(this);
。。。
        
    mFragments.dispatchResume();
        
    onPostResume();
。。。
}

final void performPause() {
    mFragments.dispatchPause();
    onPause();
}
    
final void performStop() {
。。。
     mFragments.dispatchStop();
。。。
     mInstrumentation.callActivityOnStop(this);
。。。
}
    
final void performDestroy() {
    mFragments.dispatchDestroy();
    onDestroy();
}

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>preference体系学习总结</title>
      <link>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;1preference体系学习总结&#34;&gt;1.preference体系学习总结&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一部分主要学习了preference体系的相关知识（类图中蓝色和绿色部分）&lt;/p&gt;
&lt;h2 id=&#34;11-数据结构描述&#34;&gt;1.1 数据结构描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1.1&lt;/strong&gt; &lt;strong&gt;preference&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;设置的基石，简单来讲可以认为是设置列表中的每一个项目。&lt;/p&gt;
&lt;p&gt;其中有个重要的方法getView，这个方法返回的View将会被添加到PreferenceFragment或PreferenceActivity里&lt;/p&gt;
&lt;p&gt;作用：提供一个view给即将被展示的activity并且关联一个sharepreferences来保存或取出preference数据，其他常用的preference子类都继承于该类从而进行view样式的改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.2（v7包的Preference）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;去除了getView方法，增加了继承于RecycleView.ViewHolder的PreferenceViewHolder类&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.3&lt;/strong&gt; &lt;strong&gt;PreferenceGroup&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;继承于PreferenceGroup，内部维护了一个元素为Preference的List，和Preference的关系类似于View和ViewGroup一样，采用了组合模式进行组织。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.4（v7包的PreferenceGroup）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现类似，改动不大&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.5&lt;/strong&gt; &lt;strong&gt;PreferenceScreen&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;继承于PreferenceGroup，是一个界面的root节点。当一个PreferenceScreen嵌套在另一个PreferenceScreen内部时会以Dialog的形式开启一个新的界面进行显示。&lt;/p&gt;
&lt;p&gt;内部持有一个listView，一个listAdapter（PreferenceGroupAdapter），持有一个layout文件&amp;quot;com.android.internal.R.layout.preference_list_fragment&amp;quot;的id，还有一个Dialog，用于展示嵌套的preferenceScreen&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.6 （v7包的PreferenceScreen）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现对比解耦了关联的View体系的东西，更加简洁。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.7 PreferenceManager&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;管理类，用XmlPullParser遍历解析xml文件来创建preference。&lt;/p&gt;
&lt;p&gt;1.重要的属性&lt;/p&gt;
&lt;p&gt;activity，fragment，sharepreference，preferenceDataStore，preferenceScreen；&lt;/p&gt;
&lt;p&gt;关联了一个根布局“PreferenceScreen”，和SharedPreference进行交互。&lt;/p&gt;
&lt;p&gt;2.重要的方法&lt;/p&gt;
&lt;p&gt;inflateFromResource：通过PreferenceInflater（继承于GenericInflater）递归地扫描xml文件取出所有节点信息来构建出PreferenceScreen对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.8 （v14包的PreferenceManager）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加了一些接口OnDisplayPreferenceDialogListener、OnNavigateToScreenListener&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.9 PreferenceFragment：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于显示preference对象列表&lt;/p&gt;
&lt;p&gt;持有一个listView，最终会关联到PreferenceScreen的listView，实现了onPreferenceTreeClick接口，这个接口会在ListView的项被点击时回调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.10（v14包的PreferenceFragment）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与旧实现相比改动较大。主要是采用了RecyclerView并且实现了一些Dialog的接口。&lt;/p&gt;
&lt;p&gt;关联了recycleView和preferenceManager&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.1.11 PreferenceActivity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承于ListActivity，重要的内部类&lt;/p&gt;
&lt;p&gt;Header：&lt;/p&gt;
&lt;p&gt;Header包含的属性：&lt;/p&gt;
&lt;p&gt;1.title； 2.summary；3.icon；4.fragment；5.intent；6.bundle；&lt;/p&gt;
&lt;p&gt;HeaderAdapter&lt;/p&gt;
&lt;p&gt;HeaderAdapter包含的属性：1.icon；2.title；3.summary&lt;/p&gt;
&lt;p&gt;从这个adapter和layout布局(preference_header_item.xml)可以看出一个header只有这三项。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;12-preferencefragment加载xml源码分析旧&#34;&gt;1.2 PreferenceFragment加载xml源码分析（旧）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/fragmentaddxml.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;重要流程说明：&lt;/p&gt;
&lt;p&gt;第8步：PreferenceInflater是一个xml解析器，通过解析xml取出节点，然后反射生成PreferenceScreen对象&lt;/p&gt;
&lt;h2 id=&#34;13--preferencefragment点击事件触发流程旧&#34;&gt;1.3  PreferenceFragment点击事件触发流程（旧）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            Preference的performClick
                PreferenceManager.OnPreferenceTreeClickListener的onPreferenceTreeClick
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-preferenceactivity加载xml源码分析&#34;&gt;1.4 PreferenceActivity加载xml源码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceactivityaddxml.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;重要流程说明：&lt;/p&gt;
&lt;p&gt;第4步：生成Header的方式也是通过xml解析器解析xml的header节点然后反射生成Header对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;无论是新的loadHeadersFromResource还是旧的addPreferencesFromResource，底层解析xml都用的XmlPullParser类。&lt;/p&gt;
&lt;h2 id=&#34;15-preferenceactivity点击事件触发流程&#34;&gt;1.5. PreferenceActivity点击事件触发流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;AbsListView里的onKeyUp	
    AdapterView里的performItemClick
        OnItemClickListener的onItemClick
            ListActivity里的onListItemClick
                PreferenceAcitvity里的onHeaderClick
                    然后根据fragment是否为空来执行switchToHeader或者startActivity
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2aosp中setting模块学习总结&#34;&gt;2.aosp中Setting模块学习总结&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/preferenceclass.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要分析只在系统Settings中使用的部分（除去上面分析过的蓝色和绿色部分）&lt;/p&gt;
&lt;h4 id=&#34;21-settings主页面的显示分析&#34;&gt;2.1 Settings主页面的显示分析：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsettings.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;aosp中P版本设置界面如上图所示，除去没显示的，主界面中一共展示了12个列表项，先分析列表项，后面再分析搜索和suggestion项。&lt;/p&gt;
&lt;p&gt;主Activity为Settings，继承于SettingsActivity，内部包含一个DashboardSummary的Fragment，从类图上看出DashboardSummary并没有用到preference的那一套东西。布局也相对简单，只有一个FocusRecyclerView，页面的布局由DashboardAdapter负责，DashboardAdapter用到的所有数据由DashboardData进行描述。这里只分析DashboardData中的DashboardCategory，也就是12个列表项所属的DashboardCategory，对于设置主界面来说只有一个DashboardCategory，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta-data android:name=&amp;quot;com.android.settings.category&amp;quot;
    android:value=&amp;quot;com.android.settings.category.ia.homepage&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从android manifest中也可以看到12个这样的数据，代表主界面的12个列表项。&lt;/p&gt;
&lt;p&gt;从类图中可以看出一个列表项由&lt;strong&gt;Tile&lt;/strong&gt;这样一个数据结构进行描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Tile implements Parcelable {
    public CharSequence title;
    public CharSequence summary;
    public Icon icon;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;DashboardCategory&lt;/strong&gt;表示一个类别，持有一个元素为Tile的List表；&lt;/p&gt;
&lt;p&gt;可以发现Dashboard和Preference有很多相似的地方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Base fragment for dashboard style UI containing a list of static and dynamic setting items.
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从注释可以看出DashboardFragment是为了动态加载而设计的，相对于Preference是静态地从xml文件中解析读取的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CategoryManager&lt;/strong&gt;主要是对DashboardCategory进行管理，内部会借助于&lt;strong&gt;TileUtils&lt;/strong&gt;来生成DashboardCategory对象，在生成DashboardCategory对象时会借助PackageManager来查询手机中的安装包信息来进行分析，来动态决定是否展示一些项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DashboardFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;DashboardFeatureProvider&lt;/strong&gt;接口，持有CategoryManager对象，通过CategoryManager对象进行Category的获取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SuggestionFeatureProviderImpl&lt;/strong&gt;实现了&lt;strong&gt;SuggestionFeatureProvider&lt;/strong&gt;接口，应该是用于获取推荐信息，后面再分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FeatureFactoryImpl&lt;/strong&gt;实现了&lt;strong&gt;FeatureFactory&lt;/strong&gt;接口，通过反射生成，用于生成DashboardFeatureProviderImpl和SuggestionFeatureProviderImpl等一些FeatureProvider对象。&lt;/p&gt;
&lt;p&gt;整个设置主界面加载流程大致如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/dashboardsummary.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中绿色为主线程，其他线程为后台线程。&lt;/p&gt;
&lt;p&gt;对于流程做个简单的分析。&lt;/p&gt;
&lt;h5 id=&#34;1-settingsactivity的oncreate流程&#34;&gt;1. SettingsActivity的onCreate流程&lt;/h5&gt;
&lt;p&gt;在这个过程中会进行FeatureFactory、DashboardFeatureProvider、CategoryManager的初始化，并且如果判断是主界面，则启动DashboardSummary这个Fragment。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.1 DashboardSummary在onAttach中会创建SuggestionFeatureProvider，使之来进行推荐功能的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1.2 DashboardSummary在onCreate中会成创建DashboardFeatureProvider，以及新建一个SummaryLoader，用&amp;quot;om.android.settings.category.ia.homepage&amp;quot;来作为CategoryKey，SummaryLoader构造时会启动一个HandlerThread来在后台运行，以便随时接受主线程发过来的消息从而触发SummaryProvider的setListening方法进行Summary的更新，比如更新存储空间或者电量的百分比，或者根据不同的手机特性显示不同的Summary，比如在安全设置Fragment中对于支持指纹的手机显示&amp;quot;屏幕锁定、指纹&amp;rdquo;，不支持指纹的手机仅显示&amp;quot;屏幕锁定&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1.3  DashboardSummary在onCreateView中会进行view相关的处理，rootview为R.layout.dashboard，这个view中只有一个简单的RecycleView，创建DashboardAdapter，执行rebuildUI方法，该方法启动一个后台线程调用updateCategory来进行Category的更新，更新完毕通过notifyDashboardDataChanged通知主线程进行view的更新，如果需要加载推荐项，推荐项没加载，则向主线程发送一个延迟更新view的消息，通过Handler的postDelayed方法实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-settingsactivity的onresume流程&#34;&gt;2. SettingsActivity的onResume流程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2.1 这个方法首先会在父类SettingsDrawerActivity的onResume中执行CategoriesUpdateTask，来在后台更新所有的Categories，调用完毕后回主线程调用CategoryListener接口的onCategoriesChanged方法，DashboardFrament和DashboardSummary实现了该接口来进行Category的刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.2 SettingsAcitvity在重写onResume后再次向AsyncTask中post一个doUpdateTilesList的方法，这个方法会排在CategoriesUpdateTask之后执行，也是用来更新Categories的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.3 在DashboardSummary的onResume中，会调用SummaryLoader的setListening方法，这个方法会向HandlerThread中post消息，分析这个消息类型MSG_GET_CATEGORY_TILES_AND_SET_LISTENING，对应时序图的47步，在后台线程获取到category后，遍历所有的tile，调用makeProviderW方法，因为所有该category下的Fragment都实现了SummaryProvider以及SummaryLoader.SummaryProviderFactory，SummaryProvider实现了SummaryLoader.SummaryProvider接口，因此通过tile找到相关的factory后，再通过反射生成SummaryProvider对象，如时序图的52步。紧接着在setListeningW中遍历调用所有的SummaryProvider的setListening方法，这个方法进一步触发SummaryLoader的setSummary方法来进行各个列表项summary的动态变化，比如电量的更新等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setSummary(SummaryProvider provider, final CharSequence summary) {
    final ComponentName component = mSummaryProviderMap.get(provider);
    ThreadUtils.postOnMainThread(() -&amp;gt; {
  
        final Tile tile = getTileFromCategory(
                mDashboardFeatureProvider.getTilesForCategory(mCategoryKey), component);
  
        if (tile == null) {
            if (DEBUG) {
                Log.d(TAG, &amp;quot;Can&#39;t find tile for &amp;quot; + component);
            }
            return;
        }
        if (DEBUG) {
            Log.d(TAG, &amp;quot;setSummary &amp;quot; + tile.title + &amp;quot; - &amp;quot; + summary);
        }
  
        updateSummaryIfNeeded(tile, summary);
    });
}
  
@VisibleForTesting
void updateSummaryIfNeeded(Tile tile, CharSequence summary) {
    if (TextUtils.equals(tile.summary, summary)) {
        if (DEBUG) {
            Log.d(TAG, &amp;quot;Summary doesn&#39;t change, skipping summary update for &amp;quot; + tile.title);
        }
        return;
    }
    mSummaryTextMap.put(mDashboardFeatureProvider.getDashboardKeyForTile(tile), summary);
    tile.summary = summary;
    if (mSummaryConsumer != null) {
        mSummaryConsumer.notifySummaryChanged(tile);
    } else {
        if (DEBUG) {
            Log.d(TAG, &amp;quot;SummaryConsumer is null, skipping summary update for &amp;quot;
                    + tile.title);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在SummaryLoader的setSummary方法中再通过SummaryConsumer接口的notifySummaryChanged方法进行界面的更新，对于主界面来说是DashboardAdapter实现了SummaryConsumer接口，会直接触发notifyItemChanged来进行view的更新（对于其他DashboardFragment的子类来说则是父类DashboardFragment实现了SummaryConsumer接口，会触发Preference的setSummary方法，这个方法会调用notifyChanged方法，进而触发OnPreferenceChangeInternalListener的onPreferenceChange方法，而PreferenceGroupAdapter实现了该接口，因而也会触发notifyItemChanged来进行view的更新）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-securitysettings页面的显示流程分析&#34;&gt;2.2 SecuritySettings页面的显示流程分析：&lt;/h3&gt;
&lt;p&gt;Settings主界面的显示完全是动态的，而除去主界面其他的Fragment的显示则是动态和静态相结合，以要分析的SecuritySettings来说明。SecuritySettings的继承于DashboardFragment，而DashboardFragment主要就是用来加载动态和静态的item。DashboardFragment最终继承于PreferenceFragment，因此可以解析xml中配置的preference来进行显示，而且持有DashboardFeatureProviderImpl对象，因此也可以加载DashboardCategory中的Tile进行显示。&lt;/p&gt;
&lt;p&gt;SecuritySettings界面显示是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/securitysettings.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;layout文件R.xml.security_dashboard_settings如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PreferenceScreen
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:settings=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    android:key=&amp;quot;security_dashboard_page&amp;quot;
    android:title=&amp;quot;@string/security_settings_title&amp;quot;
    settings:initialExpandedChildrenCount=&amp;quot;9&amp;quot;&amp;gt;

    &amp;lt;!-- security_settings_status.xml --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;-10&amp;quot;
        android:key=&amp;quot;security_status&amp;quot;
        android:title=&amp;quot;@string/security_status_title&amp;quot; /&amp;gt;

    &amp;lt;PreferenceCategory
        android:order=&amp;quot;1&amp;quot;
        android:key=&amp;quot;dashboard_tile_placeholder&amp;quot; /&amp;gt;

    &amp;lt;!-- security section --&amp;gt;
    &amp;lt;PreferenceCategory
        android:order=&amp;quot;10&amp;quot;
        android:key=&amp;quot;security_category&amp;quot;
        android:title=&amp;quot;@string/lock_settings_title&amp;quot;&amp;gt;  &amp;lt;!-- 设备安全性--&amp;gt;

        &amp;lt;com.android.settings.widget.GearPreference
            android:key=&amp;quot;unlock_set_or_change&amp;quot;
            android:title=&amp;quot;@string/unlock_set_unlock_launch_picker_title&amp;quot;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_lockscreen&amp;quot; /&amp;gt; &amp;lt;!-- 屏幕锁定--&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;lockscreen_preferences&amp;quot;
            android:title=&amp;quot;@string/lockscreen_settings_title&amp;quot; &amp;lt;!-- 锁屏时的偏好设置--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            android:fragment=&amp;quot;com.android.settings.security.LockscreenDashboardFragment&amp;quot; /&amp;gt;

        &amp;lt;Preference
            android:key=&amp;quot;fingerprint_settings&amp;quot;
            android:title=&amp;quot;@string/security_settings_fingerprint_preference_title&amp;quot; &amp;lt;!-- 指纹--&amp;gt;
            android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
            settings:keywords=&amp;quot;@string/keywords_fingerprint_settings&amp;quot;/&amp;gt;

    &amp;lt;/PreferenceCategory&amp;gt;
....

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码里会解析这个xml文件来构造PreferenceScreen对象。&lt;/p&gt;
&lt;p&gt;从图里看到并没有显示锁屏时的偏好设置这一个Preference的条目，从源码分析是LockScreenPreferenceController这个类动态的改变了这一个Preference的显示状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Override
    public int getAvailabilityStatus() {
        if (!mLockPatternUtils.isSecure(MY_USER_ID)) {
            return mLockPatternUtils.isLockScreenDisabled(MY_USER_ID)
                    ? DISABLED_FOR_USER : AVAILABLE;
        } else {
            return mLockPatternUtils.getKeyguardStoredPasswordQuality(MY_USER_ID)
                    == PASSWORD_QUALITY_UNSPECIFIED
                    ? DISABLED_FOR_USER : AVAILABLE;
        }
    }

    @Override
    public void updateState(Preference preference) {
        preference.setSummary(
                LockScreenNotificationPreferenceController.getSummaryResource(mContext));
    }

    @Override
    public void onResume() {
        mPreference.setVisible(isAvailable());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这三个item其实是通过动态从DashboardTiles中取出来的。下面简单分析SecuritySettings的显示过程，主要是DashboardFragment的流程分析。&lt;/p&gt;
&lt;h4 id=&#34;221dashboardfragmenet的onattach流程&#34;&gt;2.2.1.DashboardFragmenet的onAttach流程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mDashboardFeatureProvider = FeatureFactory.getFactory(context).
            getDashboardFeatureProvider(context);
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
    // Load preference controllers from code
    final List&amp;lt;AbstractPreferenceController&amp;gt; controllersFromCode =
            createPreferenceControllers(context);
    // Load preference controllers from xml definition
    final List&amp;lt;BasePreferenceController&amp;gt; controllersFromXml = PreferenceControllerListHelper
            .getPreferenceControllersFromXml(context, getPreferenceScreenResId());
    // Filter xml-based controllers in case a similar controller is created from code already.
    final List&amp;lt;BasePreferenceController&amp;gt; uniqueControllerFromXml =
            PreferenceControllerListHelper.filterControllers(
                    controllersFromXml, controllersFromCode);

    // Add unique controllers to list.
    if (controllersFromCode != null) {
        controllers.addAll(controllersFromCode);
    }
    controllers.addAll(uniqueControllerFromXml);
...

    mPlaceholderPreferenceController =
            new DashboardTilePlaceholderPreferenceController(context);
    controllers.add(mPlaceholderPreferenceController);
    for (AbstractPreferenceController controller : controllers) {
        addPreferenceController(controller);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法里主要是一些controllers的创建，这些controller可以从代码创建，也可以从xml解析获取，&lt;/p&gt;
&lt;p&gt;在SecuritySettings里通过代码创建了一些controller，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private static List&amp;lt;AbstractPreferenceController&amp;gt; buildPreferenceControllers(Context context,
            Lifecycle lifecycle, SecuritySettings host) {
        final List&amp;lt;AbstractPreferenceController&amp;gt; controllers = new ArrayList&amp;lt;&amp;gt;();
        controllers.add(new LocationPreferenceController(context, lifecycle));
        controllers.add(new ManageDeviceAdminPreferenceController(context));
        controllers.add(new EnterprisePrivacyPreferenceController(context));
        controllers.add(new ManageTrustAgentsPreferenceController(context));
        ...

        return controllers;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在xml中是通过声明settings:controller属性来创建的，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;SwitchPreference
    android:key=&amp;quot;visiblepattern_profile&amp;quot;
    android:summary=&amp;quot;@string/summary_placeholder&amp;quot;
    android:title=&amp;quot;@string/lockpattern_settings_enable_visible_pattern_title_profile&amp;quot;
    settings:controller=&amp;quot;com.android.settings.security.VisiblePatternProfilePreferenceController&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;221dashboardfragmenet的oncreate流程&#34;&gt;2.2.1.DashboardFragmenet的onCreate流程&lt;/h4&gt;
&lt;p&gt;DashboardFragmenet最终继承于v14包里的PreferenceFragment的onCreate方法，里面会调用onCreatePreferences方法，DashboardFragmenet重写了onCreatePreferences方法，进而调用refreshAllPreferences方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Refresh all preference items, including both static prefs from xml, and dynamic items from
 * DashboardCategory.
 */
private void refreshAllPreferences(final String TAG) {
    // First remove old preferences.
    if (getPreferenceScreen() != null) {
        // Intentionally do not cache PreferenceScreen because it will be recreated later.
        getPreferenceScreen().removeAll();
    }

    // Add resource based tiles.
    displayResourceTiles();

    refreshDashboardTiles(TAG);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从注释可以看出这个方法是这个Fragment显示流程的核心。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Displays resource based tiles.
 */
private void displayResourceTiles() {
    final int resId = getPreferenceScreenResId();
    if (resId &amp;lt;= 0) {
        return;
    }
    addPreferencesFromResource(resId);
    final PreferenceScreen screen = getPreferenceScreen();
    mPreferenceControllers.values().stream().flatMap(Collection::stream).forEach(
            controller -&amp;gt; controller.displayPreference(screen));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;displayResourceTiles这个方法首先获取了PreferenceScreen，然后通过循环调用了每个controller的displayPreference方法&lt;/p&gt;
&lt;p&gt;以上面说的LockScreenPreferenceController为例，LockScreenPreferenceController继承于BasePreferenceController，因此会调用如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Displays preference in this controller.
 */
@Override
public void displayPreference(PreferenceScreen screen) {
    super.displayPreference(screen);
    if (getAvailabilityStatus() == DISABLED_DEPENDENT_SETTING) {
        // Disable preference if it depends on another setting.
        final Preference preference = screen.findPreference(getPreferenceKey());
        if (preference != null) {
            preference.setEnabled(false);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从而来决定一个preference是否该显示。&lt;/p&gt;
&lt;p&gt;执行完displayResourceTiles后接着会执行refreshDashboardTiles方法，从注释也可以看出这个方法是用来展示动态DashboardCategory的item的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Refresh preference items backed by DashboardCategory.
 */
@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
void refreshDashboardTiles(final String TAG) {
    final PreferenceScreen screen = getPreferenceScreen();

    final DashboardCategory category =
            mDashboardFeatureProvider.getTilesForCategory(getCategoryKey());
    ...
    final List&amp;lt;Tile&amp;gt; tiles = category.getTiles();
    ...
    mSummaryLoader = new SummaryLoader(getActivity(), getCategoryKey());
    mSummaryLoader.setSummaryConsumer(this);
    ...
    // Install dashboard tiles.
    for (Tile tile : tiles) {
        final String key = mDashboardFeatureProvider.getDashboardKeyForTile(tile);
        ...
        if (mDashboardTilePrefKeys.contains(key)) {
            // Have the key already, will rebind.
            ....
        } else {
            // Don&#39;t have this key, add it.
            final Preference pref = new Preference(getPrefContext());
            mDashboardFeatureProvider.bindPreferenceToTile(getActivity(), getMetricsCategory(),
                    pref, tile, key, mPlaceholderPreferenceController.getOrder());
            screen.addPreference(pref);
            mDashboardTilePrefKeys.add(key);
        }
        remove.remove(key);
    }
    ...
    mSummaryLoader.setListening(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5-11行取出相关key的tile对象。对于SecuritySettings来说key是&amp;quot;com.android.settings.category.ia.security&amp;rdquo;，三个tile的title为“Google Play 保护机制、查找我的设备、安全更新”，如前面一节所介绍的，这三项是从gms服务中取出的，并不是Settings app本身内置的，因此可以看作是动态加载。&lt;/p&gt;
&lt;p&gt;13行创建了一个SummaryLoader对象，从之前的分析可知，会创建一个HandlerThread置于后台运行。&lt;/p&gt;
&lt;p&gt;14行把自己设置为SummaryConsumer接口对象，当SummaryLoader后台更新完，会调用setListeningW，这个方法又会取出所有满足要求的SummaryProvider去执行setListening方法，SummaryProvider又会反过来调用SummaryLoader的setSummary方法，SummaryLoader这时会post一个updateSummaryIfNeeded方法到主线程执行，而这个方法会取出mSummaryConsumer也就是DashboardFragment去执行notifySummaryChanged方法，这个方法会获取tile关联的preference，执行其setSummary方法，这个方法又会调用notifyChanged方法，这个方法调用OnPreferenceChangeInternalListener接口的onPreferenceChange方法，而PreferenceGroupAdapter实现了这个接口，因此最终通过PreferenceGroupAdapter实现了view中Summary的更新。&lt;/p&gt;
&lt;p&gt;25-29行创建Preference对象，并且将Preference和Tile进行绑定，然后添加到PreferenceScreen中。&lt;/p&gt;
&lt;p&gt;34行调用SummaryLoader的setListening方法，从前面一节分析可知，这个操作会往后台HandlerThread发送一个消息，从而在后台监听Summary是否有更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private SummaryProvider getSummaryProvider(Tile tile) {
    if (!mActivity.getPackageName().equals(tile.intent.getComponent().getPackageName())) {
        // Not within Settings, can&#39;t load Summary directly.
        // TODO: Load summary indirectly.
        return null;
    }
    ...
    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SummaryLoader的getSummaryProvider方法第二行中当前包名为com.android.settings，而tile的包名为com.google.android.gms，因此返回空，从注释也可以看出，如果当前的tile不在Settings应用中，是不能获取到SummaryProvider的。因此后面的通知Adapter进行Summary的刷新操作也就不会执行了，&lt;/p&gt;
&lt;h1 id=&#34;3aosp-80-settingssearch分析&#34;&gt;3.aosp 8.0 SettingsSearch分析&lt;/h1&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsettingsdatabase.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31搜索的数据源&#34;&gt;3.1搜索的数据源&lt;/h2&gt;
&lt;p&gt;SearchIndexableData:用于搜索的可索引数据&lt;/p&gt;
&lt;p&gt;SearchIndexableResource：xml资源&lt;/p&gt;
&lt;p&gt;SearchIndexableRaw：原始数据&lt;/p&gt;
&lt;p&gt;BaseColumns：基类，rank排名，className类名，iconResId等；&lt;/p&gt;
&lt;p&gt;XmlResource：xml的资源id，关联SearchIndexableResource&lt;/p&gt;
&lt;p&gt;RawData：原始数据，title标题，summary概要等；关联SearchIndexableData&lt;/p&gt;
&lt;p&gt;NonIndexableKey：描述一个不能被索引的数据&lt;/p&gt;
&lt;p&gt;SearchIndexablesProvider：用于搜索的可索引provider的基类，用于给搜索提供preference的xml文件数据或者原始数据。&lt;/p&gt;
&lt;p&gt;以上的类除了SearchIndexableRaw外其他都位于framework包中；&lt;/p&gt;
&lt;p&gt;以下的类或接口位于settings中；&lt;/p&gt;
&lt;p&gt;Indexable.SearchIndexProvider：接口，其实现类的实例可以提供可索引的数据&lt;/p&gt;
&lt;p&gt;SettingsSearchIndexablesProvider：设置app中的content provider，实现了SearchIndexablesPrevider的相关搜索方法，在phone的app中也有一个类似的实现:PhoneSearchIndexablesProvider，从而可以在设置的搜索中找到Phone中的xml数据进行跳转&lt;/p&gt;
&lt;p&gt;BaseSearchIndexProvider：&lt;/p&gt;
&lt;p&gt;IndexDatabaseHelper：提供数据库的操作，数据库文件位于data/user_de/0/com.android.settings/databases/search_index.db&lt;/p&gt;
&lt;h2 id=&#34;32数据库构建过程&#34;&gt;3.2数据库构建过程&lt;/h2&gt;
&lt;p&gt;设置中的界面大部分都是通过xml文件中声明的Preference类的各种子类构建而成，页面打开时通过解析xml文件中的各个节点从而构建成listview中的各个item从而进行显示，以日期和时间页面DateTimeSettings为例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/datatimephone.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;构成这个界面的文件date_time_prefs.xml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;

&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
        xmlns:settings=&amp;quot;http://schemas.android.com/apk/res/com.android.settings&amp;quot;
        android:title=&amp;quot;@string/date_and_time&amp;quot; 
        settings:keywords=&amp;quot;@string/keywords_date_and_time&amp;quot;&amp;gt;

    &amp;lt;com.android.settingslib.RestrictedSwitchPreference android:key=&amp;quot;auto_time&amp;quot;
        android:title=&amp;quot;@string/date_time_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/date_time_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/date_time_auto_summaryOff&amp;quot;
        settings:useAdditionalSummary=&amp;quot;true&amp;quot;
        settings:restrictedSwitchSummary=&amp;quot;@string/enabled_by_admin&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;auto_zone&amp;quot;
        android:title=&amp;quot;@string/zone_auto&amp;quot;
        android:summaryOn=&amp;quot;@string/zone_auto_summaryOn&amp;quot;
        android:summaryOff=&amp;quot;@string/zone_auto_summaryOff&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;date&amp;quot;
        android:title=&amp;quot;@string/date_time_set_date&amp;quot;
        android:summary=&amp;quot;03/10/2008&amp;quot;
        /&amp;gt;

    &amp;lt;Preference android:key=&amp;quot;time&amp;quot;
        android:title=&amp;quot;@string/date_time_set_time&amp;quot;
        android:summary=&amp;quot;12:00am&amp;quot;
        /&amp;gt;

    &amp;lt;Preference
        android:fragment=&amp;quot;com.android.settings.datetime.ZonePicker&amp;quot;
        android:key=&amp;quot;timezone&amp;quot;
        android:title=&amp;quot;@string/date_time_set_timezone&amp;quot;
        android:summary=&amp;quot;GMT-8:00&amp;quot;
        /&amp;gt;

    &amp;lt;SwitchPreference android:key=&amp;quot;24 hour&amp;quot;
        android:title=&amp;quot;@string/date_time_24hour&amp;quot;
        /&amp;gt;

&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述的xml文件的每一项跟界面展示是一一对应的，实际情况也可能不一样，可以通过配置一些属性或者代码动态增删一些项。&lt;/p&gt;
&lt;p&gt;title为显示的标题，summary为摘要，keywords为关键词（不直接显示，用于搜索），留意上面的settings:keywords=&amp;rdquo;@string/keywords_date_and_time&amp;quot;中keywords_date_and_time的值为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string name=&amp;quot;keywords_date_and_time&amp;quot; msgid=&amp;quot;758325881602648204&amp;quot;&amp;gt;&amp;quot;时钟, 军用&amp;quot;&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面写的是界面跟xml的关系，搜索过程是一个数据库的检索过程，因此搜索需要用到数据库，数据库数据的来源就是上面的xml文件，从模拟器取出search_index.db数据库观察，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/seachdb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见xml的数据跟数据库中的记录也是一一对应的，因此搜索过程就是数据库的检索过程，输入搜索的字符串最终会转换成SQL数据库查询语句从而返回查询结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/searchdemo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之所以搜索军用能出现日期和时间的结果，是因为“军用”是keyword的一部分&lt;/p&gt;
&lt;p&gt;设置中也能搜索其他app的数据，只要其实现了SearchIndexablesProvider，以phone的app为例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PhoneSearchIndexablesProvider extends SearchIndexablesProvider {
    private static final String TAG = &amp;quot;PhoneSearchIndexablesProvider&amp;quot;;

    private static SearchIndexableResource[] INDEXABLE_RES = new SearchIndexableResource[] {
            new SearchIndexableResource(1, R.xml.network_setting_fragment,
                    MobileNetworkSettings.class.getName(),
                    R.mipmap.ic_launcher_phone),
    };

    ...

    @Override
    public Cursor queryXmlResources(String[] projection) {
        ....
    }
   ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样实现后（还需要在AndroidManifest里面做些配置），设置app就能跨进程取到network_setting_fragment.xml中的数据并加入search_index.db数据库，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/phonedb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面简单分析下数据库的创建过程：&lt;/p&gt;
&lt;p&gt;刚进入设置创建数据库流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/systemsettings/aospsearchcreatedb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当点击搜索按钮后会启动SearchFragment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onAttach(Context context) {
    super.onAttach(context);
    mSearchFeatureProvider = FeatureFactory.getFactory(context).getSearchFeatureProvider();
    mMetricsFeatureProvider = FeatureFactory.getFactory(context).getMetricsFeatureProvider();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先会创建mSearchFeatureProvider，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);

    final LoaderManager loaderManager = getLoaderManager();
    mSearchAdapter = new SearchResultsAdapter(this);
    mSavedQueryController = new SavedQueryController(
            getContext(), loaderManager, mSearchAdapter);
    mSearchFeatureProvider.initFeedbackButton();

    ...
    
    // Run the Index update only if we have some space
    if (!Utils.isLowStorage(activity)) {
        mSearchFeatureProvider.updateIndex(activity, this /* indexingCallback */);
    } else {
        Log.w(TAG, &amp;quot;Cannot update the Indexer as we are running low on storage space!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在onCreate中会执行索引过程，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void updateIndex(Context context, IndexingCallback callback) {
    long indexStartTime = System.currentTimeMillis();
    getIndexingManager(context).indexDatabase(callback);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着会执行IndexManager的indexDatabase方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void indexDatabase(IndexingCallback callback) {
    IndexingTask task = new IndexingTask(callback);
    task.execute();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启了一个台任务，IndexingTask是一个AsyncTask，后台执行performIndexing方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected Void doInBackground(Void... voids) {
    performIndexing();
    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * Accumulate all data and non-indexable keys from each of the content-providers.
 * Only the first indexing for the default language gets static search results - subsequent
 * calls will only gather non-indexable keys.
 */
@VisibleForTesting
void performIndexing() {
    final Intent intent = new Intent(SearchIndexablesContract.PROVIDER_INTERFACE);
    // 这里是返回手机中所有声明了action为&amp;quot;android.content.action.SEARCH_INDEXABLES_PROVIDER&amp;quot;的provider的信息，暂时只有三个应用做了这个声明，Settings，Phone和cellbroadcastreceiver，因此Settings的搜索中可以搜索到phone的app中的信息从而进行跳转。
    final List&amp;lt;ResolveInfo&amp;gt; list =
            mContext.getPackageManager().queryIntentContentProviders(intent, 0);

    String localeStr = Locale.getDefault().toString();
    String fingerprint = Build.FINGERPRINT;
    final boolean isFullIndex = isFullIndex(localeStr, fingerprint);

    if (isFullIndex) {
        rebuildDatabase();
    }

    for (final ResolveInfo info : list) {
        if (!DatabaseIndexingUtils.isWellKnownProvider(info, mContext)) {
            continue;
        }
        final String authority = info.providerInfo.authority;
        final String packageName = info.providerInfo.packageName;

        if (isFullIndex) {
        	加载外部app的索引
            addIndexablesFromRemoteProvider(packageName, authority);
        }
        addNonIndexablesKeysFromRemoteProvider(packageName, authority);
    }
	// 更新到数据库
    updateDatabase(isFullIndex, localeStr);
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;33数据搜索以及显示过程&#34;&gt;3.3数据搜索以及显示过程&lt;/h1&gt;
&lt;p&gt;在搜索框输入字符后，会回调到SearchFragment的onQueryTextChange方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean onQueryTextChange(String query) {
    ...
    if (isEmptyQuery) {
        ...
    } else {
        restartLoaders();
    }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个搜索过程涉及到了Loader机制，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; onCreateLoader(int id, Bundle args) {
    final Activity activity = getActivity();

    switch (id) {
        case LOADER_ID_DATABASE:
            return mSearchFeatureProvider.getDatabaseSearchLoader(activity, mQuery);
        case LOADER_ID_INSTALLED_APPS:
            return mSearchFeatureProvider.getInstalledAppSearchLoader(activity, mQuery);
        default:
            return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;@Override
public List&amp;lt;? extends SearchResult&amp;gt; loadInBackground() {
    ...

    primaryFirstWordResults = firstWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[0]);
    primaryMidWordResults = secondaryWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[1]);
    secondaryResults = anyWordQuery(MATCH_COLUMNS_SECONDARY, BASE_RANKS[2]);
    tertiaryResults = anyWordQuery(MATCH_COLUMNS_TERTIARY, BASE_RANKS[3]);

    final List&amp;lt;SearchResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(
            primaryFirstWordResults.size()
            + primaryMidWordResults.size()
            + secondaryResults.size()
            + tertiaryResults.size());

    results.addAll(primaryFirstWordResults);
    results.addAll(primaryMidWordResults);
    results.addAll(secondaryResults);
    results.addAll(tertiaryResults);

    return removeDuplicates(results);
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;private List&amp;lt;SearchResult&amp;gt; firstWordQuery(String[] matchColumns, int baseRank) {
    final String whereClause = buildSingleWordWhereClause(matchColumns);
    final String query = mQueryText + &amp;quot;%&amp;quot;;
    final String[] selection = buildSingleWordSelection(query, matchColumns.length);

    return query(whereClause, selection, baseRank);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(data_title like ?  OR data_title_normalized like ? ) AND enabled = 1&lt;/p&gt;
&lt;p&gt;日期%&lt;/p&gt;
&lt;p&gt;% 日期%&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onLoadFinished(Loader&amp;lt;List&amp;lt;? extends SearchResult&amp;gt;&amp;gt; loader,
        List&amp;lt;? extends SearchResult&amp;gt; data) {
    mSearchAdapter.addSearchResults(data, loader.getClass().getName());
    if (mUnfinishedLoadersCount.decrementAndGet() != 0) {
        return;
    }
    final int resultCount = mSearchAdapter.displaySearchResults();

    if (resultCount == 0) {
        mNoResultsView.setVisibility(View.VISIBLE);
    } else {
        mNoResultsView.setVisibility(View.GONE);
        mResultsRecyclerView.scrollToPosition(0);
    }
    mSearchFeatureProvider.showFeedbackButton(this, getView());
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/**
 * Merge the results from each of the loaders into one list for the adapter.
 * Prioritizes results from the local database over installed apps.
 *
 * @return Number of matched results
 */
public int displaySearchResults() {
    final List&amp;lt;? extends SearchResult&amp;gt; databaseResults = mResultsMap
            .get(DatabaseResultLoader.class.getName());
    final List&amp;lt;? extends SearchResult&amp;gt; installedAppResults = mResultsMap
            .get(InstalledAppResultLoader.class.getName());
    final int dbSize = (databaseResults != null) ? databaseResults.size() : 0;
    final int appSize = (installedAppResults != null) ? installedAppResults.size() : 0;
    final List&amp;lt;SearchResult&amp;gt; newResults = new ArrayList&amp;lt;&amp;gt;(dbSize + appSize);

    int dbIndex = 0;
    int appIndex = 0;
    int rank = TOP_RANK;

    while (rank &amp;lt;= BOTTOM_RANK) {
        while ((dbIndex &amp;lt; dbSize) &amp;amp;&amp;amp; (databaseResults.get(dbIndex).rank == rank)) {
            newResults.add(databaseResults.get(dbIndex++));
        }
        while ((appIndex &amp;lt; appSize) &amp;amp;&amp;amp; (installedAppResults.get(appIndex).rank == rank)) {
            newResults.add(installedAppResults.get(appIndex++));
        }
        rank++;
    }

    while (dbIndex &amp;lt; dbSize) {
        newResults.add(databaseResults.get(dbIndex++));
    }
    while (appIndex &amp;lt; appSize) {
        newResults.add(installedAppResults.get(appIndex++));
    }

    final DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(
            new SearchResultDiffCallback(mSearchResults, newResults), false /* detectMoves */);
    mSearchResults = newResults;
    diffResult.dispatchUpdatesTo(this);

    return mSearchResults.size();
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public void dispatchUpdatesTo(final RecyclerView.Adapter adapter) {
    dispatchUpdatesTo(new ListUpdateCallback() {
        @Override
        public void onInserted(int position, int count) {
            adapter.notifyItemRangeInserted(position, count);
        }

        @Override
        public void onRemoved(int position, int count) {
            adapter.notifyItemRangeRemoved(position, count);
        }

        @Override
        public void onMoved(int fromPosition, int toPosition) {
            adapter.notifyItemMoved(fromPosition, toPosition);
        }

        @Override
        public void onChanged(int position, int count, Object payload) {
            adapter.notifyItemRangeChanged(position, count, payload);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>无障碍学习整理（基于talkback）</title>
      <link>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</guid>
      
        <description>&lt;h2 id=&#34;一整理原因&#34;&gt;一、整理原因：&lt;/h2&gt;
&lt;p&gt;为了辅助理解无障碍google官方开发文档api的原理。&lt;/p&gt;
&lt;h2 id=&#34;二参考文档&#34;&gt;二、参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.google.cn/guide/topics/ui/accessibility&#34;&gt;无障碍开发google官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;三无障碍服务框架结构分析&#34;&gt;三、无障碍服务框架结构分析&lt;/h2&gt;
&lt;h3 id=&#34;31结构&#34;&gt;3.1.结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xuanliangdev/blogpic/master/accessibility/%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;32相关类图&#34;&gt;3.2、相关类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/accessibilityclass.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;整个talkback机制涉及了4个进程，SystemServer（蓝色部分）、Talkback（黄色部分）、被辅助app进程（绿色部分），TTS引擎进程（暂不分析）&lt;/p&gt;
&lt;p&gt;四个AIDL接口，图上红色部分&lt;/p&gt;
&lt;h4 id=&#34;321talkback辅助app实现了accessibilityservice的app&#34;&gt;3.2.1、talkback（辅助app，实现了AccessibilityService的app）&lt;/h4&gt;
&lt;p&gt;辅助app需要用到的在framewors目录中相关的类，主要是继承AccessibilityService从而接收SystemServer进程发送过来的无障碍事件并进行相关处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yservice.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;322被辅助app进程被辅助app&#34;&gt;3.2.2、被辅助app进程（被辅助app）&lt;/h4&gt;
&lt;p&gt;被辅助的app的无障碍特性主要是通过扩展Android的View框架的功能对外提供，因此无障碍相关的类主要放在view包中，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/viewaccessibility.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;323system_process&#34;&gt;3.2.3、system_process&lt;/h4&gt;
&lt;p&gt;SystemServer进程中的无障碍服务管理类如下所示，比如核心的AccessibilityManagerService，用于协调辅助app进程和被辅助app进程的交互；TouchExpolorer用于实现“触摸浏览”手势功能等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yms.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;系统进程SystemServer中的AccessibilityManagerService，用来管理所有的无障碍服务，类似AMS，SystemServer启动时会在startOtherServices方法中启动AccessibilityManagerService，startOtherServices方法在ActivityManagerService、PackageManagerService等一些核心服务的后面启动。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.SystemServer.java

/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */
private void startOtherServices() {
...
            traceBeginAndSlog(&amp;quot;StartAccessibilityManagerService&amp;quot;);
            try {
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf(&amp;quot;starting Accessibility Manager&amp;quot;, e);
            }
            traceEnd();
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;334tts&#34;&gt;3.3.4、TTS&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/tts.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;暂不分析&lt;/p&gt;
&lt;h3 id=&#34;33-无障碍框架aidl接口&#34;&gt;3.3 无障碍框架AIDL接口&lt;/h3&gt;
&lt;p&gt;理解无障碍框架的aidl的设计是理解无障碍框架的关键。&lt;/p&gt;
&lt;p&gt;我们进行无障碍的开发通常会涉及到三个进程：&lt;/p&gt;
&lt;p&gt;辅助app（talkback、或者我们自己开发的无障碍应用（比如红包助手））&lt;/p&gt;
&lt;p&gt;SystemServer（系统服务进程，管理所有的无障碍服务，并且起到中转的作用，类似AMS的设计）&lt;/p&gt;
&lt;p&gt;被辅助的app（）&lt;/p&gt;
&lt;p&gt;跨进程通信需要用到aidl接口，无障碍服务框架也不例外，由于涉及到三个进程的通信，并且辅助app通常不需要直接跟被辅助的app通信，大部分通过SystemServer进行中转通信，因此主要涉及到了四个aidl接口：&lt;/p&gt;
&lt;p&gt;被辅助app-&amp;gt;SystemServer（IAccessibilityManager.aidl）&lt;/p&gt;
&lt;p&gt;SystemServer-&amp;gt;辅助app（IAccessibilityServiceClient.aidl）&lt;/p&gt;
&lt;p&gt;辅助app-&amp;gt;SystemServer（IAccessibilityServiceConnection.aidl）&lt;/p&gt;
&lt;p&gt;SystemServer-&amp;gt;被辅助app（IAccessibilityInteractionConnection.aidl）&lt;/p&gt;
&lt;h4 id=&#34;331iaccessibilitymanageraidl客户端被辅助app服务端systemserver&#34;&gt;3.3.1、IAccessibilityManager.aidl（客户端：被辅助app、服务端：SystemServer）&lt;/h4&gt;
&lt;p&gt;比如当被辅助app产生触摸事件后，会通过这个接口发送无障碍事件给SystemServer进程的AccessibilityManagerService&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityManager.aidl

/**
 * Interface implemented by the AccessibilityManagerService called by
 * the AccessibilityManagers.
 *
 * @hide
 */
interface IAccessibilityManager {

    oneway void sendAccessibilityEvent(in AccessibilityEvent uiEvent, int userId);

    long addClient(IAccessibilityManagerClient client, int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getInstalledAccessibilityServiceList(int userId);

    List&amp;lt;AccessibilityServiceInfo&amp;gt; getEnabledAccessibilityServiceList(int feedbackType, int userId);

    int addAccessibilityInteractionConnection(IWindow windowToken,
            in IAccessibilityInteractionConnection connection,
            String packageName, int userId);

    void removeAccessibilityInteractionConnection(IWindow windowToken);

    void notifyAccessibilityButtonClicked();

    // Requires WRITE_SECURE_SETTINGS
    void performAccessibilityShortcut();

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;332-iaccessibilityserviceclientaidl客户端systemserver服务端辅助app&#34;&gt;3.3.2 、IAccessibilityServiceClient.aidl（客户端：SystemServer、服务端：辅助app）&lt;/h4&gt;
&lt;p&gt;当SystemServer接收到被辅助的app发送的无障碍事件时，会将事件通过该接口传递给辅助app进程进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceClient.aidl

/**
 * Top-level interface to an accessibility service component.
 */
oneway interface IAccessibilityServiceClient {

    void onAccessibilityEvent(in AccessibilityEvent event, in boolean serviceWantsEvent);

    void onSoftKeyboardShowModeChanged(int showMode);

    void onPerformGestureResult(int sequence, boolean completedSuccessfully);

    void onAccessibilityButtonClicked();

    void onAccessibilityButtonAvailabilityChanged(boolean available);
    
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;333iaccessibilityserviceconnectionaidl客户端辅助app服务端systemserver&#34;&gt;3.3.3、IAccessibilityServiceConnection.aidl（客户端：辅助app、服务端：SystemServer）&lt;/h4&gt;
&lt;p&gt;当我们需要找到被辅助的app的某个view的信息时，可以通过该接口的findAccessibilityNodeInfosByViewId方法实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.IAccessibilityServiceConnection.aidl

/**
 * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
 */
interface IAccessibilityServiceConnection {

    String[] findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId,
        in Bundle arguments);

    String[] findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    String[] findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    boolean isAccessibilityButtonAvailable();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;h4 id=&#34;334iaccessibilityinteractionconnectionaidl客户端systemserver服务端被辅助app&#34;&gt;3.3.4、IAccessibilityInteractionConnection.aidl（客户端：SystemServer、服务端：被辅助app）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;android.view.accessibility.IAccessibilityInteractionConnection.aidl

/**
 * Interface for interaction between the AccessibilityManagerService
 * and the ViewRoot in a given window.
 *
 * @hide
 */
oneway interface IAccessibilityInteractionConnection {

    void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId, in Region bounds,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid, in MagnificationSpec spec,
        in Bundle arguments);

    ...

    void findFocus(long accessibilityNodeId, int focusType, in Region bounds, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
        long interrogatingTid, in MagnificationSpec spec);

  ...

    void performAccessibilityAction(long accessibilityNodeId, int action, in Bundle arguments,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;四流程分析&#34;&gt;四、流程分析&lt;/h2&gt;
&lt;h3 id=&#34;41accessibilityservice启动流程以talkback开关打开后到talkbackservice启动进行分析&#34;&gt;4.1、AccessibilityService启动流程（以talkback开关打开后到TalkbackService启动进行分析）。&lt;/h3&gt;
&lt;p&gt;在设置中打开talback开关后，会调用到如下方法，最终会往Settings provider中key为Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES的字段写入Talkback注册的AccessibilityService值（TalkbackService），这个值保存在&lt;/p&gt;
&lt;p&gt;/data/system/users/0/settings_secure.xml文件中。（其他app的AccessibilityService也保存在同一个key中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.settingslib.accessibility.AccessibilityUtils.java

/**
 * Changes an accessibility component&#39;s state for {@param userId}.
 */
public static void setAccessibilityServiceState(Context context, ComponentName toggledService,
        boolean enabled, int userId) {
    ...
    Settings.Secure.putStringForUser(context.getContentResolver(),
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
            enabledServicesBuilder.toString(), userId);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于AccessibilityManagerService创建时注册了AccessibilityContentObserver，因此马上会收到Settings provider数据变化的监听。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

private void updateServicesLocked(UserState userState) {
    ...
        if (userState.mEnabledServices.contains(componentName)
                &amp;amp;&amp;amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
            if (service == null) {
                service = new AccessibilityServiceConnection(userState, mContext, componentName,
                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                        this, mWindowManagerService, mGlobalActionPerformer);
            } 
            ...
            service.bindLocked();
        } ...
    }
    ...
    updateAccessibilityEnabledSetting(userState);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据获取到的AccessibilityService信息（com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService）创建出AccessibilityServiceConnection。AccessibilityServiceConnection代表了一个无障碍服务，存储用于管理这个服务需要的所有数据，提供了开始/停止服务和在服务管理的数据结构中添加或者移除这个服务的api。&lt;/p&gt;
&lt;p&gt;接着调用bindServiceAsUser方法来绑定服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

public void bindLocked() {
    ...
    try {
        ...
        if (mService == null &amp;amp;&amp;amp; mContext.bindServiceAsUser(
                mIntent, this, flags, new UserHandle(userState.mUserId))) {
            userState.getBindingServicesLocked().add(mComponentName);
        }
    } ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务启动后会跨进程调用到TalkbackService(AccessibilityService)的onBind方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.accessibilityservice.AccessibilityService

/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        ...
        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }
...
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;onBind方法返回的是一个IAccessibilityServiceClientWrapper的binder对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implements the internal {@link IAccessibilityServiceClient} interface to convert
 * incoming calls to it back to calls on an {@link AccessibilityService}.
 *
 * @hide
 */
public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
        implements HandlerCaller.Callback {
    ...

    private final HandlerCaller mCaller;

    private final Callbacks mCallback;

    private int mConnectionId = AccessibilityInteractionClient.NO_ID;

    public IAccessibilityServiceClientWrapper(Context context, Looper looper,
            Callbacks callback) {
        mCallback = callback;
        mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);
    }

    public void init(IAccessibilityServiceConnection connection, int connectionId,
            IBinder windowToken) {
        Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                connection, windowToken);
        mCaller.sendMessage(message);
    }

    ...

    public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {
        Message message = mCaller.obtainMessageBO(
                DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);
        mCaller.sendMessage(message);
    }
...

    @Override
    public void executeMessage(Message message) {
        switch (message.what) {
            case DO_ON_ACCESSIBILITY_EVENT: {
                AccessibilityEvent event = (AccessibilityEvent) message.obj;
                boolean serviceWantsEvent = message.arg1 != 0;
                if (event != null) {
                    // Send the event to AccessibilityCache via AccessibilityInteractionClient
                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);
                    if (serviceWantsEvent
                            &amp;amp;&amp;amp; (mConnectionId != AccessibilityInteractionClient.NO_ID)) {
                        // Send the event to AccessibilityService
                        mCallback.onAccessibilityEvent(event);
                    }
                    ...
                }
            } return;

            ...
            case DO_INIT: {
                mConnectionId = message.arg1;
                SomeArgs args = (SomeArgs) message.obj;
                IAccessibilityServiceConnection connection =
                        (IAccessibilityServiceConnection) args.arg1;
                IBinder windowToken = (IBinder) args.arg2;
                args.recycle();
                if (connection != null) {
                    AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                            connection);
                    mCallback.init(mConnectionId, windowToken);
                    mCallback.onServiceConnected();
                }...
            } return;
...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;IAccessibilityServiceClientWrapper中保存了一个HandlerCaller和Callbacks对象，其中HandlerCaller主要是将SystemServer进程中AccessibilityServiceConnection的binder call的binder线程调研切换到AccessibilityService的主线程调用。Callbacks对象则将IAccessibilityServiceClientWrapper中的调用回调到AccessibilityService中。&lt;/p&gt;
&lt;p&gt;AccessibilityService返回binder后会走到AccessibilityServiceConnection的onServiceConnected调用中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityServiceConnection.java

@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        ...
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        ...
        userState.addServiceLocked(this);
        mSystemSupport.onClientChange(false);
        // Initialize the service on the main handler after we&#39;re done setting up for
        // the new configuration (for example, initializing the input filter).
        mMainHandler.sendMessage(obtainMessage(
                AccessibilityServiceConnection::initializeService, this));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;private void initializeService() {
    IAccessibilityServiceClient serviceInterface = null;
    ...
    try {
        serviceInterface.init(this, mId, mOverlayWindowToken);
    } catch (RemoteException re) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在serviceInterface.init方法中（binder调用）将这个AccessibilityServiceConnection、mId和mOverlayWindowToken传给AccessibilityService完成初始化工作。&lt;/p&gt;
&lt;p&gt;初始化时会调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
        connection);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将AccessibilityServiceConnection保存到AccessibilityInteractionClient中。&lt;/p&gt;
&lt;h3 id=&#34;42无障碍模式下视图状态初始化流程&#34;&gt;4.2、无障碍模式下视图状态初始化流程。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/findAccessibilityNodeInfoByAccessibilityId.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;getaccessibilitynodeprovider&#34;&gt;getAccessibilityNodeProvider&lt;/h5&gt;
&lt;h5 id=&#34;oninitializeaccessibilitynodeinfo&#34;&gt;onInitializeAccessibilityNodeInfo&lt;/h5&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、talkback打开状态下，新的应用打开时，TalkbackService会接收到类型为TYPE_WINDOWS_CHANGED的无障碍事件，这个事件是SystemServer进程接收到其他进程发出的TYPE_VIEW_ACCESSIBILITY_FOCUSED事件时附带发出的，应用发出TYPE_VIEW_ACCESSIBILITY_FOCUSED事件的流程在下一节分析，暂时跳过。&lt;/p&gt;
&lt;p&gt;2、当tailback收到TYPE_WINDOWS_CHANGED事件时，会间接调用调用父类AccessibilityService的getRootInActiveWindow方法，如上图，经过SystemServer进程中转后会调用到DecorView的getAccessibilityNodeProvider，由于DecorView没有重写getAccessibilityNodeProvider方法，因此会调用到View的createAccessibilityNodeInfo方法，进一步会调用到&lt;strong&gt;onInitializeAccessibilityNodeInfo&lt;/strong&gt;方法，如果没有重写该方法，则默认实现在onInitializeAccessibilityNodeInfoInternal中。&lt;/p&gt;
&lt;p&gt;3、AccessibilityNodePrefetcher在取出DecorView的无障碍节点后，会进一步通过prefetchDescendantsOfRealNode方法取子view的无障碍节点。同理，如果我们重写了&lt;strong&gt;getAccessibilityNodeProvider&lt;/strong&gt;方法（一些特殊的自定义view需要自己重写该方法，比如webview，android.widget.NumberPicker等），重写getAccessibilityNodeProvider，需要我们实现一个AccessibilityNodeProvider的子类，来实现虚拟的view来支持无障碍模式。通常实现比较复杂的view时会重写这两个方法&lt;/p&gt;
&lt;h3 id=&#34;43无障碍事件分发流程重要app适配无障碍以及处理无障碍相关问题主要通过该流程入手&#34;&gt;4.3、无障碍事件分发流程（重要，app适配无障碍以及处理无障碍相关问题主要通过该流程入手）。&lt;/h3&gt;
&lt;p&gt;流程：被辅助app将无障碍事件发送给辅助app，systemserver进程作为中转，接口为IAccessibilityManager.aidl和IAccessibilityServiceClient.aidl&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/sendaccessibilityevent.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因-1&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法-1&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;sendaccessibilityevent&#34;&gt;&lt;strong&gt;sendAccessibilityEvent&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;sendAccessibilityEventUnchecked&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onInitializeAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dispatchPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onRequestSendAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于talkback的无障碍服务中声明了android:canRequestTouchExplorationMode=&amp;quot;true&amp;rdquo;，因此开启talkback后AccessibilityManagerService会更新AccessibilityInputFilter成员变量的触摸浏览（FLAG_FEATURE_TOUCH_EXPLORATION）的特性为true。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.android.server.accessibility.AccessibilityInputFilter

private void enableFeatures() {
    ...
    if ((mEnabledFeatures &amp;amp; FLAG_FEATURE_TOUCH_EXPLORATION) != 0) {
        mTouchExplorer = new TouchExplorer(mContext, mAms);
        addFirstEventHandler(mTouchExplorer);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;触摸浏览特性开启后会创建一个TouchExplorer对象。AccessibilityInputFilter继承自InputFilter，对输入事件进行过滤，通过和TouchExplorer配合从而实现talkback模式下的触摸浏览手势。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * This class is a strategy for performing touch exploration. It
 * transforms the motion event stream by modifying, adding, replacing,
 * and consuming certain events. The interaction model is:
 *
 * &amp;lt;ol&amp;gt;
 *   &amp;lt;li&amp;gt;1. One finger moving slow around performs touch exploration.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;2. One finger moving fast around performs gestures.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;3. Two close fingers moving in the same direction perform a drag.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;4. Multi-finger gestures are delivered to view hierarchy.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;5. Two fingers moving in different directions are considered a multi-finger gesture.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;7. Double tapping clicks on the on the last touch explored location if it was in
 *          a window that does not take focus, otherwise the click is within the accessibility
 *          focused rectangle.&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;7. Tapping and holding for a while performs a long press in a similar fashion
 *          as the click above.&amp;lt;/li&amp;gt;
 * &amp;lt;ol&amp;gt;
 *
 * @hide
 */
class TouchExplorer extends BaseEventStreamTransformation
        implements AccessibilityGestureDetector.Listener {
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该类负责将普通的触摸事件转换为触摸浏览手势，比如将MotionEvent.ACTION_DOWN事件转换为悬停事件）（MotionEvent.ACTION_HOVER_ENTER）。因此在talkback模式下，当我们点击一次view上的控件时，应用收到的是（ACTION_HOVER_ENTER）事件，而只有双击才会传递我们熟悉的ACTION_DOWN事件&lt;/p&gt;
&lt;p&gt;*ViewRootImpl:View层次结构的根。View的&lt;strong&gt;绘制流程&lt;/strong&gt;（测量measure、布局layout、绘制draw）和输入&lt;strong&gt;事件的分发流程&lt;/strong&gt;都是从ViewRootImp开始。&lt;/p&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、ViewRootImpl的内部类WindowInputEventReceiver从native方法调起dispatchInputEvent方法。&lt;/p&gt;
&lt;p&gt;2、ViewRootImpl调用deliverInputEvent传递事件输入事件。&lt;/p&gt;
&lt;p&gt;3、从顶层的DecorView的dispatchPointerEvent开始分发输入事件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View.java

/**
 * Dispatch a pointer event.
 * &amp;lt;p&amp;gt;
 * Dispatches touch related pointer events to {@link #onTouchEvent(MotionEvent)} and all
 * other events to {@link #onGenericMotionEvent(MotionEvent)}.  This separation of concerns
 * reinforces the invariant that {@link #onTouchEvent(MotionEvent)} is really about touches
 * and should not be expected to handle other pointing device features.
 * &amp;lt;/p&amp;gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 * @hide
 */
public final boolean dispatchPointerEvent(MotionEvent event) {
    if (event.isTouchEvent()) {
        return dispatchTouchEvent(event);
    } else {
        return dispatchGenericMotionEvent(event);
    }
}

...

/**
 * Returns true if this motion event is a touch event.
 * &amp;lt;p&amp;gt;
 * Specifically excludes pointer events with action {@link #ACTION_HOVER_MOVE},
 * {@link #ACTION_HOVER_ENTER}, {@link #ACTION_HOVER_EXIT}, or {@link #ACTION_SCROLL}
 * because they are not actually touch events (the pointer is not down).
 * &amp;lt;/p&amp;gt;
 * @return True if this motion event is a touch event.
 * @hide
 */
public final boolean isTouchEvent() {
    return nativeIsTouchEvent(mNativePtr);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在dispatchPointerEvent方法中会有event.isTouchEvent()的判断，如果talkback模式下，由于收到的是ACTION_HOVER_ENTER事件，因此不会走dispatchTouchEvent方法而是dispatchGenericMotionEvent方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View.java
/**
 * Dispatch a generic motion event.
 * &amp;lt;p&amp;gt;
 * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
 * are delivered to the view under the pointer.  All other generic motion events are
 * delivered to the focused view.  Hover events are handled specially and are delivered
 * to {@link #onHoverEvent(MotionEvent)}.
 * &amp;lt;/p&amp;gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
public boolean dispatchGenericMotionEvent(MotionEvent event) {
...
    final int source = event.getSource();
    if ((source &amp;amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
        final int action = event.getAction();
        if (action == MotionEvent.ACTION_HOVER_ENTER
                || action == MotionEvent.ACTION_HOVER_MOVE
                || action == MotionEvent.ACTION_HOVER_EXIT) {
            if (dispatchHoverEvent(event)) {
                return true;
            }
        } else if (dispatchGenericPointerEvent(event)) {
            return true;
        }
    } else if (dispatchGenericFocusedEvent(event)) {
        return true;
    }
	...
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在dispatchGenericMotionEvent中，如果是Hover events，则会走到dispatchHoverEvent方法中。这个方法的机制类似dispatchTouchEvent的流程，是一个责任链模式的实现，不详细展开，默认会传到最后一个子节点的onHoverEvent方法。接着该方法会调用到sendAccessibilityHoverEvent里。&lt;/p&gt;
&lt;p&gt;3、sendAccessibilityHoverEvent方法接着会调用以下方法。&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;sendAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​       &lt;strong&gt;-&amp;gt;sendAccessibilityEventUnchecked&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;onInitializeAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;dispatchPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​                &lt;strong&gt;-&amp;gt;onPopulateAccessibilityEvent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​           &lt;strong&gt;-&amp;gt;onRequestSendAccessibilityEvent&lt;/strong&gt;（只在ViewGroup中有默认实现）&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;重要：以上六个方法为当我们自定义view时适配无障碍模式可以覆盖实现的方法，可以重写view的这些方法或者实现View.AccessibilityDelegate来解决一些特殊场景下talkback播报的问题。更详细的用法可以参考官方文档。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以talkback模式下朗读一个textview上的文字为例，textview重写了view中的onPopulateAccessibilityEventInternal方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.widget.TextView.java

/** @hide */
@Override
public void onPopulateAccessibilityEventInternal(AccessibilityEvent event) {
    super.onPopulateAccessibilityEventInternal(event);

    final CharSequence text = getTextForAccessibility();
    if (!TextUtils.isEmpty(text)) {
        event.getText().add(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getTextForAccessibility方法会取到当前textview中显示的text，然后将该text的内容填充到AccessibilityEvent中发送出去。后面talkback会取出这个text并朗读出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View

public void onPopulateAccessibilityEvent(AccessibilityEvent event) {
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.onPopulateAccessibilityEvent(this, event);
    } else {
        onPopulateAccessibilityEventInternal(event);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此如果我们需要自定义textview在talkback模式下朗读的内容，或者不让某个view的内容在talkback模式下被朗读出来，可以考虑重写onPopulateAccessibilityEvent方法。&lt;/p&gt;
&lt;p&gt;4、当我们通过第3步修改view中无障碍节点的信息后，被点击的View的sendAccessibilityEventUnchecked方法会向上通过DecorView传递到ViewRootImpl的requestSendAccessibilityEvent方法中，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl

public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {
    ...
    final int eventType = event.getEventType();
    switch (eventType) {
        case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED: {
            final long sourceNodeId = event.getSourceNodeId();
            final int accessibilityViewId = AccessibilityNodeInfo.getAccessibilityViewId(
                    sourceNodeId);
            View source = mView.findViewByAccessibilityId(accessibilityViewId);
            if (source != null) {
                AccessibilityNodeProvider provider = source.getAccessibilityNodeProvider();
                if (provider != null) {
                    final int virtualNodeId = AccessibilityNodeInfo.getVirtualDescendantId(
                            sourceNodeId);
                    final AccessibilityNodeInfo node;
                    node = provider.createAccessibilityNodeInfo(virtualNodeId);
                    setAccessibilityFocus(source, node);
                }
            }
        } break;
        ...
    }
    mAccessibilityManager.sendAccessibilityEvent(event);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着无障碍事件会通过AccessibilityManager的sendAccessibilityEvent方法跨进程调用systemserver进程的AccessibilityManagerService，将类型为TYPE_VIEW_HOVER_ENTER的AccessibilityEvent事件传递到talkback的的TalkBackService（继承自AccessibilityService）的onAccessibilityEvent方法中（或者其他实现了AccessibilityService的应用）。&lt;/p&gt;
&lt;h3 id=&#34;44执行无障碍事件流程以talkback发出focus无障碍事件到被辅助的app端通过viewrootimpl绘制绿框焦点过程进行分析&#34;&gt;4.4、执行无障碍事件流程（以talkback发出focus无障碍事件，到被辅助的app端通过ViewRootImpl绘制绿框焦点过程进行分析）。&lt;/h3&gt;
&lt;p&gt;流程：辅助app（talkback）将无障碍事件发送给被辅助app，systemserver进程作为中转，接口为IAccessibilityServiceConnection.aidl和IAccessibilityInteractionConnection.aidl&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/requesfocus.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;分析该流程原因-2&#34;&gt;分析该流程原因：&lt;/h5&gt;
&lt;h5 id=&#34;为了辅助理解如下方法-2&#34;&gt;为了辅助理解如下方法：&lt;/h5&gt;
&lt;h5 id=&#34;accessibilitynodeinfoperformaction&#34;&gt;AccessibilityNodeInfo.performAction&lt;/h5&gt;
&lt;p&gt;主要流程分析：&lt;/p&gt;
&lt;p&gt;1、在talkback中有个AccessibilityEventProcessor类对无障碍事件进行集中处理，根据无障碍事件的不同类型分发到不同的处理器进行处理，比如ProcessorFocusAndSingleTap这个处理器会对类型为TYPE_VIEW_HOVER_ENTER的无障碍事件进行处理，ProcessorEventQueue（主要用于tts朗读，后面分析）这个处理器会处理所有的无障碍事件。&lt;/p&gt;
&lt;p&gt;2、在前面一节4.2中，触摸事件TYPE_VIEW_HOVER_ENTER传递到了TalkBackService，而ProcessorFocusAndSingleTap这个类会对TYPE_VIEW_HOVER_ENTER这个事件进行处理，tryFocusing函数中会调用AccessibilityNodeInfo的performAction方法，AccessibilityNodeInfo的节点信息就是4.2节中触摸到的view的信息，因此通过AccessibilityManagerService进程中转后，会最终调用到我们触摸到的view的&lt;strong&gt;performAccessibilityAction&lt;/strong&gt;方法中去（我们也可以通过调用这个方法处理一些无障碍焦点的问题）。&lt;/p&gt;
&lt;p&gt;3、在performAccessibilityAction会调用到performAccessibilityActionInternal，接着如果判断到是ACTION_ACCESSIBILITY_FOCUS事件，则会调用requestAccessibilityFocus函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.View

public boolean requestAccessibilityFocus() {
    ...
    if ((mPrivateFlags2 &amp;amp; PFLAG2_ACCESSIBILITY_FOCUSED) == 0) {
        mPrivateFlags2 |= PFLAG2_ACCESSIBILITY_FOCUSED;
        ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            viewRootImpl.setAccessibilityFocus(this, null);
        }
        invalidate();
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数里有两个重要的操作，一是调用ViewRootImpl的setAccessibilityFocus将自身设置为focus的view，然后调用invalidate触发重绘操作，ViewRootImpl会在onPostDraw中执行drawAccessibilityFocusedDrawableIfNeeded来绘制出绿框。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.view.ViewRootImpl.java

/**
 * We want to draw a highlight around the current accessibility focused.
 * Since adding a style for all possible view is not a viable option we
 * have this specialized drawing method.
 *
 * Note: We are doing this here to be able to draw the highlight for
 *       virtual views in addition to real ones.
 *
 * @param canvas The canvas on which to draw.
 */
private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas) {
    final Rect bounds = mAttachInfo.mTmpInvalRect;
    if (getAccessibilityFocusedRect(bounds)) {
        final Drawable drawable = getAccessibilityFocusedDrawable();
        if (drawable != null) {
            drawable.setBounds(bounds);
            drawable.draw(canvas);
        }
    } else if (mAttachInfo.mAccessibilityFocusDrawable != null) {
        mAttachInfo.mAccessibilityFocusDrawable.setBounds(0, 0, 0, 0);
    }
}

private boolean getAccessibilityFocusedRect(Rect bounds) {
    final AccessibilityManager manager = AccessibilityManager.getInstance(mView.mContext);
    if (!manager.isEnabled() || !manager.isTouchExplorationEnabled()) {
        return false;
    }

    final View host = mAccessibilityFocusedHost;
    if (host == null || host.mAttachInfo == null) {
        return false;
    }

    final AccessibilityNodeProvider provider = host.getAccessibilityNodeProvider();
    if (provider == null) {
        host.getBoundsOnScreen(bounds, true);
    } else if (mAccessibilityFocusedVirtualView != null) {
        mAccessibilityFocusedVirtualView.getBoundsInScreen(bounds);
    } else {
        return false;
    }

    // Transform the rect into window-relative coordinates.
    final AttachInfo attachInfo = mAttachInfo;
    bounds.offset(0, attachInfo.mViewRootImpl.mScrollY);
    bounds.offset(-attachInfo.mWindowLeft, -attachInfo.mWindowTop);
    if (!bounds.intersect(0, 0, attachInfo.mViewRootImpl.mWidth,
            attachInfo.mViewRootImpl.mHeight)) {
        // If no intersection, set bounds to empty.
        bounds.setEmpty();
    }
    return !bounds.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个操作是调用sendAccessibilityEvent方法，将TYPE_VIEW_ACCESSIBILITY_FOCUSED事件发送出去，这个事件会被talkback处理，从而调用tts引擎读出view的内容，这个流程分析如下。&lt;/p&gt;
&lt;h3 id=&#34;45talkback调用tts读出view中的text的过程&#34;&gt;4.5、talkback调用TTS读出view中的text的过程。&lt;/h3&gt;
&lt;p&gt;由于talkback最新版本属于google维护，没有开源代码，网上公开的只有talkback6.0版本的代码，因此基于6.0版本的概要分析如下&lt;/p&gt;
&lt;p&gt;无障碍事件的分发跟4.2节流程一样，talkback处理TYPE_VIEW_ACCESSIBILITY_FOCUSED事件大致流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/xuanliangdev/blogpic/blob/master/accessibility/talkbacktts.jpg?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;talkback调用tts进行朗读主要通过com.google.android.accessibility.compositor.Compositor这个类来控制，这个类中又有一个ParseTree的类来管理朗读的内容，ParseTree通过一个compositor.json的文件来定义朗读的内容的规则，比如一个简单的按钮，在talkback模式下不仅需要读出按钮的内容，还需要读出按钮的状态（比如disabled），因此朗读的内容是一个拼接起来的结果，比如下面就是通过解析compositor.json来读出一个按钮内容的大概流程。&lt;/p&gt;
&lt;p&gt;以下在compositor.json中某几个节点类型的定义，&lt;/p&gt;
&lt;p&gt;$开头会被解析成ParseTreeVariableNode，比如 &amp;ldquo;node.text&amp;quot;经过ParseTreeVariableNode的处理会取出Button中text（也就是AccessibilityEvent中AccessibilityNodeInfo中的mText）&lt;/p&gt;
&lt;p&gt;@开头会被解析成ParseTreeResourceNode，最后会通过Resource取出字段的内容，比如&amp;rdquo;@string/value_button&amp;quot;中文下会被解析为“按钮”，&lt;/p&gt;
&lt;p&gt;&amp;ldquo;@string/value_disabled&amp;quot;中文下会被解析为“已停用”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     &amp;quot;notify_disabled&amp;quot;: {
      &amp;quot;if&amp;quot;: &amp;quot;$node.isActionable &amp;amp;&amp;amp; !$node.isEnabled&amp;quot;,
      &amp;quot;then&amp;quot;: &amp;quot;@string/value_disabled&amp;quot;
     },

....

     &amp;quot;get_node_text&amp;quot;: {  // AccessibilityNodeInfoUtils.getNodeText()
      &amp;quot;fallback&amp;quot;: [
        {
          // If focusing on-screen keyboard key... apply speak-passwords policy to hide key name.
          &amp;quot;if&amp;quot;: &amp;quot;$event.sourceIsKeyboard &amp;amp;&amp;amp; $global.lastTextEditIsPassword &amp;amp;&amp;amp; !$global.speakPasswordOnAndroidShowingPasswords&amp;quot;,
          &amp;quot;then&amp;quot;: &amp;quot;@string/symbol_bullet&amp;quot;,
          &amp;quot;else&amp;quot;: &amp;quot;$node.contentDescription&amp;quot;
        },
        &amp;quot;$node.text&amp;quot;
      ]
    },
    &amp;quot;get_role_description_or_default&amp;quot;: {
      &amp;quot;fallback&amp;quot;: [
        &amp;quot;$node.roleDescription&amp;quot;,
        &amp;quot;%node_role&amp;quot;
      ]
    },
    &amp;quot;node_role&amp;quot;: {
      &amp;quot;switch&amp;quot;: &amp;quot;$node.role&amp;quot;,
      &amp;quot;cases&amp;quot;: {
        &amp;quot;button&amp;quot;: &amp;quot;@string/value_button&amp;quot;,
        &amp;quot;check_box&amp;quot;: &amp;quot;@string/value_checkbox&amp;quot;,
        &amp;quot;drop_down_list&amp;quot;: &amp;quot;@string/value_spinner&amp;quot;,
        &amp;quot;edit_text&amp;quot;: &amp;quot;@string/value_edit_box&amp;quot;,
        &amp;quot;grid&amp;quot;: &amp;quot;@string/value_gridview&amp;quot;,
        &amp;quot;image&amp;quot;: &amp;quot;@string/value_image&amp;quot;,
        &amp;quot;image_button&amp;quot;: &amp;quot;@string/value_button&amp;quot;, // Same as |button|
        &amp;quot;list&amp;quot;: &amp;quot;@string/value_listview&amp;quot;,
        &amp;quot;pager&amp;quot;: &amp;quot;@string/value_pager&amp;quot;,
        &amp;quot;progress_bar&amp;quot;: &amp;quot;@string/value_progress_bar&amp;quot;,
        &amp;quot;radio_button&amp;quot;: &amp;quot;@string/value_radio_button&amp;quot;,
        &amp;quot;seek_control&amp;quot;: &amp;quot;@string/value_seek_bar&amp;quot;,
        &amp;quot;switch&amp;quot;: &amp;quot;@string/value_switch&amp;quot;,
        &amp;quot;tab_bar&amp;quot;: &amp;quot;@string/value_tabwidget&amp;quot;,
        &amp;quot;toggle_button&amp;quot;: &amp;quot;@string/value_switch&amp;quot;, // Same as |switch|
        &amp;quot;view_group&amp;quot;: &amp;quot;&amp;quot;, // None
        &amp;quot;web_view&amp;quot;: &amp;quot;@string/value_webview&amp;quot;,
        &amp;quot;checked_text_view&amp;quot;: &amp;quot;&amp;quot; // None
      }
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ttsOutput&lt;/p&gt;
&lt;p&gt;TYPE_VIEW_ACCESSIBILITY_FOCUSED&lt;/p&gt;
&lt;p&gt;get_description_for_tree&lt;/p&gt;
&lt;p&gt;​        StateNameRolePosition&lt;/p&gt;
&lt;p&gt;​              tree_description_with_label&lt;/p&gt;
&lt;p&gt;​                 append_description_for_tree&lt;/p&gt;
&lt;p&gt;​                 |  &amp;ldquo;conditionalPrepend(%description_for_tree_status, %description_for_tree_nodes)&amp;rdquo;&lt;/p&gt;
&lt;p&gt;​                 |      description_for_tree_nodes&lt;/p&gt;
&lt;p&gt;​                 |           get_description_for_node&lt;/p&gt;
&lt;p&gt;​                 |             rule_default&lt;/p&gt;
&lt;p&gt;​                 |                node_text_and_role&lt;/p&gt;
&lt;p&gt;​                 |                    rule_view_group（%get_node_text）&lt;/p&gt;
&lt;p&gt;​                 |                    |    &amp;ldquo;$node.text&amp;rdquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;取出“Button的text”&lt;/p&gt;
&lt;p&gt;​                 |                    get_role_description_or_default&lt;/p&gt;
&lt;p&gt;​                 |                    |     %node_role&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-取出“按钮的String资源”&lt;/p&gt;
&lt;p&gt;​                  notify_disabled&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-取出“已停用的String资源”&lt;/p&gt;
&lt;p&gt;最后talkback朗读“xxx，按钮，已停用”&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>从Android项目学习设计模式</title>
      <link>https://xuanliangdev.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>&lt;h1 id=&#34;从android项目学习设计模式&#34;&gt;从Android项目学习设计模式&lt;/h1&gt;
&lt;p&gt;这个月看了一遍《Android源码设计模式解析与实战》，又一次被android中framework层的设计震惊了，也得到了一些学习的心得体会，“想要理解一个概念，要先理解why，然后才深入how，不能深入细节而忘了初衷”。&lt;/p&gt;
&lt;h2 id=&#34;面向对象六大原则&#34;&gt;面向对象六大原则&lt;/h2&gt;
&lt;p&gt;设计模式其实就是面向对象的六大原则的体现。&lt;/p&gt;
&lt;p&gt;S:单一职责（Single Responsibility Principle）一个类的职责应该只有一个。&lt;/p&gt;
&lt;p&gt;O：开闭原则（Open Close Principle）一个对象应该对修改是封闭的，对扩展是开放的。（使用接口实现）&lt;/p&gt;
&lt;p&gt;L：里氏替换（Liskov Substitution Principle）（子类能替换父类）&lt;/p&gt;
&lt;p&gt;I：接口隔离（Interface Segregation Principle）(类依赖应该建立在最小接口上)&lt;/p&gt;
&lt;p&gt;D：依赖倒置（Dependence Inversion Principle）（参考UML图，使用类指向被依赖的类，倒置后使用类指向接口，实现类也指向接口）&lt;/p&gt;
&lt;p&gt;迪米特原则(Law of Demeter)一个对象应该与其他对象有最少的了解（参考中介模式，）&lt;/p&gt;
&lt;h3 id=&#34;一创建型模式&#34;&gt;一、创建型模式&lt;/h3&gt;
&lt;h4 id=&#34;1singleton单例&#34;&gt;1、Singleton（单例）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader（双重校验锁DCL），ActivityThread，ActivityManagerNative（懒汉式），WindowManagerGlobal（懒汉式）&lt;/p&gt;
&lt;p&gt;懒汉式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Singleton&amp;lt;T&amp;gt; {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
           if (mInstance == null) {
               mInstance = create();
           }
           return mInstance;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DCL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Singleton {
    private static volatile Singleton mInstance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (mInstance == null) {
            synchronized(Singleton.class) {
                if (mInstance == null) {
                    mInstance = new Singleton();
                }
            }
        }
        return mInstance;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Singleton {
    private Singleton() {}
    private static class SingletonHolder {
        private static Singleton mInstance = new Singleton();
    }
    public static Singleton getInstance() {
        return SingletonHolder.mInstance;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2factory-method工厂方法&#34;&gt;2、Factory Method（工厂方法）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/fc9a8e83d034a89a71476498c9846d97.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际应用：BitmapFactory（简单工厂或静态工厂），Iterable&lt;/p&gt;
&lt;p&gt;有的书上说简单工厂并不算工厂模式，真正意义上的工厂方法模式里，“工厂方法”其实是一个抽象方法，该模式拥有不同的工厂类，不同的工厂类实现了各自的工厂方法，例如ArrayListIterator，LinkIterator都可以算是一个工厂，next方法，previous方法都可以看做是一个工厂方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FactoryMethon {
    public static void main(String[] args) {
        // 简单工厂
        Product p = SimpleFactory.create(&amp;quot;A&amp;quot;);
        p.method();
        // 工厂方法
        Factory f = new ConreteFactoryA();
        p = f.create();
        p.method();
        f = new ConreteFactoryB();
        p = f.create();
        p.method();
    }
}

abstract class Product {
    abstract void method();
}

class ConcreteProductA extends Product {

    @Override
    void method() {
        System.out.println(&amp;quot;ConcreteProductA&amp;quot;);
    }
}

class ConcreteProductB extends Product {

    @Override
    void method() {
        System.out.println(&amp;quot;ConcreteProductB&amp;quot;);
    }
}

// 简单工厂
class SimpleFactory {
    public static Product create(String s) {
        if (&amp;quot;A&amp;quot;.equals(s))
            return new ConcreteProductA();
        if (&amp;quot;B&amp;quot;.equals(s))
            return new ConcreteProductB();
        else
            return null;
    }

}

// 工厂方法
abstract class Factory {
    abstract Product create();
}

class ConreteFactoryA extends Factory {
    Product create() {
        return new ConcreteProductA();
    }
}

class ConreteFactoryB extends Factory {
    Product create() {
        return new ConcreteProductB();
    }
}

//ouput:
ConcreteProductA
ConcreteProductA
ConcreteProductB
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3abstract-factory抽象工厂&#34;&gt;3、Abstract Factory（抽象工厂）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/91e85c0c1e75112413c4223aa29efd0e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际应用：MediaPlayerFactory&lt;/p&gt;
&lt;p&gt;抽象工厂相比于工厂方法，多了产品簇的概念，工厂方法是为了当出现新的工厂时可以用很小的代价进行扩展（比如生产智能手机实现了一个createPhone的抽象工厂方法，一开始只有ios和android的工厂实现该方法，当出现新的winphone系统时，只要新建一个winphone工厂来实现createPhone方法就行，代价很小），第一层抽象是根据手机系统的不同，但是如果产品之间也有关联，比如三种系统生产的手机都各自分为高端机型，中端机型，低端机型，这时出现了第二个层次的抽象，高、中、低分别可以抽象出一个接口，再实现三个抽象工厂方法分别生产高、中、低端的手机。&lt;/p&gt;
&lt;p&gt;抽象工厂有利于交换产品系列（从一个系统的高端机换到另一系统的高端机），有利于产品一致性（当一个系列的产品被设计成一起工作时）。&lt;/p&gt;
&lt;p&gt;抽象工厂不利于接入新的工厂，因为如果新工厂只打算生产低端机，也必须实现生产中端、高端机的接口。&lt;/p&gt;
&lt;p&gt;（和工厂方法的明显区别，抽象工厂生产的产品比工厂方法生产的产品多了一层抽象，工厂方法：手机&amp;lt;-android手机，抽象工厂：手机&amp;lt;-高端机&amp;lt;-android手机）&lt;/p&gt;
&lt;h4 id=&#34;4builder创建者&#34;&gt;4、Builder（创建者）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader(ImageLoaderConfiguration.Builder) AlertDialog（AlertDialog.Builder）&lt;/p&gt;
&lt;p&gt;builder中链式调用进行配置，最后通过build方法或create方法生成对象并返回。其实就是通过builder对象的相关方法对各个配置项进行配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BulderPattern {

    public static void main(String[] args) {
        new Dialog.Builder().setTitle(&amp;quot;Title&amp;quot;).setMessage(&amp;quot;Message&amp;quot;).build().show();
    }
}

class Dialog {
    String title = &amp;quot;defaultTitle&amp;quot;;
    String message = &amp;quot;defaultMessage&amp;quot;;

    public void show() {
        System.out.println(title + &amp;quot; &amp;quot; + message);
    }

    public static class Builder {
        private Dialog mD;

        Builder() {
            mD = new Dialog();
        }

        Builder setTitle(String title) {
            mD.title = title;
            return this;
        }

        Builder setMessage(String message) {
            mD.message = message;
            return this;
        }

        Dialog build() {
            return mD;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5prototype原型&#34;&gt;5、Prototype（原型）&lt;/h4&gt;
&lt;p&gt;实际应用：clone方法 Intent的clone方法是通过new自身来实现的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public Object clone() {
    return new Intent(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二结构型模式&#34;&gt;二、结构型模式&lt;/h3&gt;
&lt;h4 id=&#34;6adapter适配器&#34;&gt;6、Adapter（适配器）&lt;/h4&gt;
&lt;p&gt;实际应用：ListView中的Adapter&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AdapterPettern {

    public static void main(String[] args) {
        Target t = new Adapter();
        t.method();
    }
}

interface Target {
    void method();
}

class Adaptee {
    public void methodA() {
        System.out.println(&amp;quot;Adaptee Menthod&amp;quot;);
    };
}

class Adapter implements Target {
    Adaptee a = new Adaptee();

    @Override
    public void method() {
        a.methodA();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7bridge桥接&#34;&gt;7、Bridge（桥接）&lt;/h4&gt;
&lt;p&gt;实际应用：经常用在一些imp类中，比如WindowManagerImp（感觉其实没必要设计WindowManager接口）&lt;/p&gt;
&lt;p&gt;*这个设计模式对于理解android framework的很多设计相当有帮助，可以扩展到其他一些框架的接口类和相关的Imp类进行分析。 用于多维度变化类或者多个树状类之间的耦合的解耦。一个类存在两个独立变化的维度，并且两个维度都需要扩展。&lt;/p&gt;
&lt;p&gt;（想到了一个问题，只被一个类继承的接口到底有没有必要把接口抽象出来，比如WindowManagerImpl和WindowManager，有没有必要把WindowManager接口提取出来）&lt;/p&gt;
&lt;p&gt;这个模式诠释了（多用组合，少用继承）的好处&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Bridge {

    public static void main(String[] args) {
        //两个维度，Size和Additive
        LargeCoffee lc = new LargeCoffee(new Additives() {
        });
        lc.makeCoffee();
		
        Suger suger = new Suger();
        lc = new LargeCoffee(suger);
        lc.makeCoffee();
    }
}

abstract class Coffee {
    Additives add;

    Coffee(Additives add) {
        this.add = add;
    }

    abstract void makeCoffee();
}

abstract class Additives {
    String addSomething() {
        return &amp;quot;Nothing&amp;quot;;
    };
}

class Suger extends Additives {

    @Override
    String addSomething() {
        return &amp;quot;Suger&amp;quot;;
    }
}

class LargeCoffee extends Coffee {
    LargeCoffee(Additives add) {
        super(add);
    }

    @Override
    void makeCoffee() {
        System.out.println(&amp;quot;Large &amp;quot; + add.addSomething());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;8composite组成&#34;&gt;8、Composite（组成）&lt;/h4&gt;
&lt;p&gt;实际应用：View和ViewGroup&lt;/p&gt;
&lt;p&gt;ViewGrop继承于View，并且已聚合的方式包含View&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class View {
    public void create() {
    };
}

abstract class ViewGroup extends View {
    private ArrayList&amp;lt;View&amp;gt; views = new ArrayList&amp;lt;View&amp;gt;();

    public void addView(View v) {
        views.add(v);
    };

    public void removeView(View v) {
        views.remove(v);
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;9decorator装饰&#34;&gt;9、Decorator（装饰）&lt;/h4&gt;
&lt;p&gt;实际应用：Context和ContextWrapper，java中的各种输入输出流&lt;/p&gt;
&lt;p&gt;包装器Wrapper中包含实际对象的引用，并调用实际对象引用的方法，并对实际对象进行功能扩展。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Decorator {

    public static void main(String[] args) {
        ContextImpl ctImp = new ContextImpl();
        new ContextThemeWrapper(ctImp).doSomething();
    }
}

abstract class Context {
    abstract void doSomething();
}

class ContextImpl extends Context {
    void doSomething() {
        System.out.println(&amp;quot;ContextImpl doSomething&amp;quot;);
    };
}

class ContextWrapper extends Context {
    Context mBase;

    ContextWrapper(Context context) {
        mBase = context;
    }

    void doSomething() {
        mBase.doSomething();
    }
}

class ContextThemeWrapper extends ContextWrapper {

    ContextThemeWrapper(Context context) {
        super(context);
    }

    void doSomething() {
        super.doSomething();
        System.out.println(&amp;quot;ContextThemeWrapper doSomething&amp;quot;);
    }
}
//output:
ContextImpl doSomething
ContextThemeWrapper doSomething
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;10facade外观&#34;&gt;10、Facade（外观）&lt;/h4&gt;
&lt;p&gt;实际应用：ContextImpl（管理ActivityManagerNative，PackageManager，ResourcesManager等子系统）&lt;/p&gt;
&lt;p&gt;提供了一个高层次接口，方便各个子系统的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/166ddb9730698785966723efb3d8b8a8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ContextImpl {
    AMS ams;
    PKMS pkms;

    void startActivities() {
        ams.startActivity();
    };

    void getPackageManager() {
        pkms.getPackageManager();
    }

}

class AMS {
    void startActivity() {
        System.out.println(&amp;quot;startActivity&amp;quot;);
    };
}

class PKMS {
    void getPackageManager() {
        System.out.println(&amp;quot;getPackageManager&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ContextImpl相当于一个外观模式，Wrapper类是装饰器模式&lt;/p&gt;
&lt;h4 id=&#34;11flyweight享元&#34;&gt;11、Flyweight（享元）&lt;/h4&gt;
&lt;p&gt;实际应用：Message的重用，JDK中的String对象的常量池&lt;/p&gt;
&lt;p&gt;对象池的一种实现，比如一篇word文档中有一万个字符，创建一万个字符对象代价就太大了。通常和state模式或strategy模式一起使用&lt;/p&gt;
&lt;h4 id=&#34;12proxy代理&#34;&gt;12、Proxy（代理）&lt;/h4&gt;
&lt;p&gt;实际应用：Binder&lt;/p&gt;
&lt;p&gt;对于理解Binder机制很有帮助。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Proxy {

    public static void main(String[] args) {
        RealSub rs = new RealSub();
        ProxySub ps = new ProxySub(rs);
        ps.visit();
    }
}

abstract class Sub {
    abstract void visit();
}

class RealSub extends Sub {
    @Override
    void visit() {
        System.out.println(&amp;quot;RealVisit&amp;quot;);
    }
}

class ProxySub extends Sub {
    RealSub sub;

    ProxySub(RealSub sub) {
        this.sub = sub;
    }

    @Override
    void visit() {
        sub.visit();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三行为模式&#34;&gt;三、行为模式&lt;/h3&gt;
&lt;h4 id=&#34;13chain-of-responsibility责任链对象行为&#34;&gt;13、chain of responsibility（责任链）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：事件分发机制，比如屏幕的触摸事件&lt;/p&gt;
&lt;p&gt;要点是当前Handler保持一个下一节点Handler的引用，当前节点处理不了则把消息分发给下一节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ChainOfResponsibility {

    public static void main(String[] args) {
        Request1 r1 = new Request1();
        Request2 r2 = new Request2();

        Handler1 h1 = new Handler1();
        Handler2 h2 = new Handler2();
        h1.next = h2;
        h1.handlerRequest(r1);
        h1.handlerRequest(r2);
    }

}

abstract class AbsHandler {
    AbsHandler next;

    void handlerRequest(AbsRequest req) {
        if (getHanlderLevel() == req.getRequestLevel()) {
            handle(req);
        } else {
            next.handle(req);
        }
    }

    abstract String getHanlderLevel();

    abstract void handle(AbsRequest req);
}

class Handler1 extends AbsHandler {

    @Override
    String getHanlderLevel() {
        return &amp;quot;1&amp;quot;;
    }

    @Override
    void handle(AbsRequest req) {
        System.out.println(&amp;quot;Handler1 handle&amp;quot;);

    }
}

class Handler2 extends AbsHandler {

    @Override
    String getHanlderLevel() {
        return &amp;quot;2&amp;quot;;
    }

    @Override
    void handle(AbsRequest req) {
        System.out.println(&amp;quot;Handler2 handle&amp;quot;);
    }

}

abstract class AbsRequest {
    abstract String getRequestLevel();
}

class Request1 extends AbsRequest {

    @Override
    String getRequestLevel() {
        return &amp;quot;1&amp;quot;;
    }
}

class Request2 extends AbsRequest {

    @Override
    String getRequestLevel() {
        return &amp;quot;2&amp;quot;;
    }

}
//output:
Handler1 handle
Handler2 handle
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;14command命令对象行为&#34;&gt;14、command（命令）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：PackageManagerService中的MeasureParams、InstallParams和MoveParams&lt;/p&gt;
&lt;p&gt;通过把请求封装成对象，不同的命令对象子类持有各自的接收者，接受者可以相同也可以不同，然后不同的命令对象中，接收者执行不同的具体操作。&lt;/p&gt;
&lt;p&gt;command模式是过程语言中回调（callback）机制的一个面向对象的替代品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CommandPattern {

    public static void main(String[] args) {
        Car car = new Car();
        LeftCommand left = new LeftCommand(car);
        RightCommand right = new RightCommand(car);
        BackCommand back = new BackCommand(car);
        ForwardCommand forward = new ForwardCommand(car);

        Handler h = new Handler(car);
        h.setBack(back);
        h.setForward(forward);
        h.setLeft(left);
        h.setRight(right);

        h.toBack();
        h.toLeft();
        h.toForward();
        h.toRight();
		
        h.undo();
        h.undo();
        h.undo();
        h.undo();
    }
}

class Car {

    void toLeft() {
        System.out.println(&amp;quot;toLeft&amp;quot;);
    }

    void toRight() {
        System.out.println(&amp;quot;toRight&amp;quot;);
    }

    void toForward() {
        System.out.println(&amp;quot;toForward&amp;quot;);
    }

    void toBack() {
        System.out.println(&amp;quot;toBack&amp;quot;);
    }
}

interface Command {
    void execute();
    void undo();
}

class LeftCommand implements Command {
    Car car;

    public LeftCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toLeft();
    }

    @Override
    public void undo() {
        car.toRight();
		
    }
}

class RightCommand implements Command {
    Car car;

    public RightCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toRight();
    }

    @Override
    public void undo() {
        car.toLeft();
		
    }
}

class ForwardCommand implements Command {
    Car car;

    public ForwardCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toForward();
    }

    @Override
    public void undo() {
        car.toBack();
		
    }
}

class BackCommand implements Command {
    Car car;

    public BackCommand(Car car) {
        super();
        this.car = car;
    }

    @Override
    public void execute() {
        car.toBack();
    }

    @Override
    public void undo() {
        car.toForward();
		
    }
}

class Handler {
    Car car;
    LeftCommand left;
    RightCommand right;
    BackCommand back;
    ForwardCommand forward;
    ArrayList&amp;lt;Command&amp;gt; commandList = new ArrayList&amp;lt;&amp;gt;();
    Handler(Car car) {
        this.car = car;
    }

    public void setLeft(LeftCommand left) {
        this.left = left;
    }

    public void setRight(RightCommand right) {
        this.right = right;
    }

    public void setBack(BackCommand back) {
        this.back = back;
    }

    public void setForward(ForwardCommand forward) {
        this.forward = forward;
    }

    void toLeft() {
        left.execute();
        commandList.add(left);
    }

    void toRight() {
        right.execute();
        commandList.add(right);
    }

    void toBack() {
        back.execute();
        commandList.add(back);
    }

    void toForward() {
        forward.execute();
        commandList.add(forward);
    }
	
    void undo(){
        if(commandList.size() &amp;gt; 0){
            commandList.get(commandList.size() - 1).undo();
            commandList.remove(commandList.size() - 1);
        }
    }
}
//output:
toBack
toLeft
toForward
toRight
toLeft
toBack
toRight
toForward
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;15interpreter解释器类行为&#34;&gt;15、interpreter（解释器）（类行为）&lt;/h4&gt;
&lt;p&gt;实际应用：xml解释器&lt;/p&gt;
&lt;p&gt;经常会用到一些正则表达式进行字符串匹配，比较复杂&lt;/p&gt;
&lt;h4 id=&#34;16iterator迭代器对象行为&#34;&gt;16、iterator（迭代器）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：容器对象的遍历&lt;/p&gt;
&lt;h4 id=&#34;17mediator中介者对象行为&#34;&gt;17、mediator（中介者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：KeyguardViewMediator&lt;/p&gt;
&lt;p&gt;将两个对象直接的操作通过实现一个中介者进行解耦。具体客户类都持有一个中介者对象，中介者持有具体客户类对象。缺点是中介者封装了协议，比任何一个客户类都复杂，业务太多的话会变得难以维护。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MediatorPattern {

    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();
        Owner owner = new Owner(mediator);
        Render render = new Render(mediator);
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
        render.action();
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
        owner.action();
        System.out.println(&amp;quot;mediator has money : &amp;quot; + mediator.money);
    }

}

abstract class Trader {
    Mediator m;

    abstract void action();
}

class Owner extends Trader {

    public Owner(ConcreteMediator m) {
        this.m = m;
    }

    @Override
    void action() {
        m.giveMoney(100);
        System.out.println(&amp;quot;Owner receive money from mediator&amp;quot;);
    }

}

class Render extends Trader {

    public Render(ConcreteMediator m) {
        this.m = m;
    }

    @Override
    void action() {
        m.receiveMoney(100);
        System.out.println(&amp;quot;Render give money to mediator&amp;quot;);

    }

}

abstract class Mediator {
    Owner owner;
    Render render;

    abstract void receiveMoney(int money);

    abstract void giveMoney(int money);
}

class ConcreteMediator extends Mediator {
    int money = 0;

    @Override
    void receiveMoney(int money) {
        this.money += money;
    }

    @Override
    void giveMoney(int money) {
        this.money -= money;

    }
}
//output:
mediator has money : 0
Render give money to mediator
mediator has money : 100
Owner receive money from mediator
mediator has money : 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;18memento备忘录对象行为&#34;&gt;18、memento（备忘录）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：onSaveInstanceState（activity相当于caretaker，Bundle相当于memento，各种UI信息相当于originator）&lt;/p&gt;
&lt;p&gt;通过实现一个备忘录（memento）对象，保存原发器（originator）的状态，caretaker负责管理memento。&lt;/p&gt;
&lt;p&gt;*变量以及状态封装成对象进行保存&lt;/p&gt;
&lt;h4 id=&#34;19observer观察者对象行为&#34;&gt;19、observer（观察者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：ListView&lt;/p&gt;
&lt;p&gt;BaseAdapter创建的时候会同时创建一个DataSetObservable（被观察者），当listview调用setAdapter时会创建一个AdapterDataSetObserver（观察者），当Adapter调用notifyDataSetChanged时，被观察者调用notifyChanged遍历通知所有观察者执行onChanged方法，然后观察者会执行重新布局的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ObserverPattern {
    public static void main(String[] args) {
        ConcreteObserver osr1 = new ConcreteObserver(&amp;quot;osr1&amp;quot;);
        ConcreteObserver osr2 = new ConcreteObserver(&amp;quot;osr2&amp;quot;);
        ConcreteSubject sub = new ConcreteSubject();
        sub.attach(osr1);
        sub.attach(osr2);
        sub.notifyObservers();
    }
}

interface Observer {
    void update(Subject o, String arg);
}

class ConcreteObserver implements Observer {
    String name;

    public ConcreteObserver(String name) {
        super();
        this.name = name;
    }

    @Override
    public void update(Subject o, String arg) {
        System.out.println(name + &amp;quot; receive: &amp;quot; + arg);
    }
}

abstract class Subject {
    abstract void attach(Observer observer);

    abstract void detach(Observer observer);

    abstract void notifyObservers();
}

class ConcreteSubject extends Subject {
    ArrayList&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @Override
    void attach(Observer observer) {
        list.add(observer);
    }

    @Override
    void detach(Observer observer) {
        list.remove(observer);
    }

    @Override
    void notifyObservers() {
        for (Observer observer : list) {
            observer.update(this, &amp;quot;new content!&amp;quot;);
        }
    }
}
//output:
osr1 receive: new content!
osr2 receive: new content!
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;20state状态对象行为&#34;&gt;20、state（状态）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：WifiStateMachine&lt;/p&gt;
&lt;p&gt;状态模式把对象行为包装在不同的状态对象里，意图是让一个对象在内部状态改变的时候行为也跟着改变。&lt;/p&gt;
&lt;p&gt;*状态封装成接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class State {

    public static void main(String[] args) {
        TvController tvController = new TvController();
        tvController.downVolme();
        tvController.powerOn();
        tvController.downVolme();
        tvController.powerOff();
        tvController.preChannel();
        tvController.powerOn();
        tvController.nextChannel();
    }
}

interface TvState{
    void upVolume();
    void downVolme();
    void nextChannel();
    void preChannel();
}

class PowerOffState implements TvState{

    @Override
    public void upVolume() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void downVolme() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void nextChannel() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }

    @Override
    public void preChannel() {
        System.out.println(&amp;quot;TV is PowerOff&amp;quot;);
    }
}

class PowerOnState implements TvState{

    @Override
    public void upVolume() {
        System.out.println(&amp;quot;upVolume&amp;quot;);
    }

    @Override
    public void downVolme() {
        System.out.println(&amp;quot;downVolme&amp;quot;);
    }

    @Override
    public void nextChannel() {
        System.out.println(&amp;quot;nextChannel&amp;quot;);
    }

    @Override
    public void preChannel() {
        System.out.println(&amp;quot;preChannel&amp;quot;);
    }
}

class TvController implements TvState{
    TvState tvState = new PowerOffState();;
    public void powerOn(){
        tvState = new PowerOnState();
        System.out.println(&amp;quot;PowerOn TV!&amp;quot;);
    }
	
    public void powerOff(){
        tvState = new PowerOffState();
        System.out.println(&amp;quot;PowerOff TV!&amp;quot;);
    }

    @Override
    public void upVolume() {
        tvState.upVolume();
    }

    @Override
    public void downVolme() {
        tvState.downVolme();
    }

    @Override
    public void nextChannel() {
        tvState.nextChannel();
    }

    @Override
    public void preChannel() {
        tvState.preChannel();
    }
}
//output:
TV is PowerOff
PowerOn TV!
downVolme
PowerOff TV!
TV is PowerOff
PowerOn TV!
nextChannel
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;21strategy策略对象行为&#34;&gt;21、strategy（策略）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：ImageLoader中的各种MemoryCache算法，android实现动画效果的各种插值器算法。&lt;/p&gt;
&lt;p&gt;对算法进行封装，让各个算法直接可以相互替换。&lt;/p&gt;
&lt;p&gt;*方法封装成对象&lt;/p&gt;
&lt;h4 id=&#34;22template-method模板方法类行为&#34;&gt;22、template method（模板方法）（类行为）&lt;/h4&gt;
&lt;p&gt;实际应用：asyncTask，Activity（生命周期方法）&lt;/p&gt;
&lt;p&gt;定义一个算法框架，让其实现延迟到子类。&lt;/p&gt;
&lt;h4 id=&#34;23visitor访问者对象行为&#34;&gt;23、visitor（访问者）（对象行为）&lt;/h4&gt;
&lt;p&gt;实际应用：注解框架的实现（ButterKnife）&lt;/p&gt;
&lt;p&gt;是为了将数据操作与数据结构分离的模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class VisitorPattern {

    public static void main(String[] args) {
        Report report = new Report();
        report.showReport(new VisitorA());
        System.out.println(&amp;quot;----------------&amp;quot;);
        report.showReport(new VisitorB());
    }
}

abstract class Staff {
    String name;
    String sex;

    public Staff(String name, String sex) {
        super();
        this.name = name;
        this.sex = sex;
    }

    abstract void accept(Visitor visitor);
}

class StaffA extends Staff {

    public StaffA(String name, String sex) {
        super(name, sex);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visitStaffA(this);
    }
}

class StaffB extends Staff {

    public StaffB(String name, String sex) {
        super(name, sex);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visitStaffB(this);
    }
}

interface Visitor {
    void visitStaffA(StaffA staffA);

    void visitStaffB(StaffB staffB);
}

class VisitorA implements Visitor {

    @Override
    public void visitStaffA(StaffA staffA) {
        System.out.println(staffA.name);
    }

    @Override
    public void visitStaffB(StaffB staffB) {
        System.out.println(staffB.name);
    }
}

class VisitorB implements Visitor {

    @Override
    public void visitStaffA(StaffA staffA) {
        System.out.println(staffA.sex);
    }

    @Override
    public void visitStaffB(StaffB staffB) {
        System.out.println(staffB.sex);
    }
}

class Report {
    List&amp;lt;Staff&amp;gt; list = new ArrayList&amp;lt;Staff&amp;gt;();

    public Report() {
        list.add(new StaffA(&amp;quot;AA&amp;quot;, &amp;quot;MALE&amp;quot;));
        list.add(new StaffA(&amp;quot;AB&amp;quot;, &amp;quot;FEMALE&amp;quot;));
        list.add(new StaffB(&amp;quot;BA&amp;quot;, &amp;quot;MALE&amp;quot;));
        list.add(new StaffB(&amp;quot;BB&amp;quot;, &amp;quot;FEMALE&amp;quot;));
    }

    public void showReport(Visitor visitor) {
        for (Staff staff : list) {
            staff.accept(visitor);
        }
    }
}
//output：
A
A
B
B
----------------
MALE
FEMALE
MALE
FEMALE&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>ActivityManagerService流程总结</title>
      <link>https://xuanliangdev.github.io/post/activitymanagerservice%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/activitymanagerservice%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;activitymanagerservice流程总结&#34;&gt;ActivityManagerService流程总结&lt;/h2&gt;
&lt;p&gt;ActivityManagerService是一个Binder服务，用来负责系统中四大组件的管理和调度。&lt;/p&gt;
&lt;h3 id=&#34;1activitymanagerservice启动流程分析&#34;&gt;1.ActivityManagerService启动流程分析&lt;/h3&gt;
&lt;p&gt;Android系统第一个启动的进程是Zygote进程，是通过脚本启动的，这个进程启动后马上会通过fork启动一个System Server进程，system server进程很重要，PackageManagerService和ActivityManagerService等一些重要服务都是运行在这个进程里。System Server进程启动后会开启一个ServerThread线程，这是一个开启了looper的线程，然后会在这个线程里调用ActivityManagerService的main函数进行启动。&lt;/p&gt;
&lt;p&gt;main函数执行的时序图如下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/d88c3b68bcb05192324ec63afcaeb194.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;1.创建一个AThread的线程&lt;/p&gt;
&lt;p&gt;2.启动Athread线程&lt;/p&gt;
&lt;p&gt;3.等待ActivityManagerService对象的创建&lt;/p&gt;
&lt;p&gt;4.Athread这时会去创建ActivityManagerService对象，即执行ActivityManagerService的构造方法&lt;/p&gt;
&lt;p&gt;5.ActivityManagerService对象创建完成唤醒ServerThread线程&lt;/p&gt;
&lt;p&gt;6.Athread等待&lt;/p&gt;
&lt;p&gt;7.执行ActivityThread.systemMain()函数，（我们知道ActivityThread是一个app进程的主线程，借用《深入理解Android卷2》中一句话，systemMain的目的是为system_server进程搭建一个和普通app进程一样的android运行环境）&lt;/p&gt;
&lt;p&gt;8.创建ActivityThread对象（在这里其实是system/framework/framework-res.apk的主线程）&lt;/p&gt;
&lt;p&gt;9.关联到系统进程&lt;/p&gt;
&lt;p&gt;10.取得系统ContextImpl对象（同样是system/framework/framework-res.apk的context）&lt;/p&gt;
&lt;p&gt;11.返回ContextImpl对象，然后创建一个ActivityStack对象。&lt;/p&gt;
&lt;p&gt;12.唤醒Athread线程，Athread线程进入looper循环&lt;/p&gt;
&lt;p&gt;13.继续执行startRunning函数（此处由于系统没准备好，直接返回）&lt;/p&gt;
&lt;h2 id=&#34;2startactivity流程分析&#34;&gt;2.startActivity流程分析&lt;/h2&gt;
&lt;p&gt;在控制台可以通过adb shell登录，并通过am命令打开一个activity
比如&lt;/p&gt;
&lt;p&gt;am start -n demo.leakcanary.srain.in.leakcanarydemo/.MainActivity&lt;/p&gt;
&lt;p&gt;activity从桌面启动的时序图如下图所示：&lt;/p&gt;
&lt;p&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-X8FsQtIO-1613019571484)(https://i.imgur.com/TUdt4OH.png)]&lt;/p&gt;
&lt;h3 id=&#34;1-911步在amsactivitymanagerservice进程中执行&#34;&gt;1-9、11步在AMS（ActivityManagerService）进程中执行；&lt;/h3&gt;
&lt;p&gt;1.使用am命令启动一个activity，实质是Am类通过ActivityManagerNative.getDefault()获得一个ActivityManagerProxy代理，ActivityManagerProxy代理会调用startActivityAndWait方法，而这其实又会调用AMS的startActivityAndWait方法。（因为AMS是ActivityManagerNative子类）&lt;/p&gt;
&lt;p&gt;2.调用ActivityStack的startActivityAndWait方法，ActivityStack是AMS的一个实例，是对activity进行调度的核心，比如管理activity的启动模式。&lt;/p&gt;
&lt;p&gt;3.这里会获取launchFlags来取出启动模式，检查权限等。&lt;/p&gt;
&lt;p&gt;4.创建activityRecod。&lt;/p&gt;
&lt;p&gt;5.这里也会对不同的启动模式进行处理，即为新建的activity_record找task。&lt;/p&gt;
&lt;p&gt;6.里面有一些动画相关的处理&lt;/p&gt;
&lt;p&gt;7.判断当前是否有resume的activity，有就进行pause操作（当前是home界面，所以先对launcher当前显示的activity进行pause操作）&lt;/p&gt;
&lt;p&gt;8.取出launcher进程的ApplicationThreadProxy代理。&lt;/p&gt;
&lt;p&gt;9.调用launcher进程代理的schedulePauseActivity方法进行pause activity的操作&lt;/p&gt;
&lt;p&gt;11、AMS执行完毕进入等待。&lt;/p&gt;
&lt;h3 id=&#34;1012-14在launcher所在进程中执行&#34;&gt;10、12-14在launcher所在进程中执行；&lt;/h3&gt;
&lt;p&gt;10.取出AMS发过来的参数。&lt;/p&gt;
&lt;p&gt;12.launcher通过H向自己的主线程发送pause activity的消息&lt;/p&gt;
&lt;p&gt;13.处理activity的pause操作。&lt;/p&gt;
&lt;p&gt;14.通过ActivityManagerProxy通知AMS当前activity已经完成暂停操作了。由此可见打开一个activity，首先得先把当前显示的activity先暂停。而不是先创建新的activity。&lt;/p&gt;
&lt;h3 id=&#34;15-22在ams进程中执行&#34;&gt;15-22在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;15.AMS调用ActivityStack的activityPaused方法。&lt;/p&gt;
&lt;p&gt;16.该过程会检查系统是否正在进入睡眠或关闭，否则再次调用resumeTopActivityLocked函数。&lt;/p&gt;
&lt;p&gt;17.resumeTopActivityLocked这个函数在第7步调用过，当时前面的activity没pause所以直接返回了，现在launcher显示的activity已经pause成功，则马上调用startSpecificActivityLocked方法、&lt;/p&gt;
&lt;p&gt;18.该函数首先会检查当前要启动的activity所在进程是否存在，如果不存在则新建进程，如果存在则直接执行realStartActivityLocked方法（这个方法后面32步也会调到）。&lt;/p&gt;
&lt;p&gt;19.取出ProcessRecord对象，如果进程不存在，则新建ProcessRecord对象，并加入到AMS的mProcessNames中。&lt;/p&gt;
&lt;p&gt;20.调用另一个startProcessLocked来创建新的进程对象&lt;/p&gt;
&lt;p&gt;21.调用Process.start方法开启一个新进程&lt;/p&gt;
&lt;p&gt;22.AMS执行完进入等待。&lt;/p&gt;
&lt;h3 id=&#34;23-26在新开的应用进程中执行&#34;&gt;23-26在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;23.Process.start开启进程后会进入新的app的主线程的main方法，也就是ActivityThread的main方法。ActivityThread类加载时会new一个ApplicationThread的binder对象，AMS便会和这个ApplicationThread进行进程间通信。&lt;/p&gt;
&lt;p&gt;24.创建一个ActivityThread对象。&lt;/p&gt;
&lt;p&gt;25.调用对象的attach方法&lt;/p&gt;
&lt;p&gt;26.通过AMS代理调用AMS的attachApplication方法&lt;/p&gt;
&lt;h3 id=&#34;27-28在ams进程中执行&#34;&gt;27-28在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;27.目的是将新的app的ApplicationThread和pid在AMS中注册。&lt;/p&gt;
&lt;p&gt;28.通过ApplicationThreadProxy将信息返回给新的app进程。&lt;/p&gt;
&lt;h3 id=&#34;29-31在新开的应用进程中执行&#34;&gt;29-31在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;29.新应用取出AMS发过来的数据向自己主线程的H发送消息。&lt;/p&gt;
&lt;p&gt;30.H处理消息。&lt;/p&gt;
&lt;p&gt;31.执行handleBindApplication进行相关信息的绑定。此处的操作包括创建上下文ContextImpl，创建应用的application，并调用application的oncreate方法。&lt;/p&gt;
&lt;h3 id=&#34;32-33在ams进程中执行&#34;&gt;32-33在AMS进程中执行；&lt;/h3&gt;
&lt;p&gt;32.AMS执行完bindApplication后便开始调用ActivityStack的realStartActivityLocked进行activity的显示，（该方法在之前18步的一个分支也可能会调用到）&lt;/p&gt;
&lt;p&gt;33.调用scheduleLaunchActivity方法，通过ApplicationThreadPoxy通知应用进行打开activity。&lt;/p&gt;
&lt;h3 id=&#34;34-44在新开的应用进程中执行&#34;&gt;34-44在新开的应用进程中执行；&lt;/h3&gt;
&lt;p&gt;34.像主线程的H发送打开activity的message。&lt;/p&gt;
&lt;p&gt;35.处理打开activity的操作。&lt;/p&gt;
&lt;p&gt;36.调用performLaunchActivity进行创建并打开activity的操作。&lt;/p&gt;
&lt;p&gt;37.该函数内会调用activity声明周期的oncreate和onstart方法。&lt;/p&gt;
&lt;p&gt;38.通过反射创建activity对象。&lt;/p&gt;
&lt;p&gt;39.newActivity创建完成返回activity变量。&lt;/p&gt;
&lt;p&gt;40.调用Instrumentation的callActivityOnCreate方法。&lt;/p&gt;
&lt;p&gt;41.调用activity的oncreate方法。&lt;/p&gt;
&lt;p&gt;42.执行完后会紧接着执行activity.performStart方法，即回调activity的onstart方法。&lt;/p&gt;
&lt;p&gt;43.执行handleResumeActivity方法，当44步调用完后，接着还会往主线程的MessageQueue发送一个Idler对象，会在这里面通知AMS对已经暂停的activity调用onStop和onDestroy的生命周期&lt;/p&gt;
&lt;p&gt;44.该过程会调用activity的onresume方法。&lt;/p&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;Android AOSP代码&lt;/p&gt;
&lt;p&gt;《深入理解Android 卷2 邓凡平》&lt;/p&gt;
&lt;p&gt;《Android系统源代码情景分析 罗升阳》&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android内存性能分析</title>
      <link>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;h1 id=&#34;android内存性能分析&#34;&gt;Android内存性能分析&lt;/h1&gt;
&lt;p&gt;工具：Android Studio、MAT(Memory Analyzer Tool)&lt;/p&gt;
&lt;p&gt;第三方库：LeakCanary&lt;/p&gt;
&lt;h2 id=&#34;1android-profiler基础用法&#34;&gt;1、Android Profiler基础用法&lt;/h2&gt;
&lt;p&gt;首先附上Android Profilder的官方使用说明地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.google.cn/studio/profile/memory-profiler.html&#34;&gt;https://developer.android.google.cn/studio/profile/memory-profiler.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android Profiler可以实时查看app的cpu、memory和network状态，这里只说memory，简单写个用GridView加载大量网络图片的例子，对于加载到的bitmap对象分别采用HashMap和LruCache进行保存，观察内存变化。&lt;/p&gt;
&lt;p&gt;当使用HashMap时，观察Android Profiler中memory的变化
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/d2c75694fc47cc7d42d8d17f07808d93.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出内存不停增加，最终程序oom；&lt;/p&gt;
&lt;p&gt;接着用LruCache替换HashMap，LruCahe的配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // 获取应用程序最大可用内存
    int maxMemory = (int) Runtime.getRuntime().maxMemory();
    int cacheSize = maxMemory / 8;
    // 设置图片缓存大小为程序最大可用内存的1/8
    mMemoryCache = new android.util.LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getByteCount();
        }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/f9d15f24a08c15d50886f9356d4feb6c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，当内存达到一定的值时得到了回收。&lt;/p&gt;
&lt;p&gt;*AndroidManifest.xml文件&lt;!-- raw HTML omitted --&gt;中可以设置 android:largeHeap=&amp;quot;true&amp;quot;来增加app的可使用内存，实验发现默认情况下nexus5手机android6.0系统当内存达到300多M时产生oom，如果设置该选项内存达到500多M时才会oom，但是设置该值会导致gc时间变长从而一定程度上影响性能，所以要斟酌使用。&lt;/p&gt;
&lt;p&gt;*ActivityManager获取的内存值定义在系统rom中，编译时已经写入系统，而Runtime类可以获得运行时的内存数据，也是Android profiler显示的动态图数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHead am.getMemoryClass()为192
02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHead am.getLargeMemoryClass()为512
02-02 20:39:17.158 14633-14633/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHeadRuntime.getRuntime().maxMemory()为：536870912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;android:largeHeap=&amp;quot;false&amp;quot;时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;02-02 20:44:46.550 17492-17492/com.blogxuan.oomdemo2 I/OOMDEMO: 机型：AOSP on HammerHeadRuntime.getRuntime().maxMemory()为：201326592
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2使用android-profiler进行内存泄露分析&#34;&gt;2、使用Android Profiler进行内存泄露分析。&lt;/h3&gt;
&lt;p&gt;一个简单的内存泄露例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestActivity extends Activity {
    TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        textView = (TextView) findViewById(R.id.test_text_view);
        TestDataModel.getInstance().setRetainedTextView(textView);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TestDataModel的class文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestDataModel {

    private static TestDataModel sInstance;
    private TextView mRetainedTextView;

    public static TestDataModel getInstance() {
        if (sInstance == null) {
            sInstance = new TestDataModel();
        }
        return sInstance;
    }

    public void setRetainedTextView(TextView textView) {
        mRetainedTextView = textView;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在例子中，当TestActivity finish后，由于静态变量sInstance引用了textView，而textView引用了TestActivity的context，最终导致TestActivity对象不能被回收产生了内存泄露。&lt;/p&gt;
&lt;p&gt;找出本应该回收但是并没有回收的对象（也就是发生了泄露的对象）：&lt;/p&gt;
&lt;p&gt;通过分析操作前和操作后的堆中的对象分配，首先找出堆计数异常大或者本该回收但是却没得到回收的对象，然后查看具体是哪些对象引用了他们导致他们没能回收。&lt;/p&gt;
&lt;p&gt;也可以从Android Studio中将堆转储保存为hprof文件来用其他工具（比如MAT）进行分析，比如上面的例子，TestActivity打开前保存一二hprof文件，然后打开后再finish，然后再在android studio中手动gc一下，再导出hprof文件。接着在MAT中对比这两个堆文件。结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/b6e1969b987f1b0b6ff134ce61001852.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见TestDataModel对象和TestActivity对象并没有被回收，这是因为静态的sInstance生命周期跟application一样，而sInstance引用了textView，textView引用了TestActivity的context，因此TestActivity也没有被回收。&lt;/p&gt;
&lt;h3 id=&#34;3使用leakcanary进行内存泄露分析&#34;&gt;3、使用LeakCanary进行内存泄露分析。&lt;/h3&gt;
&lt;p&gt;LeakCanary是square公司开源的一个检测内存泄露的工具库，使用很简单，只要在gradle中依赖一下，然后在application中注册一下就行了。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&#34;https://github.com/square/leakcanary&#34;&gt;https://github.com/square/leakcanary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用LeakCanary检测内存泄露实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestActivity2 extends Activity {
    TextView textView;
    Message msg;
    Handler mLeakyHandler= new Handler(){
        @Override
        public void handleMessage(Message msg) {
        }
    };
    Message msg;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        msg = Message.obtain();
        mLeakyHandler.sendMessageDelayed(msg, 40000);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中TestActivity打开后马上关闭，会产生内存泄露，LeakCanary会有如下内存泄露提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/03bf5ed49636637f47071953e5b7e741.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是因为handler发送一个消息给MessageQueue后，存在一条这样的引用链，主线程→mainLooper→MessageQueue→Message→handler→TestActivity，当activity destroy后，message还存在消息队列里，因此activity对象得不得回收。&lt;/p&gt;
&lt;p&gt;要使activity能得到回收，只要在activity关闭后在这个引用链的任意一处切断都行，有如下三种方法：&lt;/p&gt;
&lt;p&gt;1.切断Message和messageQueue的联系，即在activity的onDestroy中调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mLeakyHandler.removeCallbacksAndMessages(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法可以移除消息队列中的消息从而切断Message和MessageQueue的联系，使activity得到回收。&lt;/p&gt;
&lt;p&gt;2.切断Message和handler的联系，可以通过在activity的onDestroy中调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; msg.setTarget(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来实现，即把handler置空。&lt;/p&gt;
&lt;p&gt;3.由于非静态内部类或匿名类会持有外部类的引用，即handler持有activity的引用，因此可以通过把handler声明为静态内部类来切断handler对activity实例的引用，但是静态内部类的对象是不能调用外部类的实例变量的，因此可以通过传递一个外部activity实例的WeakReference给handler使用，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static class MyHandler extends Handler
    {
        private WeakReference&amp;lt;Context&amp;gt; reference;

        public MyHandler(Context activity)
        {
            reference = new WeakReference&amp;lt;Context&amp;gt;(activity);
        }

        @Override
        public void handleMessage(Message msg)
        {
            TestActivity2 mTestActivity = (TestActivity2) reference.get();
            if (reference.get() != null)
            {
                mTestActivity.textView.setText(&amp;quot;hello&amp;quot;);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;handler泄露的危害：有的人会说通常情况不会使用handler发送延迟太久的消息，而且消息达到延迟的时间后，activity不就可以自动被回收了么，因此handler泄露也没什么打不了啊，但是考虑这样一个情景，通常我们都会在onDestory里处理一些资源回收的操作，如果handler的handleMessage里面使用到了某些资源，而这些资源被回收了，那就会出问题了，最常见的就是产生空指针导致程序崩溃。&lt;/p&gt;
&lt;h3 id=&#34;3leakcanary原理简单介绍&#34;&gt;3、LeakCanary原理简单介绍。&lt;/h3&gt;
&lt;p&gt;leakCanary内存泄露检测完整时序图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/796a8176b9a07f8a39500a118cb8e8b6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码中我们只要简单使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LeakCanary.install(this);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就能完成LeakCanary的初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
        .buildAndInstall();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要看下buildAndInstall这个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      LeakCanary.enableDisplayLeakActivity(context);
      ActivityRefWatcher.install((Application) context, refWatcher);
    }
    return refWatcher;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面调用了ActivityRefWatcher.install方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void install(Application application, RefWatcher refWatcher) {
    new ActivityRefWatcher(application, refWatcher).watchActivities();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面调用了watchActivities这个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void watchActivities() {
    // Make sure you don&#39;t get installed twice.
    stopWatchingActivities();
    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lifecycleCallbacks定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
  new Application.ActivityLifecycleCallbacks() {
    @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    }

    @Override public void onActivityStarted(Activity activity) {
    }

    @Override public void onActivityResumed(Activity activity) {
    }

    @Override public void onActivityPaused(Activity activity) {
    }

    @Override public void onActivityStopped(Activity activity) {
    }

    @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }

    @Override public void onActivityDestroyed(Activity activity) {
      ActivityRefWatcher.this.onActivityDestroyed(activity);
    }
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是application提供的一个方法，可以用来监听我们应用中所有activity的生命周期，LeakCanay就是在这里通过监控所有activity的onDestroyed方法来检测内存泄露的。&lt;/p&gt;
&lt;p&gt;继续进入ActivityRefWatcher.this.onActivityDestroyed方法，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void onActivityDestroyed(Activity activity) {
    refWatcher.watch(activity);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LeakCanay内存泄露检测的核心就是这个watch方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
      return;
    }
    checkNotNull(watchedReference, &amp;quot;watchedReference&amp;quot;);
    checkNotNull(referenceName, &amp;quot;referenceName&amp;quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
        new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;retainedKeys是一个Set&lt;!-- raw HTML omitted --&gt;类型的集合，用来记录被监控的所有还在内存的对象（这里是刚调用了onDestoryed方法的activity对象），KeyedWeakReference继承自WeakReference，作用是用一个弱引用来引用被监控的对象（activity），queue是一个ReferenceQueue队列，作用后面说，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    long gcStartNanoTime = System.nanoTime();
    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);

    removeWeaklyReachableReferences();

    if (debuggerControl.isDebuggerAttached()) {
      // The debugger can create false leaks.
      return RETRY;
    }
    if (gone(reference)) {
      return DONE;
    }
    gcTrigger.runGc();

    removeWeaklyReachableReferences();
    if (!gone(reference)) {
      long startDumpHeap = System.nanoTime();
      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);

      File heapDumpFile = heapDumper.dumpHeap();
      if (heapDumpFile == RETRY_LATER) {
        // Could not dump the heap.
        return RETRY;
      }
      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
      heapdumpListener.analyze(
          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
              gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ensureGone是LeakCanay内存泄露检测主要逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
      retainedKeys.remove(ref.key);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先从removeWeaklyReachableReferences这个方法说起，从上面的注释我们可以看出ReferenceQueue的作用（如果一个对象变成弱引用，那么这个对象入队），也就是如果我们的activity被finish了，正常情况下这个activity是应该进入这个队列了，因此当我们通过queue.poll()把这个activity对象取出来，retainedKeys中就移除这个activity，表示这个activity被回收了，而gone(reference)这个方法就是来判断retainedKeys中是否还存在这个对象，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  private boolean gone(KeyedWeakReference reference) {
    return !retainedKeys.contains(reference.key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;removeWeaklyReachableReferences和gone方法都执行了两次，如果第一次对象就从retainedKeys移除了，那就是表示对象已经成功被回收了，如果没有，则调用gcTrigger.runGc()执行一次gc操作，再进一步确认对象是否还存在，如果还存在则猜测发生了内存泄露，因此取出dump文件进一步分析，对dump文件的分析使用了squareup的另一个haha库，如果确实出现了泄露，则找出泄露对象的引用路径通知用户。如有需要我们也可以导出LeakCanay生成的dump文件使用其他工具比如MAT，Android Studio进行分析。&lt;/p&gt;
&lt;p&gt;*看LeakCanary源码时发现使用到了一个&lt;a href=&#34;https://github.com/tbroyer/gradle-errorprone-plugin&#34;&gt;net.ltgt.gradle:gradle-errorprone-plugin&lt;/a&gt;的库，通过这个库，如果我们的handler有内存泄露的隐患，直接在运行app时就会报错，因此我们可以在项目中引用这个库来提前发现一些问题，从而避免一些安全隐患。&lt;/p&gt;
&lt;h3 id=&#34;推荐书籍&#34;&gt;推荐书籍&lt;/h3&gt;
&lt;p&gt;《Android群英传：神兵利器》&lt;/p&gt;
&lt;p&gt;《高性能Android应用开发》&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>APK的安装过程分析</title>
      <link>https://xuanliangdev.github.io/post/apk%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/apk%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;h2 id=&#34;apk的安装过程分析packagemanagerservice启动过程&#34;&gt;APK的安装过程分析（PackageManagerService启动过程）&lt;/h2&gt;
&lt;p&gt;时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/988c7fc940d83d6bdaa9d306e709bf70.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;步骤说明&#34;&gt;步骤说明&lt;/h2&gt;
&lt;p&gt;1.pkms的main函数入口&lt;/p&gt;
&lt;p&gt;2.加入android.uid.system，android.uid.phone等一些系统的shareUserId，保存到SharedUserSetting数据结构&lt;/p&gt;
&lt;p&gt;3.保存shareUserId到Uid的数据结构中&lt;/p&gt;
&lt;p&gt;4.从system/etc/permissions目录的xml读取权限，这些xml文件是编译完成后烧写进手机的。&lt;/p&gt;
&lt;p&gt;5.将xml的内容保存到特定的数据结构。&lt;/p&gt;
&lt;p&gt;6.解析data/system/目录下packages.xml，packages-backup.xml，packages.list，packages-stopped.xml，packages-stopped-backup.xml的信息&lt;/p&gt;
&lt;p&gt;7.读取packages.xml文件中package标签信息&lt;/p&gt;
&lt;p&gt;8.保存xml信息到PackageSetting的数据结构&lt;/p&gt;
&lt;p&gt;9.保存pakage到应用对应的uid数据结构，和3步骤相似&lt;/p&gt;
&lt;p&gt;10.读取packages.xml文件中shared-user标签信息&lt;/p&gt;
&lt;p&gt;11.保存xml信息到SharedUserSetting的数据结构&lt;/p&gt;
&lt;p&gt;12.保存shareUserId到应用对应的uid数据结构，和3，9步骤相似&lt;/p&gt;
&lt;p&gt;13.开始扫描package，此函数会调用多次，从而扫描不同目录下的apk文件，比如系统的apk默认路径有system/framework,system/app,system/vendor/app这三个，非系统apk安装路径为data/app,data/app-private&lt;/p&gt;
&lt;p&gt;14.对每个apk文件执行scanPackageLI操作&lt;/p&gt;
&lt;p&gt;15.PackageParser解析apk（即解析AndroidManifest.xml文件中的各个标签，主要通过AssetManager来取出apk中的AndroidManifest.xml文件）并返回Package对象&lt;/p&gt;
&lt;p&gt;16.生成Package对象&lt;/p&gt;
&lt;p&gt;17.返回Package对象并传入第二个scanPackageLI函数的参数中&lt;/p&gt;
&lt;p&gt;18.开始第二个scanPackageLI函数，这个函数做的事情比较多，比如将apk里的lib文件夹的动态库so文件解压出来&lt;/p&gt;
&lt;p&gt;19.获取一个pkg的setting信息&lt;/p&gt;
&lt;p&gt;20.获取一个pkg的setting信息&lt;/p&gt;
&lt;p&gt;21.为解析得到的pkg分配linux 的uid&lt;/p&gt;
&lt;p&gt;22.获取pkg的setting信息结束（后面还会把这个信息保存到mSettings变量里）&lt;/p&gt;
&lt;p&gt;23.这一步之前还会循环遍历所有四大组件的信息并保存到成员变量中，&lt;/p&gt;
&lt;p&gt;24.汇总并更新权限相关信息&lt;/p&gt;
&lt;p&gt;25.授予权限&lt;/p&gt;
&lt;p&gt;26.将应用的安装信息保存到data/system/目录下的package.xml,package.list等本地文件之中&lt;/p&gt;
&lt;p&gt;27.结束pkms的构造函数&lt;/p&gt;
&lt;p&gt;后续计划，permission，assetmanager和resource相关的学习。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>mac编译源码</title>
      <link>https://xuanliangdev.github.io/post/mac%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/mac%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/</guid>
      
        <description>&lt;h2 id=&#34;mac-编译-android-framework-60源码&#34;&gt;Mac 编译 android framework 6.0源码&lt;/h2&gt;
&lt;p&gt;工作到现在为止刚好一年半，一直做着公司Android产品的半开发半维护的工作，内心一直向往一份关于android framework开发方面的工作，前面几个月研读了一些设计模式和Sandroid framework源码的书，接下来的目标就是搭建调试framework的环境，听说mac不错，于是买了个mba 128g的笔记本，现在有点后悔，如果时间能重新选择，一定买mbp，本来打算编译2.3点源码的，但是看了官方的android版本于编译系统的对应关系，还是决定按要求来吧，选择了android6.0.1版本，而且自己有个nexus5，正好可以刷。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Android版本&lt;/th&gt;
&lt;th&gt;Mac OS (Intel/x86)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Android 6.0 (Marshmallow) - Android最新版本&lt;/td&gt;
&lt;td&gt;Mac OS v10.10 (Yosemite) or later with Xcode 4.5.2 and Command Line Tools&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 5.x (Lollipop)&lt;/td&gt;
&lt;td&gt;Mac OS v10.8 (Mountain Lion) with Xcode 4.5.2 and Command Line Tools&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 4.1.x-4.3.x (Jelly Bean) - Android 4.4.x (KitKat)&lt;/td&gt;
&lt;td&gt;Mac OS v10.6 (Snow Leopard) or Mac OS X v10.7 (Lion) and Xcode 4.2 (Apple’s Developer Tools)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android 1.5 (Cupcake) - Android 4.0.x (Ice Cream Sandwich)&lt;/td&gt;
&lt;td&gt;Mac OS v10.5 (Leopard) or Mac OS X v10.6 (Snow Leopard) and the Mac OS X v10.5 SDK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;##1、本文相关配置&lt;/p&gt;
&lt;p&gt;硬件：&lt;/p&gt;
&lt;p&gt;1、MacBook Air i5双核处理器 硬盘128g 内存8g&lt;/p&gt;
&lt;p&gt;2、一块2T的移动硬盘&lt;/p&gt;
&lt;p&gt;3、nexus5&lt;/p&gt;
&lt;p&gt;软件：&lt;/p&gt;
&lt;p&gt;1、各个版本的jdk，jdk6、jdk7、jdk8，（本文选择android版本为6.0.1因此默认用jdk7）&lt;a href=&#34;https://pan.baidu.com/s/1bp8ouMr&#34;&gt;网盘地址&lt;/a&gt;  密码:tz95&lt;/p&gt;
&lt;p&gt;2、repo &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、清华镜像站的初始化包 &lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/help/AOSP/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、选择编译的android版本为android-6.0.1_r60（r60分支只支持刷入nexus5）&lt;/p&gt;
&lt;p&gt;5、xcode8（最新版为xcode9，但是编译过程提示xcode和aosp中externl库函数冲突，google发现别人也有这个问题，换xcode8后解决了）&lt;/p&gt;
&lt;p&gt;6、MacOSX10.11.sdk（xcode8默认的MacOSX10.12.sdk编译时会提示有些函数废弃了编译不了，因此需要下载10.11.sdk，并拷贝到10.12.sdk同一目录下）&lt;a href=&#34;https://pan.baidu.com/s/1jHE5wdo&#34;&gt;网盘地址&lt;/a&gt;密码:kv23&lt;/p&gt;
&lt;p&gt;7、MacPorts（用于方便安装make、git、gpg等相关工具）&lt;a href=&#34;https://www.macports.org/install.php&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、nexus5 r60分支版本的驱动&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/android/drivers#hammerheadlrx22c&#34;&gt;google官网驱动下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nexus5 r60分支版本MOB30Y的驱动&lt;a href=&#34;https://pan.baidu.com/s/1gf2GzBX&#34;&gt;网盘地址&lt;/a&gt;密码:2a33，不同版本对应不同驱动，这个要注意&lt;/p&gt;
&lt;p&gt;##2、下载源码&lt;/p&gt;
&lt;p&gt;国内有长城，google下不来，可以从&lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/help/AOSP/&#34;&gt;清华大学开源软件镜像站&lt;/a&gt;下,看介绍源码会有30g以上，但是自己的笔记本却只有128g，而且现在就剩40g了，查资料发现可以在移动硬盘弄，于是乎买了个2t的移动硬盘。&lt;/p&gt;
&lt;p&gt;##3、下载repo工具
1.这个命令会下载一个repo的文件到当前命令的目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*&lt;em&gt;第一个知识点：repo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2.在home目录下创建bin目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir ~/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.把上面下载的repo拷贝到~/bin目录下&lt;/p&gt;
&lt;p&gt;4.赋予权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod a+x ~/bin/repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.用文本编辑的方式打开repo，并且修改为REPO_URL为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##4、安装MacPorts&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.macports.org/install.php&#34;&gt;MacPorts下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接着使用下面等MacPorts命令安装make、git等工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo port install gmake libsdl git-core gnupg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##5、创建一个区分大小写的镜像文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdiutil create -type SPARSE -fs &#39;Case-sensitive Journaled HFS+&#39; -size 100g ~/android.dmg.sparsefile.sparseimage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个镜像主要是用来存放源代码的，由于我用的是移动硬盘来编译源码，因此把这个镜像文件移动到移动硬盘里，因为自己笔记本容量小，因此把镜像文件拷到移动硬盘后再进行使用镜像，这步很重要，这个100g是镜像的上限，新创建时并没有100g，只有200多m，而且可以动态改变大小，只要用下面的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdiutil resize -size 150g ~/android.dmg.sparsefile.sparseimage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我编译了模拟器以及真机的镜像，最后镜像大小为127g，当然如果编译时空间不够，可以把.repo删除了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4a21dc980710ba590aa2ee80226169fc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在~/根目录下看看有没有.bash_profile文件，没有就创建一个，这个文件主要是用来进行一些环境变量的配置，下面是我自己的.bash_profile文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 用来挂载镜像的函数
function mountAndroid { hdiutil attach /Volumes/mhdd/android.dmg.sparsefile.sparseimage -mountpoint /Volumes/android; }

# 推出镜像，跟在桌面推出效果一样
function umountAndroid() { hdiutil detach /Volumes/android; }

# 安装MacPorts的变量配置
PATH=/opt/local/bin:$PATH
PATH=/opt/local/sbin:$PATH

#解除1024限制 
ulimit -S -n 1024

# -------------java的环境变量start---------------------
# Mac默认 JDK 6  
export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`  
# 设置 JDK 7  
export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`  
# 设置 JDK 8  
export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`  
  
#默认JDK 7  
export JAVA_HOME=$JAVA_7_HOME  
  
#alias命令动态切换JDK版本，直接在命令行输入jdk6或其他版本就可切换了  
alias jdk6=&amp;quot;export JAVA_HOME=$JAVA_6_HOME&amp;quot;  
alias jdk7=&amp;quot;export JAVA_HOME=$JAVA_7_HOME&amp;quot;  
alias jdk8=&amp;quot;export JAVA_HOME=$JAVA_8_HOME&amp;quot;  
# -------------java的环境变量end---------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​
#&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-repo环境变量&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
export PATH=$PATH:$HOME/bin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-----------------android sdk环境变量--------------
#主要是执行adb命令，fastboot命令等用到，这是我本地的路径，根据需要自己修改
ANDROID_HOME=/Users/xuanliang/coding/android/android-sdk-macosx
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/platform-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*&lt;em&gt;第二个知识点：bash_profile文件是什么&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用命令行mountAndroid挂载好镜像文件后，就可以像硬盘一样使用镜像文件了，在镜像中建立aosp文件夹，接着从清华镜像站下载好40多g的原始包，把它解压到镜像文件aosp文件夹里，是一个.repo的文件。（一开始自己是先从笔记本硬盘把压缩文件拷到镜像里再解压，发现很慢，想起来是因为镜像在移动硬盘上的原因，于是采用直接从笔记本用命令把文件解压到镜像文件里，就快多了），命令行进入到aosp目录，执行初始化repo到命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;r60代表是nexus5的MOB30Y版本，_r60这个参数很重要，因为对应着机型版本以及驱动版本，版本不对烧写真机时容易出问题，可以根据需要取其他分支。然后执行下面的命令进行同步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repo sync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步完成后aosp目录会生成6.0.1_r60分支的所有代码，可以通过.repo目录里的manifest文件看看所下分支是否正确。（执行repo sync命令时遇到了一个坑，查了半天发现是当时解压用的软件解压的，解压的不完全，解压出的文件有问题，后来把文件都删除了，重新用命令行解压后再进行repo sync同步就好了，得了个教训以后对于大文件解压还是得用命令行）&lt;/p&gt;
&lt;p&gt;然后就是进行编译了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source build/envsetup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/75eb0732507c275146ef26586596aee2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lunch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/a5bbf7db3588501c7c41def2a1066810.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -j4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译成功会在products里生成hammerhead文件夹，烧写入真机时要进入这个文件夹执行fastboot等命令，如果上面lunch选择1则会generic文件夹，里面是模拟器用到的镜像相关文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/2a31ce2839c36b89d13b72e28ce2f152.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为要烧写入真机，因此先执行驱动的三个脚本文件生成相关文件，如果只需要模拟器则跳过这步
首先把驱动脚本拷进aosp目录，然后依次执行三个驱动脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/5389f217a75bc639473a83064016c58b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./extract-broadcom-hammerhead.sh
./extract-lge-hammerhead.sh
./extract-qcom-hammerhead.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行过程中会有一些条款，阅读完后会提示输入“同意”指令，输入完会在相关目录生成驱动文件。&lt;/p&gt;
&lt;p&gt;最后手机连上电脑，执行adb命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会让手机重启并进入刷机模式，如果adb命令找不到，先看看是否环境变量配置正确，adb工具以及fastboot工具在android的sdk里，参考步骤5里的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/0b47a76ac0ac6ea90070a673e1a5bbcc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cd 到源码编译输出的目录执行fastboot命令
fastboot -w flashall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后刷机成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/e3feef918e21dc2712f7f90e90039ccc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接着是生成android studio能导入的文件，使用如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make idegen &amp;amp;&amp;amp; development/tools/idegen/idegen.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在源码目录生成两个文件，如下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/cabff872caa4a2dc77ef324206f328c3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以对android.imp进行编辑去掉一些模块，这样android studio导入就会快点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/.repo&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/abi&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/art&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/bionic&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/bootable&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/build&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/cts&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/dalvik&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/developers&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/development&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/device&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/bluetooth&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/chromium&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/emma&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/icu4c&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/jdiff&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/external/webkit&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/frameworks/base/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/hardware&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/libcore&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/libnativehelper&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/ndk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/eclipse&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/host&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/common/docs&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/out/target/product&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/packages&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/pdk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/prebuilt&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/prebuilts&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/sdk&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/system&amp;quot; /&amp;gt;
  &amp;lt;excludeFolder url=&amp;quot;file://$MODULE_DIR$/tools&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着还要在android stuidio中进行一些源码关联sdk的配置，&lt;/p&gt;
&lt;p&gt;然后就可以通过真机调试framework源代码了。手机连上电脑，关联debugger可以看到手机上的所有进程。选择system_process绑定，
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/e37498538bed10253f625e2e1bbfd221.png&#34; alt=&#34;&#34;&gt;
然后在activitymanagerservice中找个位置打上断点，随便打开一个app，发现可以跳进断点了。
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/43542de5f3bce0390cf4f9c178e56bd6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;编译过程完成，后面就是进一步对android framework的学习了，漫漫长路踏出第一步。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Binder机制学习</title>
      <link>https://xuanliangdev.github.io/post/binder%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 05 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/binder%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;binder机制学习&#34;&gt;Binder机制学习&lt;/h1&gt;
&lt;p&gt;Binder是用在Android系统中的一个进程间通信(IPC)机制，使用C/S架构，服务端和客户端通过Binder进行跨进程的数据交换，Binder继承自IBinder接口，因此IBinder接口最重要的一个方法是transact，所以虽然Android为了减少开发者开发工作量，采用了代理模式封装了一个复杂的Binder架构，但是其本质都是从源进程传递数据给目标进程，然后目标进程处理完后再把数据回传给源进程，所以在学习Binder实现原理时最好是要不时回想起框架实现的目的，才能不被架构里的各种类似的概念搞迷糊。&lt;/p&gt;
&lt;p&gt;关于Service，其实就是提供服务的代码，在java端是通过AIDL来定义进程间通信的接口，Service端实现接口并通过onBind方法向客户端公开该接口，客户端取得该接口后就可以调用接口的相关方法。调用方法也很简单，具体可以参考&lt;a href=&#34;https://developer.android.google.cn/guide/components/aidl.html#Defining&#34;&gt;官方API指南AIDL章节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4ead3d64921078d6d86346f1e0c22954.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;复杂的架构都是为了更方便别人进行调用，我们可以在java端或native端进行binder的使用，作为java开发者我们要使用Binder只要实现图上绿色部分的接口和类就够了（绿色部分的aidl类为android sdk自带的apidemo中的一个示例），而作为native端的开发者需要实现如蓝色部分的接口和类。&lt;/p&gt;
&lt;p&gt;关于Binder的源码分析的书籍有《Android系统源代码情景分析[罗升阳著]》《深入理解Android卷I[邓平凡著]》《Android技术内幕系统卷[杨丰盛著]》，写的都比较好，最好是边看源码边看书，看的时候多想想为什么这么设计，为了防止自己忘记，画了几幅时序图辅助理解。如下四幅图为Binder通信的四个主要过程：&lt;/p&gt;
&lt;p&gt;ServiceManagerProxy获取过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/0609d7a4f068d8ba811e5317df1c5a55.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;向ServiceManager注册Service过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/183c79904de0ae85ae16c07713e7d779.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;Service代理对象获取过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/621b0903549b48c66db5bdd89945411e.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;跨进程调用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/62fc2c1f41d27954757fa74d9cc688a7.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Android 消息处理机制学习</title>
      <link>https://xuanliangdev.github.io/post/android-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xuanliangdev.github.io/post/android-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;android-消息处理机制学习&#34;&gt;Android 消息处理机制学习&lt;/h1&gt;
&lt;p&gt;之前也看过不少的书或博客介绍Android 消息处理机制的知识点，但总是刚看完感觉懂了，过几天就忘，今天一边看源码，一边画了类图和时序图，希望可以加深自己的理解。&lt;/p&gt;
&lt;p&gt;Android应用启动时会创建一个主线程，与Android UI工具包交互，因此也叫UI线程，因此不能被一些耗时长的操作阻塞，阻塞时通常的表现是UI控件的事件不能得到响应，比如按钮按下去了弹不回来，长时间还会造成ANR，Android提供的消息处理机制就是来解决这个问题的，其中涉及的主要的类是Handler、Looper和MessageQueue。其类图如下，简单起见只列出了一些主要的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/a0e13532e9fa67407a2608cd0a801fb5.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中MessageQueue为消息队列，Looper负责创建并管理消息队列，使其进入一个循环，Handler负责发送消息以及处理消息。发送消息一般在耗时操作执行完后在工作线程进行，处理消息一般在主线程进行。以下为Android消息处理机制的时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/405232c48662550cefabd2c7b84b55f3.png&#34; alt=&#34;img&#34;&gt;&lt;img src=&#34;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#34; alt=&#34;点击并拖拽以移动&#34;&gt;&lt;/p&gt;
&lt;p&gt;时序图中1-4步是消息队列的创建过程。&lt;/p&gt;
&lt;p&gt;5-11步为线程进入一个循环，并监听是否有消息要处理，如果没有消息，线程就会进入睡眠等待状态。&lt;/p&gt;
&lt;p&gt;12-16步为消息发送过程。&lt;/p&gt;
&lt;p&gt;17-19步为消息的处理过程。&lt;/p&gt;
&lt;p&gt;以上就是android异步消息处理的整个过程。下面结合具体应用进一步分析。&lt;/p&gt;
&lt;p&gt;下面是一段最简单的应用代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package blogxuan.bloghandler;
import android.app.Activity;
import android.app.ProgressDialog;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;

public class MainActivity extends Activity
{
	ProgressDialog progressDialog;
	Handler handler = new Handler()
	{
		@Override
		public void handleMessage(Message msg) {
			if (msg.what == 0) {
				progressDialog.cancel();
			}
		}
	};

	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Button startBtn = (Button) findViewById(R.id.button);
		progressDialog = new ProgressDialog(MainActivity.this);
		startBtn.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				progressDialog.show();
				new Thread(new Runnable() {
					@Override
					public void run() {
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        handler.sendEmptyMessage(0);
					}
				}).start();
			}
		});
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点击按钮后主界面会显示一个进度对话框，然后会新建一个线程，Thread的sleep方法模拟一个耗时操作，执行完后handler发送消息，然后在主线程中handler的handleMessage方法收到消息后关闭进度对话框。代码中可以看出只有流程图中的消息发送过程以及消息处理过程，并没看到1-11步消息队列的创建过程以及循环过程。这是因为UI线程默认会给我们进行这两个过程。在Acitvity的源码中可以找到一个叫mMainThread的ActivityThread类变量，而Looper和MessageQueue的创建就是在ActivityThread这个类的main方法中进行的，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Process.setArgV0(&amp;quot;&amp;lt;pre-initialized&amp;gt;&amp;quot;);

    Looper.prepareMainLooper();
    if (sMainThreadHandler == null) {
        sMainThreadHandler = new Handler();
    }

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &amp;quot;ActivityThread&amp;quot;));
    }

    Looper.loop();

    throw new RuntimeException(&amp;quot;Main thread loop unexpectedly exited&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然没有时序图中的Looper.prepare()方法，但其实Looper.prepareMainLooper()这个方法也会间接调用prepare()方法。一旦调用prepare()方法，便会完成Looper对象以及MessageQueue对象的创建，同时完成C++层的NativeMessageQueue和Looper的绑定，不在深入。&lt;/p&gt;
&lt;p&gt;调用Looper.prepare()只是创建消息队列的过程，调用Looper.loop()方法才能使消息队列进入一个循环过程并对消息进行监听。&lt;/p&gt;
&lt;p&gt;UI线程创建的时候自动建立了消息队列并进入循环过程，这样我们就可以在完成工作线程的耗时操作后往UI线程的消息队列发消息提示更新UI组件。&lt;/p&gt;
&lt;p&gt;但是如果我们希望一个相反的过程，也就是工作线程需要等待UI线程完成一些操作后再做一些操作，那么我们必须自己在工作线程中实现Looper和MessageQueue的创建以及循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LooperThread extends Thread {
    public Handler mHandler;

    public void run() {
        Looper.prepare();

        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // process incoming messages here
            }
        };

        Looper.loop();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是Looper源代码中的参考用例。这种用法自己暂时只用到过一次，当时项目中有个需求是实现异步数据库事务。当时开了一个子线程来调用了数据库的beginTransaction()方法，当又开了另一个线程进行数据库操作的时候发现报数据库被锁了，后来查资料发现一个完整的数据库事务必须放在一个线程执行才行，但是根据项目的需求执行数据库的操作是在UI线程发起的，因此就只能在开启事务的子线程中实现Looper和MessageQueue（线程默认是没有Looper和MessageQueue的），这样就实现了子线程也能进行消息循环监听，当UI线程需要执行数据库操作时再向子线程发送消息通知在子线程中继续进行数据库操作，就能保证数据库的操作跟开启事务是同一个子线程。&lt;/p&gt;
&lt;p&gt;Looper对象的创建还有一个概念是ThreadLocal，Looper.prepare()方法完成了Looper对象的创建，其源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void prepare() {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&amp;quot;Only one Looper may be created per thread&amp;quot;);
    }
    sThreadLocal.set(new Looper());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码中看到Looper对象创建并不像我们通常的方式new一个静态全局变量，或者是通过单例模式的方式创建，而是通过ThreadLocal对象来把这个Looper对象包含起来，ThreadLocal的源码的注释说明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implements a thread-local storage, that is, a variable for which each thread
 * has its own value. All threads share the same {@code ThreadLocal} object,
 * but each sees a different value when accessing it, and changes made by one
 * thread do not affect the other threads. The implementation supports
 * {@code null} values.
 *
 * @see java.lang.Thread
 * @author Bob Lee
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单来讲就是可以实现同一个ThreadLocal对象，在不同的线程中有不同的值，并且不同线程之间的值互不干扰，为什么需要这个东西呢，假设有两个线程都需要实现looper机制，这两个线程的Looper和MessageQueue肯定是不一样的，而且一个线程只能有一个Looper和MessageQueue，这点从上面Looper.prepare()的源码看出，当在两个线程各创建了一个Handler时，怎么保证这两个handler发的消息不会发到别的线程的消息队列中呢？这就需要handler跟各自线程的Looper和MessageQueue绑定起来，而怎么绑定呢？ 下面是Handler创建的构造函数的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Handler() {
   ...
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &amp;quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&amp;quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码可以看出是通过Looper.myLooper()；方法来进行关联的，Looper.myLooper()的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Looper myLooper() {
    return sThreadLocal.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单的一行代码就实现了绑定，而如果我们不用ThreadLocal，那么就必须提供一个全局的哈希表给Handler来查找关联的线程的Looper了，这就是ThreadLocal的好处，至于ThreadLocal为什么能实现这种效果，下面是ThreadLocal的set方法代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这个方法大致可以看出set进去的value值（Looper）和Thread对象以及this（ThreadLocal）对象关联了，而不同线程的values是不一样的，所以当调用get方法取出Looper时就可以根据不同的线程对象取出不同的值了，就不往下分析了。
以上是Looper和MessageQueue的创建以及循环过程，下面分析下消息的发送过程和处理过程。&lt;/p&gt;
&lt;p&gt;消息的发送过程通常是用handler的sendMessage方法，通过上面handler的类图可以发现还有好多类似的方法，但最终都会走导sendMessageAtTime方法，因此时序图中写的是这个方法，源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean sendMessageAtTime(Message msg, long uptimeMillis)
{
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    }
    else {
       ...
    }
    return sent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送消息过程其实就是消息入队过程，之后便会唤醒阻塞的queue.next()方法。这个方法是在Looper.loop()方法中调用的，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public static void loop() {
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&amp;quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&amp;quot;);
    }
    MessageQueue queue = me.mQueue;    
    ...
    while (true) {
        Message msg = queue.next(); // might block
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
		   ...
            msg.target.dispatchMessage(msg);
           ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;唤醒queue.next（）后就会进入消息处理过程，也就是msg.target.dispatchMessage(msg)，而msg.target其实就是handler对象，从sendMessageAtTime的源码中就可以看出来，handler.dispatchMessage的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第十行的代码就会调用到在new Handler时重写的方法。这里还有必要说下第三行的handleCallback(msg)方法：&lt;/p&gt;
&lt;p&gt;在公司的项目中经常看到一个这样的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;handler.post(new Runnable() {
    @Override
        public void run() {
        	progressDialog.cancel();
        }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;handler在创建的时候并没重写handleMessage方法，为什么可以这样在run方法中进行ui操作呢？查看handler的post源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而sendMessageDelayed方法其实最终也会调用到上面讲过的sendMessageAtTime方法，getPostMessage的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到getPostMessage构造了一个消息对象，对象的callback对象就是post方法中进行UI操作的的Runable对象，从上面dispatchMessage中源码的第三行查看handleCallback代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final void handleCallback(Message message) {
    message.callback.run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正是在这里执行了run方法的操作，因为直接调用Runable的run方法并不会创建一个线程，因此如果handler关联的是UI线程，在handler.post方法中进行UI操作是没问题的，同理不能在这里执行耗时操作。&lt;/p&gt;
&lt;p&gt;以上就是自己对于Android消息处理机制的理解，第一次认真写一篇博客，花费了快一天的时间，希望能坚持下去。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
