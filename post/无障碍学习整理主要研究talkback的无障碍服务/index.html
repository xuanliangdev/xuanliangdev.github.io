<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>无障碍学习整理（基于talkback） - xuanliang</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="xuanliang" />
  <meta name="description" content="一、整理原因： 为了辅助理解无障碍google官方开发文档api的原理。 二、参考文档 无障碍开发google官方文档 三、无障碍服务框架结构分析 3" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.63.2" />


<link rel="canonical" href="https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.0995afa14b62cd93e93cfc066b646c4c17a3eddca0e9d52a1d9dcf5d90aaacd3.css" integrity="sha256-CZWvoUtizZPpPPwGa2RsTBej7dyg6dUqHZ3PXZCqrNM=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="无障碍学习整理（基于talkback）" />
<meta property="og:description" content="一、整理原因： 为了辅助理解无障碍google官方开发文档api的原理。 二、参考文档 无障碍开发google官方文档 三、无障碍服务框架结构分析 3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xuanliangdev.github.io/post/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E4%B8%BB%E8%A6%81%E7%A0%94%E7%A9%B6talkback%E7%9A%84%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/" />
<meta property="article:published_time" content="2019-08-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-03T00:00:00+00:00" />
<meta itemprop="name" content="无障碍学习整理（基于talkback）">
<meta itemprop="description" content="一、整理原因： 为了辅助理解无障碍google官方开发文档api的原理。 二、参考文档 无障碍开发google官方文档 三、无障碍服务框架结构分析 3">
<meta itemprop="datePublished" content="2019-08-03T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-08-03T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="10317">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="无障碍学习整理（基于talkback）"/>
<meta name="twitter:description" content="一、整理原因： 为了辅助理解无障碍google官方开发文档api的原理。 二、参考文档 无障碍开发google官方文档 三、无障碍服务框架结构分析 3"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">XuanLiang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/">This is Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      XuanLiang
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/">This is Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xuanliangdev.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">无障碍学习整理（基于talkback）</h1>
      
      <div class="post-meta">
        <time datetime="2019-08-03" class="post-time">
          2019-08-03
        </time>
        
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一整理原因">一、整理原因：</a></li>
    <li><a href="#二参考文档">二、参考文档</a></li>
    <li><a href="#三无障碍服务框架结构分析">三、无障碍服务框架结构分析</a>
      <ul>
        <li><a href="#31结构">3.1.结构</a></li>
        <li><a href="#32相关类图">3.2、相关类图</a></li>
        <li><a href="#33-无障碍框架aidl接口">3.3 无障碍框架AIDL接口</a></li>
      </ul>
    </li>
    <li><a href="#四流程分析">四、流程分析</a>
      <ul>
        <li><a href="#41accessibilityservice启动流程以talkback开关打开后到talkbackservice启动进行分析">4.1、AccessibilityService启动流程（以talkback开关打开后到TalkbackService启动进行分析）。</a></li>
        <li><a href="#42无障碍模式下视图状态初始化流程">4.2、无障碍模式下视图状态初始化流程。</a></li>
        <li><a href="#43无障碍事件分发流程重要app适配无障碍以及处理无障碍相关问题主要通过该流程入手">4.3、无障碍事件分发流程（重要，app适配无障碍以及处理无障碍相关问题主要通过该流程入手）。</a></li>
        <li><a href="#44执行无障碍事件流程以talkback发出focus无障碍事件到被辅助的app端通过viewrootimpl绘制绿框焦点过程进行分析">4.4、执行无障碍事件流程（以talkback发出focus无障碍事件，到被辅助的app端通过ViewRootImpl绘制绿框焦点过程进行分析）。</a></li>
        <li><a href="#45talkback调用tts读出view中的text的过程">4.5、talkback调用TTS读出view中的text的过程。</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="一整理原因">一、整理原因：</h2>
<p>为了辅助理解无障碍google官方开发文档api的原理。</p>
<h2 id="二参考文档">二、参考文档</h2>
<p><a href="https://developer.android.google.cn/guide/topics/ui/accessibility">无障碍开发google官方文档</a></p>
<h2 id="三无障碍服务框架结构分析">三、无障碍服务框架结构分析</h2>
<h3 id="31结构">3.1.结构</h3>
<p><img src="https://raw.githubusercontent.com/xuanliangdev/blogpic/master/accessibility/%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.jpg" alt=""></p>
<h3 id="32相关类图">3.2、相关类图</h3>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/accessibilityclass.jpg?raw=true" alt=""></p>
<p>整个talkback机制涉及了4个进程，SystemServer（蓝色部分）、Talkback（黄色部分）、被辅助app进程（绿色部分），TTS引擎进程（暂不分析）</p>
<p>四个AIDL接口，图上红色部分</p>
<h4 id="321talkback辅助app实现了accessibilityservice的app">3.2.1、talkback（辅助app，实现了AccessibilityService的app）</h4>
<p>辅助app需要用到的最framewors目录中相关的类，主要是继承AccessibilityService从而接收SystemServer进程发送过来的无障碍事件并进行相关处理</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yservice.png?raw=true" alt=""></p>
<h4 id="322被辅助app进程被辅助app">3.2.2、被辅助app进程（被辅助app）</h4>
<p>被辅助的app的无障碍特性主要是通过扩展Android的View框架的功能对外提供，因此无障碍相关的类主要放在view包中，如下。</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/viewaccessibility.png?raw=true" alt=""></p>
<h4 id="323system_process">3.2.3、system_process</h4>
<p>SystemServer进程中的无障碍服务管理类如下所示，比如核心的AccessibilityManagerService，用于协调辅助app进程和被辅助app进程的交互；TouchExpolorer用于实现“触摸浏览”手势功能等。</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/a11yms.png?raw=true" alt=""></p>
<p>系统进程SystemServer中的AccessibilityManagerService，用来管理所有的无障碍服务，类似AMS，SystemServer启动时会在startOtherServices方法中启动AccessibilityManagerService，startOtherServices方法在ActivityManagerService、PackageManagerService等一些核心服务的后面启动。</p>
<pre><code>com.android.server.SystemServer.java

/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */
private void startOtherServices() {
...
            traceBeginAndSlog(&quot;StartAccessibilityManagerService&quot;);
            try {
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf(&quot;starting Accessibility Manager&quot;, e);
            }
            traceEnd();
...
}
</code></pre><h5 id="334tts">3.3.4、TTS</h5>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/tts.png?raw=true" alt=""></p>
<p>暂不分析</p>
<h3 id="33-无障碍框架aidl接口">3.3 无障碍框架AIDL接口</h3>
<p>理解无障碍框架的aidl的设计是理解无障碍框架的关键。</p>
<p>我们进行无障碍的开发通常会涉及到三个进程：</p>
<p>辅助app（talkback、或者我们自己开发的无障碍应用（比如红包助手））</p>
<p>SystemServer（系统服务进程，管理所有的无障碍服务，并且起到中转的作用，类似AMS的设计）</p>
<p>被辅助的app（）</p>
<p>跨进程通信需要用到aidl接口，无障碍服务框架也不例外，由于涉及到三个进程的通信，并且辅助app通常不需要直接跟被辅助的app通信，大部分通过SystemServer进行中转通信，因此主要涉及到了四个aidl接口：</p>
<p>被辅助app-&gt;SystemServer（IAccessibilityManager.aidl）</p>
<p>SystemServer-&gt;辅助app（IAccessibilityServiceClient.aidl）</p>
<p>辅助app-&gt;SystemServer（IAccessibilityServiceConnection.aidl）</p>
<p>SystemServer-&gt;被辅助app（IAccessibilityInteractionConnection.aidl）</p>
<h4 id="331iaccessibilitymanageraidl客户端被辅助app服务端systemserver">3.3.1、IAccessibilityManager.aidl（客户端：被辅助app、服务端：SystemServer）</h4>
<p>比如当被辅助app产生触摸事件后，会通过这个接口发送无障碍事件给SystemServer进程的AccessibilityManagerService</p>
<pre><code>android.view.accessibility.IAccessibilityManager.aidl

/**
 * Interface implemented by the AccessibilityManagerService called by
 * the AccessibilityManagers.
 *
 * @hide
 */
interface IAccessibilityManager {

    oneway void sendAccessibilityEvent(in AccessibilityEvent uiEvent, int userId);

    long addClient(IAccessibilityManagerClient client, int userId);

    List&lt;AccessibilityServiceInfo&gt; getInstalledAccessibilityServiceList(int userId);

    List&lt;AccessibilityServiceInfo&gt; getEnabledAccessibilityServiceList(int feedbackType, int userId);

    int addAccessibilityInteractionConnection(IWindow windowToken,
            in IAccessibilityInteractionConnection connection,
            String packageName, int userId);

    void removeAccessibilityInteractionConnection(IWindow windowToken);

    void notifyAccessibilityButtonClicked();

    // Requires WRITE_SECURE_SETTINGS
    void performAccessibilityShortcut();

}
</code></pre><h4 id="332-iaccessibilityserviceclientaidl客户端systemserver服务端辅助app">3.3.2 、IAccessibilityServiceClient.aidl（客户端：SystemServer、服务端：辅助app）</h4>
<p>当SystemServer接收到被辅助的app发送的无障碍事件时，会将事件通过该接口传递给辅助app进程进行处理。</p>
<pre><code>android.accessibilityservice.IAccessibilityServiceClient.aidl

/**
 * Top-level interface to an accessibility service component.
 */
oneway interface IAccessibilityServiceClient {

    void onAccessibilityEvent(in AccessibilityEvent event, in boolean serviceWantsEvent);

    void onSoftKeyboardShowModeChanged(int showMode);

    void onPerformGestureResult(int sequence, boolean completedSuccessfully);

    void onAccessibilityButtonClicked();

    void onAccessibilityButtonAvailabilityChanged(boolean available);
    
    ...
}
</code></pre><h4 id="333iaccessibilityserviceconnectionaidl客户端辅助app服务端systemserver">3.3.3、IAccessibilityServiceConnection.aidl（客户端：辅助app、服务端：SystemServer）</h4>
<p>当我们需要找到被辅助的app的某个view的信息时，可以通过该接口的findAccessibilityNodeInfosByViewId方法实现。</p>
<pre><code>android.accessibilityservice.IAccessibilityServiceConnection.aidl

/**
 * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
 */
interface IAccessibilityServiceConnection {

    String[] findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId,
        in Bundle arguments);

    String[] findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    String[] findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    boolean isAccessibilityButtonAvailable();
}
</code></pre><h4 id="heading"></h4>
<h4 id="334iaccessibilityinteractionconnectionaidl客户端systemserver服务端被辅助app">3.3.4、IAccessibilityInteractionConnection.aidl（客户端：SystemServer、服务端：被辅助app）</h4>
<pre><code>android.view.accessibility.IAccessibilityInteractionConnection.aidl

/**
 * Interface for interaction between the AccessibilityManagerService
 * and the ViewRoot in a given window.
 *
 * @hide
 */
oneway interface IAccessibilityInteractionConnection {

    void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId, in Region bounds,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid, in MagnificationSpec spec,
        in Bundle arguments);

    ...

    void findFocus(long accessibilityNodeId, int focusType, in Region bounds, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
        long interrogatingTid, in MagnificationSpec spec);

  ...

    void performAccessibilityAction(long accessibilityNodeId, int action, in Bundle arguments,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, int flags,
        int interrogatingPid, long interrogatingTid);
}
</code></pre><h2 id="四流程分析">四、流程分析</h2>
<h3 id="41accessibilityservice启动流程以talkback开关打开后到talkbackservice启动进行分析">4.1、AccessibilityService启动流程（以talkback开关打开后到TalkbackService启动进行分析）。</h3>
<p>在设置中打开talback开关后，会调用到如下方法，最终会往Settings provider中key为Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES的字段写入Talkback注册的AccessibilityService值（TalkbackService），这个值保存在</p>
<p>/data/system/users/0/settings_secure.xml文件中。（其他app的AccessibilityService也保存在同一个key中）</p>
<pre><code>com.android.settingslib.accessibility.AccessibilityUtils.java

/**
 * Changes an accessibility component's state for {@param userId}.
 */
public static void setAccessibilityServiceState(Context context, ComponentName toggledService,
        boolean enabled, int userId) {
    ...
    Settings.Secure.putStringForUser(context.getContentResolver(),
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
            enabledServicesBuilder.toString(), userId);
}
</code></pre><p>由于AccessibilityManagerService创建时注册了AccessibilityContentObserver，因此马上会收到Settings provider数据变化的监听。</p>
<pre><code>com.android.server.accessibility.AccessibilityServiceConnection.java

private void updateServicesLocked(UserState userState) {
    ...
        if (userState.mEnabledServices.contains(componentName)
                &amp;&amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
            if (service == null) {
                service = new AccessibilityServiceConnection(userState, mContext, componentName,
                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                        this, mWindowManagerService, mGlobalActionPerformer);
            } 
            ...
            service.bindLocked();
        } ...
    }
    ...
    updateAccessibilityEnabledSetting(userState);
}
</code></pre><p>根据获取到的AccessibilityService信息（com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService）创建出AccessibilityServiceConnection。AccessibilityServiceConnection代表了一个无障碍服务，存储用于管理这个服务需要的所有数据，提供了开始/停止服务和在服务管理的数据结构中添加或者移除这个服务的api。</p>
<p>接着调用bindServiceAsUser方法来绑定服务。</p>
<pre><code>com.android.server.accessibility.AccessibilityServiceConnection.java

public void bindLocked() {
    ...
    try {
        ...
        if (mService == null &amp;&amp; mContext.bindServiceAsUser(
                mIntent, this, flags, new UserHandle(userState.mUserId))) {
            userState.getBindingServicesLocked().add(mComponentName);
        }
    } ...
}
</code></pre><p>服务启动后会跨进程调用到TalkbackService(AccessibilityService)的onBind方法</p>
<pre><code>android.accessibilityservice.AccessibilityService

/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        ...
        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }
...
    });
}
</code></pre><p>onBind方法返回的是一个IAccessibilityServiceClientWrapper的binder对象</p>
<pre><code>/**
 * Implements the internal {@link IAccessibilityServiceClient} interface to convert
 * incoming calls to it back to calls on an {@link AccessibilityService}.
 *
 * @hide
 */
public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
        implements HandlerCaller.Callback {
    ...

    private final HandlerCaller mCaller;

    private final Callbacks mCallback;

    private int mConnectionId = AccessibilityInteractionClient.NO_ID;

    public IAccessibilityServiceClientWrapper(Context context, Looper looper,
            Callbacks callback) {
        mCallback = callback;
        mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);
    }

    public void init(IAccessibilityServiceConnection connection, int connectionId,
            IBinder windowToken) {
        Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                connection, windowToken);
        mCaller.sendMessage(message);
    }

    ...

    public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {
        Message message = mCaller.obtainMessageBO(
                DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);
        mCaller.sendMessage(message);
    }
...

    @Override
    public void executeMessage(Message message) {
        switch (message.what) {
            case DO_ON_ACCESSIBILITY_EVENT: {
                AccessibilityEvent event = (AccessibilityEvent) message.obj;
                boolean serviceWantsEvent = message.arg1 != 0;
                if (event != null) {
                    // Send the event to AccessibilityCache via AccessibilityInteractionClient
                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);
                    if (serviceWantsEvent
                            &amp;&amp; (mConnectionId != AccessibilityInteractionClient.NO_ID)) {
                        // Send the event to AccessibilityService
                        mCallback.onAccessibilityEvent(event);
                    }
                    ...
                }
            } return;

            ...
            case DO_INIT: {
                mConnectionId = message.arg1;
                SomeArgs args = (SomeArgs) message.obj;
                IAccessibilityServiceConnection connection =
                        (IAccessibilityServiceConnection) args.arg1;
                IBinder windowToken = (IBinder) args.arg2;
                args.recycle();
                if (connection != null) {
                    AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                            connection);
                    mCallback.init(mConnectionId, windowToken);
                    mCallback.onServiceConnected();
                }...
            } return;
...
        }
    }
}
</code></pre><p>IAccessibilityServiceClientWrapper中保存了一个HandlerCaller和Callbacks对象，其中HandlerCaller主要是将SystemServer进程中AccessibilityServiceConnection的binder call的binder线程调研切换到AccessibilityService的主线程调用。Callbacks对象则将IAccessibilityServiceClientWrapper中的调用回调到AccessibilityService中。</p>
<p>AccessibilityService返回binder后会走到AccessibilityServiceConnection的onServiceConnected调用中:</p>
<pre><code>com.android.server.accessibility.AccessibilityServiceConnection.java

@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        ...
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        ...
        userState.addServiceLocked(this);
        mSystemSupport.onClientChange(false);
        // Initialize the service on the main handler after we're done setting up for
        // the new configuration (for example, initializing the input filter).
        mMainHandler.sendMessage(obtainMessage(
                AccessibilityServiceConnection::initializeService, this));
    }
}
</code></pre><pre><code>private void initializeService() {
    IAccessibilityServiceClient serviceInterface = null;
    ...
    try {
        serviceInterface.init(this, mId, mOverlayWindowToken);
    } catch (RemoteException re) {
        ...
    }
}
</code></pre><p>在serviceInterface.init方法中（binder调用）将这个AccessibilityServiceConnection、mId和mOverlayWindowToken传给AccessibilityService完成初始化工作。</p>
<p>初始化时会调用</p>
<pre><code>AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
        connection);
</code></pre><p>将AccessibilityServiceConnection保存到AccessibilityInteractionClient中。</p>
<h3 id="42无障碍模式下视图状态初始化流程">4.2、无障碍模式下视图状态初始化流程。</h3>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/findAccessibilityNodeInfoByAccessibilityId.jpg?raw=true" alt=""></p>
<h5 id="分析该流程原因">分析该流程原因：</h5>
<h5 id="为了辅助理解如下方法">为了辅助理解如下方法：</h5>
<h5 id="1getaccessibilitynodeprovider">1、getAccessibilityNodeProvider</h5>
<h5 id="2oninitializeaccessibilitynodeinfo">2、onInitializeAccessibilityNodeInfo</h5>
<p>1、talkback打开状态下，新的应用打开时，TalkbackService会接收到类型为TYPE_WINDOWS_CHANGED的无障碍事件，这个事件是SystemServer进程接收到其他进程发出的TYPE_VIEW_ACCESSIBILITY_FOCUSED事件时附带发出的，应用发出TYPE_VIEW_ACCESSIBILITY_FOCUSED事件的流程在下一节分析，暂时跳过。</p>
<p>2、当tailback收到TYPE_WINDOWS_CHANGED事件时，会间接调用调用父类AccessibilityService的getRootInActiveWindow方法，如上图，经过SystemServer进程中转后会调用到DecorView的getAccessibilityNodeProvider，由于DecorView没有重写getAccessibilityNodeProvider方法，因此会调用到View的createAccessibilityNodeInfo方法，进一步会调用到<strong>onInitializeAccessibilityNodeInfo</strong>方法，如果没有重写该方法，则默认实现在onInitializeAccessibilityNodeInfoInternal中。</p>
<p>3、AccessibilityNodePrefetcher在取出DecorView的无障碍节点后，会进一步通过prefetchDescendantsOfRealNode方法取子view的无障碍节点。同理，如果我们重写了<strong>getAccessibilityNodeProvider</strong>方法（一些特殊的自定义view需要自己重写该方法，比如webview，android.widget.NumberPicker等），重写getAccessibilityNodeProvider，需要我们实现一个AccessibilityNodeProvider的子类，来实现虚拟的view来支持无障碍模式。通常实现比较复杂的view时会重写这两个方法</p>
<h3 id="43无障碍事件分发流程重要app适配无障碍以及处理无障碍相关问题主要通过该流程入手">4.3、无障碍事件分发流程（重要，app适配无障碍以及处理无障碍相关问题主要通过该流程入手）。</h3>
<p>流程：被辅助app将无障碍事件发送给辅助app，systemserver进程作为中转，接口为IAccessibilityManager.aidl和IAccessibilityServiceClient.aidl</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/sendaccessibilityevent.jpg?raw=true" alt=""></p>
<h5 id="分析该流程原因-1">分析该流程原因：</h5>
<h5 id="为了辅助理解如下方法-1">为了辅助理解如下方法：</h5>
<h5 id="1sendaccessibilityevent"><strong>1、sendAccessibilityEvent</strong></h5>
<p><strong>2、sendAccessibilityEventUnchecked</strong></p>
<p><strong>3、onInitializeAccessibilityEvent</strong></p>
<p><strong>4、dispatchPopulateAccessibilityEvent</strong></p>
<p><strong>5、onPopulateAccessibilityEvent</strong></p>
<p><strong>6、onRequestSendAccessibilityEvent</strong></p>
<p>talkback开启触摸浏览（Explore by Touch）模式下输入事件的传递</p>
<p>1、由于talkback的无障碍服务中声明了android:canRequestTouchExplorationMode=&quot;true&rdquo;，因此开启talkback后AccessibilityManagerService会更新AccessibilityInputFilter成员变量的触摸浏览（FLAG_FEATURE_TOUCH_EXPLORATION）的特性为true。</p>
<pre><code>com.android.server.accessibility.AccessibilityInputFilter

private void enableFeatures() {
    ...
    if ((mEnabledFeatures &amp; FLAG_FEATURE_TOUCH_EXPLORATION) != 0) {
        mTouchExplorer = new TouchExplorer(mContext, mAms);
        addFirstEventHandler(mTouchExplorer);
    }
    ...
}
</code></pre><p>触摸浏览特性开启后会创建一个TouchExplorer对象。AccessibilityInputFilter继承自InputFilter，对输入事件进行过滤，通过和TouchExplorer配合从而实现talkback模式下的触摸浏览手势。</p>
<pre><code>/**
 * This class is a strategy for performing touch exploration. It
 * transforms the motion event stream by modifying, adding, replacing,
 * and consuming certain events. The interaction model is:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;1. One finger moving slow around performs touch exploration.&lt;/li&gt;
 *   &lt;li&gt;2. One finger moving fast around performs gestures.&lt;/li&gt;
 *   &lt;li&gt;3. Two close fingers moving in the same direction perform a drag.&lt;/li&gt;
 *   &lt;li&gt;4. Multi-finger gestures are delivered to view hierarchy.&lt;/li&gt;
 *   &lt;li&gt;5. Two fingers moving in different directions are considered a multi-finger gesture.&lt;/li&gt;
 *   &lt;li&gt;7. Double tapping clicks on the on the last touch explored location if it was in
 *          a window that does not take focus, otherwise the click is within the accessibility
 *          focused rectangle.&lt;/li&gt;
 *   &lt;li&gt;7. Tapping and holding for a while performs a long press in a similar fashion
 *          as the click above.&lt;/li&gt;
 * &lt;ol&gt;
 *
 * @hide
 */
class TouchExplorer extends BaseEventStreamTransformation
        implements AccessibilityGestureDetector.Listener {
...
</code></pre><p>该类负责将普通的触摸事件转换为触摸浏览手势，比如将MotionEvent.ACTION_DOWN事件转换为悬停事件）（MotionEvent.ACTION_HOVER_ENTER）。因此在talkback模式下，当我们点击一次view上的控件时，应用收到的是（ACTION_HOVER_ENTER）事件，而只有双击才会传递我们熟悉的ACTION_DOWN事件</p>
<p>*ViewRootImpl:View层次结构的根。View的<strong>绘制流程</strong>（测量measure、布局layout、绘制draw）和输入<strong>事件的分发流程</strong>都是从ViewRootImp开始。</p>
<p>1、ViewRootImpl的内部类WindowInputEventReceiver从native方法调起dispatchInputEvent方法。</p>
<p>2、ViewRootImpl调用deliverInputEvent传递事件输入事件。</p>
<p>3、从顶层的DecorView的dispatchPointerEvent开始分发输入事件。</p>
<pre><code>android.view.View.java

/**
 * Dispatch a pointer event.
 * &lt;p&gt;
 * Dispatches touch related pointer events to {@link #onTouchEvent(MotionEvent)} and all
 * other events to {@link #onGenericMotionEvent(MotionEvent)}.  This separation of concerns
 * reinforces the invariant that {@link #onTouchEvent(MotionEvent)} is really about touches
 * and should not be expected to handle other pointing device features.
 * &lt;/p&gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 * @hide
 */
public final boolean dispatchPointerEvent(MotionEvent event) {
    if (event.isTouchEvent()) {
        return dispatchTouchEvent(event);
    } else {
        return dispatchGenericMotionEvent(event);
    }
}

...

/**
 * Returns true if this motion event is a touch event.
 * &lt;p&gt;
 * Specifically excludes pointer events with action {@link #ACTION_HOVER_MOVE},
 * {@link #ACTION_HOVER_ENTER}, {@link #ACTION_HOVER_EXIT}, or {@link #ACTION_SCROLL}
 * because they are not actually touch events (the pointer is not down).
 * &lt;/p&gt;
 * @return True if this motion event is a touch event.
 * @hide
 */
public final boolean isTouchEvent() {
    return nativeIsTouchEvent(mNativePtr);
}
</code></pre><p>在dispatchPointerEvent方法中会有event.isTouchEvent()的判断，如果talkback模式下，由于收到的是ACTION_HOVER_ENTER事件，因此不会走dispatchTouchEvent方法而是dispatchGenericMotionEvent方法。</p>
<pre><code>android.view.View.java
/**
 * Dispatch a generic motion event.
 * &lt;p&gt;
 * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
 * are delivered to the view under the pointer.  All other generic motion events are
 * delivered to the focused view.  Hover events are handled specially and are delivered
 * to {@link #onHoverEvent(MotionEvent)}.
 * &lt;/p&gt;
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
public boolean dispatchGenericMotionEvent(MotionEvent event) {
...
    final int source = event.getSource();
    if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
        final int action = event.getAction();
        if (action == MotionEvent.ACTION_HOVER_ENTER
                || action == MotionEvent.ACTION_HOVER_MOVE
                || action == MotionEvent.ACTION_HOVER_EXIT) {
            if (dispatchHoverEvent(event)) {
                return true;
            }
        } else if (dispatchGenericPointerEvent(event)) {
            return true;
        }
    } else if (dispatchGenericFocusedEvent(event)) {
        return true;
    }
	...
    return false;
}
</code></pre><p>在dispatchGenericMotionEvent中，如果是Hover events，则会走到dispatchHoverEvent方法中。这个方法的机制类似dispatchTouchEvent的流程，是一个责任链模式的实现，不详细展开，默认会传到最后一个子节点的onHoverEvent方法。接着该方法会调用到sendAccessibilityHoverEvent里。</p>
<p><strong>6、sendAccessibilityHoverEvent方法接着会调用以下方法。</strong></p>
<p>​     <strong>sendAccessibilityEvent</strong></p>
<p>​       <strong>-&gt;sendAccessibilityEventUnchecked</strong></p>
<p>​           <strong>-&gt;onInitializeAccessibilityEvent</strong></p>
<p>​           <strong>-&gt;dispatchPopulateAccessibilityEvent</strong></p>
<p>​                <strong>-&gt;onPopulateAccessibilityEvent</strong></p>
<p>​           <strong>-&gt;onRequestSendAccessibilityEvent</strong>（只在ViewGroup中有默认实现）</p>
<p>*<strong>重要：以上六个方法为当我们自定义view时适配无障碍模式可以覆盖实现的方法，可以重写view的这些方法或者实现View.AccessibilityDelegate来解决一些特殊场景下talkback播报的问题。更详细的用法可以参考官方文档。</strong></p>
<p>以talkback模式下朗读一个textview上的文字为例，textview重写了view中的onPopulateAccessibilityEventInternal方法</p>
<pre><code>android.widget.TextView.java

/** @hide */
@Override
public void onPopulateAccessibilityEventInternal(AccessibilityEvent event) {
    super.onPopulateAccessibilityEventInternal(event);

    final CharSequence text = getTextForAccessibility();
    if (!TextUtils.isEmpty(text)) {
        event.getText().add(text);
    }
}
</code></pre><p>getTextForAccessibility方法会取到当前textview中显示的text，然后将该text的内容填充到AccessibilityEvent中发送出去。后面talkback会取出这个text并朗读出来。</p>
<pre><code>android.view.View

public void onPopulateAccessibilityEvent(AccessibilityEvent event) {
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.onPopulateAccessibilityEvent(this, event);
    } else {
        onPopulateAccessibilityEventInternal(event);
    }
}
</code></pre><p>因此如果我们需要自定义textview在talkback模式下朗读的内容，或者不让某个view的内容在talkback模式下被朗读出来，可以考虑重写onPopulateAccessibilityEvent方法。</p>
<p>7、当我们通过第6步修改view中无障碍节点的信息后，被点击的View的sendAccessibilityEventUnchecked方法会向上通过DecorView传递到ViewRootImpl的requestSendAccessibilityEvent方法中，</p>
<pre><code>android.view.ViewRootImpl

public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {
    ...
    final int eventType = event.getEventType();
    switch (eventType) {
        case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED: {
            final long sourceNodeId = event.getSourceNodeId();
            final int accessibilityViewId = AccessibilityNodeInfo.getAccessibilityViewId(
                    sourceNodeId);
            View source = mView.findViewByAccessibilityId(accessibilityViewId);
            if (source != null) {
                AccessibilityNodeProvider provider = source.getAccessibilityNodeProvider();
                if (provider != null) {
                    final int virtualNodeId = AccessibilityNodeInfo.getVirtualDescendantId(
                            sourceNodeId);
                    final AccessibilityNodeInfo node;
                    node = provider.createAccessibilityNodeInfo(virtualNodeId);
                    setAccessibilityFocus(source, node);
                }
            }
        } break;
        ...
    }
    mAccessibilityManager.sendAccessibilityEvent(event);
    return true;
}
</code></pre><p>接着无障碍事件会通过AccessibilityManager的sendAccessibilityEvent方法跨进程调用systemserver进程的AccessibilityManagerService，将类型为TYPE_VIEW_HOVER_ENTER的AccessibilityEvent事件传递到talkback的的TalkBackService（继承自AccessibilityService）的onAccessibilityEvent方法中（或者其他实现了AccessibilityService的应用）。</p>
<h3 id="44执行无障碍事件流程以talkback发出focus无障碍事件到被辅助的app端通过viewrootimpl绘制绿框焦点过程进行分析">4.4、执行无障碍事件流程（以talkback发出focus无障碍事件，到被辅助的app端通过ViewRootImpl绘制绿框焦点过程进行分析）。</h3>
<p>流程：辅助app（talkback）将无障碍事件发送给被辅助app，systemserver进程作为中转，接口为IAccessibilityServiceConnection.aidl和IAccessibilityInteractionConnection.aidl</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/requesfocus.jpg?raw=true" alt=""></p>
<h5 id="分析该流程原因-2">分析该流程原因：</h5>
<h5 id="为了辅助理解如下方法-2">为了辅助理解如下方法：</h5>
<h5 id="accessibilitynodeinfoperformaction">AccessibilityNodeInfo.performAction</h5>
<p>1、在talkback中有个AccessibilityEventProcessor类对无障碍事件进行集中处理，根据无障碍事件的不同类型分发到不同的处理器进行处理，比如ProcessorFocusAndSingleTap这个处理器会对类型为TYPE_VIEW_HOVER_ENTER的无障碍事件进行处理，ProcessorEventQueue（主要用于tts朗读，后面分析）这个处理器会处理所有的无障碍事件。</p>
<p>2、在前面一节4.2中，触摸事件TYPE_VIEW_HOVER_ENTER传递到了TalkBackService，而ProcessorFocusAndSingleTap这个类会对TYPE_VIEW_HOVER_ENTER这个事件进行处理，tryFocusing函数中会调用AccessibilityNodeInfo的performAction方法，AccessibilityNodeInfo的节点信息就是4.2节中触摸到的view的信息，因此通过AccessibilityManagerService进程中转后，会最终调用到我们触摸到的view的<strong>performAccessibilityAction</strong>方法中去（我们也可以通过调用这个方法处理一些无障碍焦点的问题）。</p>
<p>3、在performAccessibilityAction会调用到performAccessibilityActionInternal，接着如果判断到是ACTION_ACCESSIBILITY_FOCUS事件，则会调用requestAccessibilityFocus函数</p>
<pre><code>android.view.View

public boolean requestAccessibilityFocus() {
    ...
    if ((mPrivateFlags2 &amp; PFLAG2_ACCESSIBILITY_FOCUSED) == 0) {
        mPrivateFlags2 |= PFLAG2_ACCESSIBILITY_FOCUSED;
        ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            viewRootImpl.setAccessibilityFocus(this, null);
        }
        invalidate();
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
        return true;
    }
    return false;
}
</code></pre><p>这个函数里有两个重要的操作，一是调用ViewRootImpl的setAccessibilityFocus将自身设置为focus的view，然后调用invalidate触发重绘操作，ViewRootImpl会在onPostDraw中执行drawAccessibilityFocusedDrawableIfNeeded来绘制出绿框。</p>
<pre><code>android.view.ViewRootImpl.java

/**
 * We want to draw a highlight around the current accessibility focused.
 * Since adding a style for all possible view is not a viable option we
 * have this specialized drawing method.
 *
 * Note: We are doing this here to be able to draw the highlight for
 *       virtual views in addition to real ones.
 *
 * @param canvas The canvas on which to draw.
 */
private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas) {
    final Rect bounds = mAttachInfo.mTmpInvalRect;
    if (getAccessibilityFocusedRect(bounds)) {
        final Drawable drawable = getAccessibilityFocusedDrawable();
        if (drawable != null) {
            drawable.setBounds(bounds);
            drawable.draw(canvas);
        }
    } else if (mAttachInfo.mAccessibilityFocusDrawable != null) {
        mAttachInfo.mAccessibilityFocusDrawable.setBounds(0, 0, 0, 0);
    }
}

private boolean getAccessibilityFocusedRect(Rect bounds) {
    final AccessibilityManager manager = AccessibilityManager.getInstance(mView.mContext);
    if (!manager.isEnabled() || !manager.isTouchExplorationEnabled()) {
        return false;
    }

    final View host = mAccessibilityFocusedHost;
    if (host == null || host.mAttachInfo == null) {
        return false;
    }

    final AccessibilityNodeProvider provider = host.getAccessibilityNodeProvider();
    if (provider == null) {
        host.getBoundsOnScreen(bounds, true);
    } else if (mAccessibilityFocusedVirtualView != null) {
        mAccessibilityFocusedVirtualView.getBoundsInScreen(bounds);
    } else {
        return false;
    }

    // Transform the rect into window-relative coordinates.
    final AttachInfo attachInfo = mAttachInfo;
    bounds.offset(0, attachInfo.mViewRootImpl.mScrollY);
    bounds.offset(-attachInfo.mWindowLeft, -attachInfo.mWindowTop);
    if (!bounds.intersect(0, 0, attachInfo.mViewRootImpl.mWidth,
            attachInfo.mViewRootImpl.mHeight)) {
        // If no intersection, set bounds to empty.
        bounds.setEmpty();
    }
    return !bounds.isEmpty();
}
</code></pre><p>第二个操作是调用sendAccessibilityEvent方法，将TYPE_VIEW_ACCESSIBILITY_FOCUSED事件发送出去，这个事件会被talkback处理，从而调用tts引擎读出view的内容，这个流程分析如下。</p>
<h3 id="45talkback调用tts读出view中的text的过程">4.5、talkback调用TTS读出view中的text的过程。</h3>
<p>由于talkback最新版本属于google维护，没有开源代码，网上公开的只有talkback6.0版本的代码，因此基于6.0版本的概要分析如下</p>
<p>无障碍事件的分发跟4.2节流程一样，talkback处理TYPE_VIEW_ACCESSIBILITY_FOCUSED事件大致流程如下：</p>
<p><img src="https://github.com/xuanliangdev/blogpic/blob/master/accessibility/talkbacktts.jpg?raw=true" alt=""></p>
<p>talkback调用tts进行朗读主要通过com.google.android.accessibility.compositor.Compositor这个类来控制，这个类中又有一个ParseTree的类来管理朗读的内容，ParseTree通过一个compositor.json的文件来定义朗读的内容的规则，比如一个简单的按钮，在talkback模式下不仅需要读出按钮的内容，还需要读出按钮的状态（比如disabled），因此朗读的内容是一个拼接起来的结果，比如下面就是通过解析compositor.json来读出一个按钮内容的大概流程。</p>
<p>以下在compositor.json中某几个节点类型的定义，</p>
<p>$开头会被解析成ParseTreeVariableNode，比如 &ldquo;node.text&quot;经过ParseTreeVariableNode的处理会取出Button中text（也就是AccessibilityEvent中AccessibilityNodeInfo中的mText）</p>
<p>@开头会被解析成ParseTreeResourceNode，最后会通过Resource取出字段的内容，比如&rdquo;@string/value_button&quot;中文下会被解析为“按钮”，</p>
<p>&ldquo;@string/value_disabled&quot;中文下会被解析为“已停用”。</p>
<pre><code>     &quot;notify_disabled&quot;: {
      &quot;if&quot;: &quot;$node.isActionable &amp;&amp; !$node.isEnabled&quot;,
      &quot;then&quot;: &quot;@string/value_disabled&quot;
     },

....

     &quot;get_node_text&quot;: {  // AccessibilityNodeInfoUtils.getNodeText()
      &quot;fallback&quot;: [
        {
          // If focusing on-screen keyboard key... apply speak-passwords policy to hide key name.
          &quot;if&quot;: &quot;$event.sourceIsKeyboard &amp;&amp; $global.lastTextEditIsPassword &amp;&amp; !$global.speakPasswordOnAndroidShowingPasswords&quot;,
          &quot;then&quot;: &quot;@string/symbol_bullet&quot;,
          &quot;else&quot;: &quot;$node.contentDescription&quot;
        },
        &quot;$node.text&quot;
      ]
    },
    &quot;get_role_description_or_default&quot;: {
      &quot;fallback&quot;: [
        &quot;$node.roleDescription&quot;,
        &quot;%node_role&quot;
      ]
    },
    &quot;node_role&quot;: {
      &quot;switch&quot;: &quot;$node.role&quot;,
      &quot;cases&quot;: {
        &quot;button&quot;: &quot;@string/value_button&quot;,
        &quot;check_box&quot;: &quot;@string/value_checkbox&quot;,
        &quot;drop_down_list&quot;: &quot;@string/value_spinner&quot;,
        &quot;edit_text&quot;: &quot;@string/value_edit_box&quot;,
        &quot;grid&quot;: &quot;@string/value_gridview&quot;,
        &quot;image&quot;: &quot;@string/value_image&quot;,
        &quot;image_button&quot;: &quot;@string/value_button&quot;, // Same as |button|
        &quot;list&quot;: &quot;@string/value_listview&quot;,
        &quot;pager&quot;: &quot;@string/value_pager&quot;,
        &quot;progress_bar&quot;: &quot;@string/value_progress_bar&quot;,
        &quot;radio_button&quot;: &quot;@string/value_radio_button&quot;,
        &quot;seek_control&quot;: &quot;@string/value_seek_bar&quot;,
        &quot;switch&quot;: &quot;@string/value_switch&quot;,
        &quot;tab_bar&quot;: &quot;@string/value_tabwidget&quot;,
        &quot;toggle_button&quot;: &quot;@string/value_switch&quot;, // Same as |switch|
        &quot;view_group&quot;: &quot;&quot;, // None
        &quot;web_view&quot;: &quot;@string/value_webview&quot;,
        &quot;checked_text_view&quot;: &quot;&quot; // None
      }
    },
</code></pre><p>ttsOutput</p>
<p>TYPE_VIEW_ACCESSIBILITY_FOCUSED</p>
<p>​     get_description_for_tree</p>
<p>​        StateNameRolePosition</p>
<p>​              tree_description_with_label</p>
<p>​                 append_description_for_tree</p>
<p>​                 |  &ldquo;conditionalPrepend(%description_for_tree_status, %description_for_tree_nodes)&rdquo;</p>
<p>​                 |      description_for_tree_nodes</p>
<p>​                 |           get_description_for_node</p>
<p>​                 |             rule_default</p>
<p>​                 |                node_text_and_role</p>
<p>​                 |                    rule_view_group（%get_node_text）</p>
<p>​                 |                    |    &ldquo;$node.text&rdquo;&mdash;&mdash;&mdash;&ndash;取出“Button的text”</p>
<p>​                 |                    get_role_description_or_default</p>
<p>​                 |                    |     %node_role&mdash;&mdash;&mdash;&mdash;-取出“按钮的String资源”</p>
<p>​                  notify_disabled&mdash;&mdash;&mdash;&mdash;-取出“已停用的String资源”</p>
<p>最后talkback朗读“xxx，按钮，已停用”</p>
<p>​</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">xuanliang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2019-08-03
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/preference%E4%BD%93%E7%B3%BB%E5%AD%A6%E4%B9%A0/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">preference体系学习总结</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="https://github.com/xuanliangdev" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://xuanliangdev.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        xuanliang
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
